type vec3 = f32[3];
# ���ͺ�������������
func swap<T> (a : T ref, b : T ref) -> void {
    let t : T = a;
    a = b;
    b = t;
}

# ���߽ṹ��
struct Ray {
    o : vec3;  # ����ԭ��
    d : vec3;  # ���߷���
    func Ray(self, o : vec3, d : vec3) { self.o = o; self.d = d; }
};

# ������ӿ�
interface Geometry {
    func intersect(r : Ray) -> bool;  # �жϼ������������Ƿ��ཻ
};

# ����̳м�����ӿ�
struct Sphere : Geometry {
    center : vec3;  # ����
    radius : f32;   # �뾶
    func Sphere(self, c, r) { self.center = c; self.radius = r; }
    func intersect(self, r : Ray) -> bool {
        let oc = r.o - self.center;
        let d = dot(r.d, oc);
        if (d > 0) 
            return false;
        return d * d - dot(oc, oc) + self.radius * self.radius >= 0;
    }
};

# ������̳м�����ӿ�
struct Box : Geometry {
    minp : vec3;  # ��ʼ����
    maxp : vec3;  # ��������
    func Sphere(self, c, r) { self.center = c; self.radius = r; }
    func intersect(self, r : Ray) -> bool {
        let tmin : f32 = (minp[0] - r.o[0]) / r.d[0];
        let tmax : f32 = (maxp[0] - r.o[0]) / r.d[0];
        if (tmin > tmax) swap(tmin, tmax);
    
        let tymin : f32 = (minp[1] - r.o[1]) / r.d[1];
        let tymax : f32 = (maxp[1] - r.o[1]) / r.d[1];
        if (tymin > tymax) swap(tymin, tymax);
        if ((tmin > tymax) || (tymin > tmax)) return false;
        if (tymin > tmin) tmin = tymin;
        if (tymax < tmax) tmax = tymax;
        
        let tzmin : f32 = (minp[2] - r.o[2]) / r.d[2];
        let tzmax : f32 = (maxp[2] - r.o[2]) / r.d[2];
        if (tzmin > tzmax) swap(tzmin, tzmax);
        if ((tmin > tzmax) || (tzmin > tmax)) return false;
        if (tzmin > tmin) tmin = tzmin;
        if (tzmax < tmax) tmax = tzmax;
    
        return true;
    }
};
};

# ������ӿ�
interface Geometry {
    func intersect(r : Ray) -> bool;  # �жϼ������������Ƿ��ཻ
};

# ����̳м�����ӿ�
struct Sphere : Geometry {
    center : vec3;  # ����
    radius : f32;   # �뾶
    func Sphere(self, c, r) { self.center = c; self.radius = r; }
    func intersect(self, r : Ray) -> bool {
        let oc = r.o - self.center;
        let d = dot(r.d, oc);
        if (d > 0) return false;
        return d * d - dot(oc, oc) + self.radius * self.radius >= 0;
    }
};

# ������̳м�����ӿ�
struct Box : Geometry {
    minp : vec3;  # ��ʼ����
    maxp : vec3;  # ��������
    func Sphere(self, c, r) { self.center = c; self.radius = r; }
    func intersect(self, r : Ray) -> bool {
        let tmin : f32 = (minp[0] - r.o[0]) / r.d[0];
        let tmax : f32 = (maxp[0] - r.o[0]) / r.d[0];
        if (tmin > tmax) swap(tmin, tmax);
    
        let tymin : f32 = (minp[1] - r.o[1]) / r.d[1];
        let tymax : f32 = (maxp[1] - r.o[1]) / r.d[1];
        if (tymin > tymax) swap(tymin, tymax);
        if ((tmin > tymax) || (tymin > tmax)) return false;
        if (tymin > tmin) tmin = tymin;
        if (tymax < tmax) tmax = tymax;
        
        let tzmin : f32 = (minp[2] - r.o[2]) / r.d[2];
        let tzmax : f32 = (maxp[2] - r.o[2]) / r.d[2];
        if (tzmin > tzmax) swap(tzmin, tzmax);
        if ((tmin > tzmax) || (tzmin > tmax)) return false;
        if (tzmin > tmin) tmin = tzmin;
        if (tzmax < tmax) tmax = tzmax;
    
        return true;
    }
};

# ���ݹ����뼸�����Ƿ��ཻ����ɫ�������ز�ͬ����ɫ
func shade<T : Geometry>(g : T, ray : Ray) -> vec3 {
    if (g.intersect(ray))
        return vec3(1.0f, 0.0f, 0.0f);
    else
        return vec3(0.0f, 0.0f, 0.0f);
}
