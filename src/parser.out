Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    SAMPLER

Grammar

Rule 0     S' -> start
Rule 1     start -> translation_unit
Rule 2     translation_unit -> block_decl translation_unit
Rule 3     translation_unit -> function_def translation_unit
Rule 4     translation_unit -> empty
Rule 5     block_decl -> type_decl SEMICOLON
Rule 6     block_decl -> variable_decl SEMICOLON
Rule 7     block_decl -> constant_decl SEMICOLON
Rule 8     block_decl -> function_decl SEMICOLON
Rule 9     type_decl -> type_alias_decl
Rule 10    type_decl -> struct_decl
Rule 11    type_decl -> interface_decl
Rule 12    type_alias_decl -> TYPE ID ASSIGN type_spec
Rule 13    variable_decl -> LET declarator declarator_nest
Rule 14    declarator_nest -> COMMA declarator declarator_nest
Rule 15    declarator_nest -> empty
Rule 16    constant_decl -> CONST declarator declarator_nest
Rule 17    declarator -> ID type_spec_colon_opt ASSIGN expression
Rule 18    type_spec_colon_opt -> COLON type_spec
Rule 19    type_spec_colon_opt -> empty
Rule 20    function_decl -> FUNC ID function_sign
Rule 21    function_def -> function_decl block_statement
Rule 22    type_spec -> simple_type
Rule 23    type_spec -> complex_type
Rule 24    type_spec -> generic_type
Rule 25    type_spec -> alias_type
Rule 26    type_spec -> array_type
Rule 27    type_spec -> reference_type
Rule 28    type_spec -> function_type
Rule 29    simple_type -> VOID
Rule 30    simple_type -> BOOL
Rule 31    simple_type -> I8
Rule 32    simple_type -> U8
Rule 33    simple_type -> I16
Rule 34    simple_type -> U16
Rule 35    simple_type -> I32
Rule 36    simple_type -> U32
Rule 37    simple_type -> I64
Rule 38    simple_type -> U64
Rule 39    simple_type -> F16
Rule 40    simple_type -> F32
Rule 41    simple_type -> F64
Rule 42    complex_type -> INTERFACEID generics_specialization_list_opt
Rule 43    complex_type -> STRUCTID generics_specialization_list_opt
Rule 44    generic_type -> GENERICID
Rule 45    alias_type -> TYPEALIASID
Rule 46    array_type -> type_spec LBRACKET int_literal_opt RBRACKET
Rule 47    int_literal_opt -> INT
Rule 48    int_literal_opt -> empty
Rule 49    reference_type -> type_spec REF
Rule 50    function_type -> function_sign
Rule 51    struct_decl -> STRUCT ID new_struct generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE
Rule 52    new_struct -> <empty>
Rule 53    complex_type_colon_opt -> COLON complex_type
Rule 54    complex_type_colon_opt -> empty
Rule 55    interface_decl -> INTERFACE ID new_interface generics_type_list_opt LBRACE interface_member_decl_nest RBRACE
Rule 56    new_interface -> <empty>
Rule 57    generics_type_list_opt -> generics_type_list
Rule 58    generics_type_list_opt -> empty
Rule 59    member_decl_nest -> member_decl member_decl_nest
Rule 60    member_decl_nest -> empty
Rule 61    interface_member_decl_nest -> interface_member_decl interface_member_decl_nest
Rule 62    interface_member_decl_nest -> empty
Rule 63    member_decl -> member_declarator
Rule 64    member_decl -> function_def
Rule 65    member_decl -> type_function_def
Rule 66    type_function_def -> type_function_decl block_statement
Rule 67    interface_member_decl -> function_decl SEMICOLON
Rule 68    interface_member_decl -> type_function_decl SEMICOLON
Rule 69    type_function_decl -> FUNC type_spec function_sign
Rule 70    member_declarator -> ID COLON type_spec SEMICOLON
Rule 71    function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
Rule 72    parameter_decl_list_opt -> parameter_decl parameter_decl_comma_nest
Rule 73    parameter_decl_list_opt -> empty
Rule 74    type_spec_assigntype_opt -> ASSIGNTYPE type_spec
Rule 75    type_spec_assigntype_opt -> empty
Rule 76    parameter_decl_comma_nest -> COMMA parameter_decl parameter_decl_comma_nest
Rule 77    parameter_decl_comma_nest -> empty
Rule 78    parameter_decl -> ID type_spec_colon_opt
Rule 79    generics_type_list -> LESS generics_type generics_type_comma_nest GREATER
Rule 80    generics_type_comma_nest -> COMMA generics_type generics_type_comma_nest
Rule 81    generics_type_comma_nest -> empty
Rule 82    generics_type -> ID generics_type_range_colon_opt
Rule 83    generics_type_range_colon_opt -> COLON generics_type_range
Rule 84    generics_type_range_colon_opt -> empty
Rule 85    generics_type_range -> complex_type
Rule 86    statement -> decl_statement
Rule 87    statement -> block_statement
Rule 88    statement -> expression_statement
Rule 89    statement -> if_statement
Rule 90    statement -> iteration_statement
Rule 91    statement -> jump_statement
Rule 92    decl_statement -> variable_decl SEMICOLON
Rule 93    decl_statement -> constant_decl SEMICOLON
Rule 94    block_statement -> LBRACE statement_nest RBRACE
Rule 95    statement_nest -> statement statement_nest
Rule 96    statement_nest -> empty
Rule 97    expression_statement -> expression_opt SEMICOLON
Rule 98    expression_opt -> expression
Rule 99    expression_opt -> empty
Rule 100   if_statement -> IF LPAREN expression RPAREN statement statement_else_opt
Rule 101   statement_else_opt -> ELSE statement
Rule 102   statement_else_opt -> empty
Rule 103   iteration_statement -> while_clause
Rule 104   iteration_statement -> for_clause
Rule 105   while_clause -> WHILE LPAREN expression RPAREN statement
Rule 106   for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
Rule 107   for_init_statement -> expression_statement
Rule 108   for_init_statement -> decl_statement
Rule 109   jump_statement -> BREAK SEMICOLON
Rule 110   jump_statement -> CONTINUE SEMICOLON
Rule 111   jump_statement -> RETURN expression_opt SEMICOLON
Rule 112   expression -> assign_expr
Rule 113   expression -> binary_expr
Rule 114   expression -> unary_expr
Rule 115   expression -> primary_expr
Rule 116   assign_expr -> expression ASSIGN expression
Rule 117   binary_expr -> expression PLUS expression
Rule 118   binary_expr -> expression MINUS expression
Rule 119   binary_expr -> expression MUL expression
Rule 120   binary_expr -> expression DIV expression
Rule 121   binary_expr -> expression AND expression
Rule 122   binary_expr -> expression OR expression
Rule 123   binary_expr -> expression XOR expression
Rule 124   binary_expr -> expression MOD expression
Rule 125   binary_expr -> expression LSHIFT expression
Rule 126   binary_expr -> expression RSHIFT expression
Rule 127   binary_expr -> expression LOGICAL_OR expression
Rule 128   binary_expr -> expression LOGICAL_AND expression
Rule 129   binary_expr -> expression NOT_EQUAL expression
Rule 130   binary_expr -> expression EQUAL expression
Rule 131   binary_expr -> expression LESS_EQUAL expression
Rule 132   binary_expr -> expression LESS expression
Rule 133   binary_expr -> expression GREATER_EQUAL expression
Rule 134   binary_expr -> expression GREATER expression
Rule 135   unary_expr -> unary_operation primary_expr
Rule 136   unary_operation -> NOT
Rule 137   unary_operation -> LOGICAL_NOT
Rule 138   unary_operation -> PLUS
Rule 139   unary_operation -> MINUS
Rule 140   primary_expr -> operand
Rule 141   primary_expr -> call_expr
Rule 142   primary_expr -> index_expr
Rule 143   primary_expr -> cast_expr
Rule 144   primary_expr -> new_expr
Rule 145   primary_expr -> member_expr
Rule 146   primary_expr -> lambda_expr
Rule 147   primary_expr -> io_expr
Rule 148   operand -> INT
Rule 149   operand -> HEXADECIMAL
Rule 150   operand -> FLOAT
Rule 151   operand -> DOUBLE
Rule 152   operand -> STRING
Rule 153   operand -> ID
Rule 154   operand -> LPAREN expression RPAREN
Rule 155   member_expr -> primary_expr DOT ID
Rule 156   index_expr -> primary_expr LBRACKET expression RBRACKET
Rule 157   cast_expr -> LPAREN type_spec RPAREN expression
Rule 158   new_expr -> type_spec LPAREN parameter_list_opt RPAREN
Rule 159   parameter_list_opt -> parameter_list
Rule 160   parameter_list_opt -> empty
Rule 161   call_expr -> primary_expr LPAREN parameter_list_opt RPAREN
Rule 162   call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
Rule 163   generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER
Rule 164   generics_specialization_list_opt -> empty
Rule 165   type_spec_comma_nest -> COMMA type_spec type_spec_comma_nest
Rule 166   type_spec_comma_nest -> empty
Rule 167   parameter_list -> expression expression_comma_nest
Rule 168   expression_comma_nest -> COMMA expression expression_comma_nest
Rule 169   expression_comma_nest -> empty
Rule 170   lambda_expr -> FUNC function_sign block_statement
Rule 171   io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN
Rule 172   in_out -> IN
Rule 173   in_out -> OUT
Rule 174   empty -> <empty>

Terminals, with rules where they appear

AND                  : 121
ASSIGN               : 12 17 116
ASSIGNTYPE           : 74
BOOL                 : 30
BREAK                : 109
COLON                : 18 53 70 83
COMMA                : 14 76 80 165 168
CONST                : 16
CONTINUE             : 110
DIV                  : 120
DOT                  : 155
DOUBLE               : 151
ELSE                 : 101
EQUAL                : 130
F16                  : 39
F32                  : 40
F64                  : 41
FLOAT                : 150
FOR                  : 106
FUNC                 : 20 69 170
GENERICID            : 44
GENERICMARK          : 162
GREATER              : 79 134 162 163 171
GREATER_EQUAL        : 133
HEXADECIMAL          : 149
I16                  : 33
I32                  : 35
I64                  : 37
I8                   : 31
ID                   : 12 17 20 51 55 70 78 82 153 155
IF                   : 100
IN                   : 172
INT                  : 47 148
INTERFACE            : 55
INTERFACEID          : 42
LBRACE               : 51 55 94
LBRACKET             : 46 156
LESS                 : 79 132 162 163 171
LESS_EQUAL           : 131
LET                  : 13
LOGICAL_AND          : 128
LOGICAL_NOT          : 137
LOGICAL_OR           : 127
LPAREN               : 71 100 105 106 154 157 158 161 162 171
LSHIFT               : 125
MINUS                : 118 139
MOD                  : 124
MUL                  : 119
NOT                  : 136
NOT_EQUAL            : 129
OR                   : 122
OUT                  : 173
PLUS                 : 117 138
RBRACE               : 51 55 94
RBRACKET             : 46 156
REF                  : 49
RETURN               : 111
RPAREN               : 71 100 105 106 154 157 158 161 162 171
RSHIFT               : 126
SAMPLER              : 
SEMICOLON            : 5 6 7 8 67 68 70 92 93 97 106 109 110 111
STRING               : 152 171
STRUCT               : 51
STRUCTID             : 43
TYPE                 : 12
TYPEALIASID          : 45
U16                  : 34
U32                  : 36
U64                  : 38
U8                   : 32
VOID                 : 29
WHILE                : 105
XOR                  : 123
error                : 

Nonterminals, with rules where they appear

alias_type           : 25
array_type           : 26
assign_expr          : 112
binary_expr          : 113
block_decl           : 2
block_statement      : 21 66 87 170
call_expr            : 141
cast_expr            : 143
complex_type         : 23 53 85
complex_type_colon_opt : 51
constant_decl        : 7 93
decl_statement       : 86 108
declarator           : 13 14 16
declarator_nest      : 13 14 16
empty                : 4 15 19 48 54 58 60 62 73 75 77 81 84 96 99 102 160 164 166 169
expression           : 17 98 100 105 106 116 116 117 117 118 118 119 119 120 120 121 121 122 122 123 123 124 124 125 125 126 126 127 127 128 128 129 129 130 130 131 131 132 132 133 133 134 134 154 156 157 167 168
expression_comma_nest : 167 168
expression_opt       : 97 106 111
expression_statement : 88 107
for_clause           : 104
for_init_statement   : 106
function_decl        : 8 21 67
function_def         : 3 64
function_sign        : 20 50 69 170
function_type        : 28
generic_type         : 24
generics_specialization_list_opt : 42 43
generics_type        : 79 80
generics_type_comma_nest : 79 80
generics_type_list   : 57
generics_type_list_opt : 51 55 71
generics_type_range  : 83
generics_type_range_colon_opt : 82
if_statement         : 89
in_out               : 171
index_expr           : 142
int_literal_opt      : 46
interface_decl       : 11
interface_member_decl : 61
interface_member_decl_nest : 55 61
io_expr              : 147
iteration_statement  : 90
jump_statement       : 91
lambda_expr          : 146
member_decl          : 59
member_decl_nest     : 51 59
member_declarator    : 63
member_expr          : 145
new_expr             : 144
new_interface        : 55
new_struct           : 51
operand              : 140
parameter_decl       : 72 76
parameter_decl_comma_nest : 72 76
parameter_decl_list_opt : 71
parameter_list       : 159
parameter_list_opt   : 158 161 162
primary_expr         : 115 135 155 156 161 162
reference_type       : 27
simple_type          : 22
start                : 0
statement            : 95 100 101 105 106
statement_else_opt   : 100
statement_nest       : 94 95
struct_decl          : 10
translation_unit     : 1 2 3
type_alias_decl      : 9
type_decl            : 5
type_function_decl   : 66 68
type_function_def    : 65
type_spec            : 12 18 46 49 69 70 74 157 158 162 163 165 171
type_spec_assigntype_opt : 71
type_spec_colon_opt  : 17 78
type_spec_comma_nest : 162 163 165
unary_expr           : 114
unary_operation      : 135
variable_decl        : 6 92
while_clause         : 103

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . translation_unit
    (2) translation_unit -> . block_decl translation_unit
    (3) translation_unit -> . function_def translation_unit
    (4) translation_unit -> . empty
    (5) block_decl -> . type_decl SEMICOLON
    (6) block_decl -> . variable_decl SEMICOLON
    (7) block_decl -> . constant_decl SEMICOLON
    (8) block_decl -> . function_decl SEMICOLON
    (21) function_def -> . function_decl block_statement
    (174) empty -> .
    (9) type_decl -> . type_alias_decl
    (10) type_decl -> . struct_decl
    (11) type_decl -> . interface_decl
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (20) function_decl -> . FUNC ID function_sign
    (12) type_alias_decl -> . TYPE ID ASSIGN type_spec
    (51) struct_decl -> . STRUCT ID new_struct generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE
    (55) interface_decl -> . INTERFACE ID new_interface generics_type_list_opt LBRACE interface_member_decl_nest RBRACE

    $end            reduce using rule 174 (empty -> .)
    LET             shift and go to state 13
    CONST           shift and go to state 14
    FUNC            shift and go to state 15
    TYPE            shift and go to state 16
    STRUCT          shift and go to state 17
    INTERFACE       shift and go to state 18

    start                          shift and go to state 1
    translation_unit               shift and go to state 2
    block_decl                     shift and go to state 3
    function_def                   shift and go to state 4
    empty                          shift and go to state 5
    type_decl                      shift and go to state 6
    variable_decl                  shift and go to state 7
    constant_decl                  shift and go to state 8
    function_decl                  shift and go to state 9
    type_alias_decl                shift and go to state 10
    struct_decl                    shift and go to state 11
    interface_decl                 shift and go to state 12

state 1

    (0) S' -> start .



state 2

    (1) start -> translation_unit .

    $end            reduce using rule 1 (start -> translation_unit .)


state 3

    (2) translation_unit -> block_decl . translation_unit
    (2) translation_unit -> . block_decl translation_unit
    (3) translation_unit -> . function_def translation_unit
    (4) translation_unit -> . empty
    (5) block_decl -> . type_decl SEMICOLON
    (6) block_decl -> . variable_decl SEMICOLON
    (7) block_decl -> . constant_decl SEMICOLON
    (8) block_decl -> . function_decl SEMICOLON
    (21) function_def -> . function_decl block_statement
    (174) empty -> .
    (9) type_decl -> . type_alias_decl
    (10) type_decl -> . struct_decl
    (11) type_decl -> . interface_decl
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (20) function_decl -> . FUNC ID function_sign
    (12) type_alias_decl -> . TYPE ID ASSIGN type_spec
    (51) struct_decl -> . STRUCT ID new_struct generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE
    (55) interface_decl -> . INTERFACE ID new_interface generics_type_list_opt LBRACE interface_member_decl_nest RBRACE

    $end            reduce using rule 174 (empty -> .)
    LET             shift and go to state 13
    CONST           shift and go to state 14
    FUNC            shift and go to state 15
    TYPE            shift and go to state 16
    STRUCT          shift and go to state 17
    INTERFACE       shift and go to state 18

    block_decl                     shift and go to state 3
    translation_unit               shift and go to state 19
    function_def                   shift and go to state 4
    empty                          shift and go to state 5
    type_decl                      shift and go to state 6
    variable_decl                  shift and go to state 7
    constant_decl                  shift and go to state 8
    function_decl                  shift and go to state 9
    type_alias_decl                shift and go to state 10
    struct_decl                    shift and go to state 11
    interface_decl                 shift and go to state 12

state 4

    (3) translation_unit -> function_def . translation_unit
    (2) translation_unit -> . block_decl translation_unit
    (3) translation_unit -> . function_def translation_unit
    (4) translation_unit -> . empty
    (5) block_decl -> . type_decl SEMICOLON
    (6) block_decl -> . variable_decl SEMICOLON
    (7) block_decl -> . constant_decl SEMICOLON
    (8) block_decl -> . function_decl SEMICOLON
    (21) function_def -> . function_decl block_statement
    (174) empty -> .
    (9) type_decl -> . type_alias_decl
    (10) type_decl -> . struct_decl
    (11) type_decl -> . interface_decl
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (20) function_decl -> . FUNC ID function_sign
    (12) type_alias_decl -> . TYPE ID ASSIGN type_spec
    (51) struct_decl -> . STRUCT ID new_struct generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE
    (55) interface_decl -> . INTERFACE ID new_interface generics_type_list_opt LBRACE interface_member_decl_nest RBRACE

    $end            reduce using rule 174 (empty -> .)
    LET             shift and go to state 13
    CONST           shift and go to state 14
    FUNC            shift and go to state 15
    TYPE            shift and go to state 16
    STRUCT          shift and go to state 17
    INTERFACE       shift and go to state 18

    function_def                   shift and go to state 4
    translation_unit               shift and go to state 20
    block_decl                     shift and go to state 3
    empty                          shift and go to state 5
    type_decl                      shift and go to state 6
    variable_decl                  shift and go to state 7
    constant_decl                  shift and go to state 8
    function_decl                  shift and go to state 9
    type_alias_decl                shift and go to state 10
    struct_decl                    shift and go to state 11
    interface_decl                 shift and go to state 12

state 5

    (4) translation_unit -> empty .

    $end            reduce using rule 4 (translation_unit -> empty .)


state 6

    (5) block_decl -> type_decl . SEMICOLON

    SEMICOLON       shift and go to state 21


state 7

    (6) block_decl -> variable_decl . SEMICOLON

    SEMICOLON       shift and go to state 22


state 8

    (7) block_decl -> constant_decl . SEMICOLON

    SEMICOLON       shift and go to state 23


state 9

    (8) block_decl -> function_decl . SEMICOLON
    (21) function_def -> function_decl . block_statement
    (94) block_statement -> . LBRACE statement_nest RBRACE

    SEMICOLON       shift and go to state 24
    LBRACE          shift and go to state 26

    block_statement                shift and go to state 25

state 10

    (9) type_decl -> type_alias_decl .

    SEMICOLON       reduce using rule 9 (type_decl -> type_alias_decl .)


state 11

    (10) type_decl -> struct_decl .

    SEMICOLON       reduce using rule 10 (type_decl -> struct_decl .)


state 12

    (11) type_decl -> interface_decl .

    SEMICOLON       reduce using rule 11 (type_decl -> interface_decl .)


state 13

    (13) variable_decl -> LET . declarator declarator_nest
    (17) declarator -> . ID type_spec_colon_opt ASSIGN expression

    ID              shift and go to state 28

    declarator                     shift and go to state 27

state 14

    (16) constant_decl -> CONST . declarator declarator_nest
    (17) declarator -> . ID type_spec_colon_opt ASSIGN expression

    ID              shift and go to state 28

    declarator                     shift and go to state 29

state 15

    (20) function_decl -> FUNC . ID function_sign

    ID              shift and go to state 30


state 16

    (12) type_alias_decl -> TYPE . ID ASSIGN type_spec

    ID              shift and go to state 31


state 17

    (51) struct_decl -> STRUCT . ID new_struct generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE

    ID              shift and go to state 32


state 18

    (55) interface_decl -> INTERFACE . ID new_interface generics_type_list_opt LBRACE interface_member_decl_nest RBRACE

    ID              shift and go to state 33


state 19

    (2) translation_unit -> block_decl translation_unit .

    $end            reduce using rule 2 (translation_unit -> block_decl translation_unit .)


state 20

    (3) translation_unit -> function_def translation_unit .

    $end            reduce using rule 3 (translation_unit -> function_def translation_unit .)


state 21

    (5) block_decl -> type_decl SEMICOLON .

    LET             reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    CONST           reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    FUNC            reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    TYPE            reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    STRUCT          reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    INTERFACE       reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    $end            reduce using rule 5 (block_decl -> type_decl SEMICOLON .)


state 22

    (6) block_decl -> variable_decl SEMICOLON .

    LET             reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    CONST           reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    FUNC            reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    TYPE            reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    STRUCT          reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    INTERFACE       reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    $end            reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)


state 23

    (7) block_decl -> constant_decl SEMICOLON .

    LET             reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    CONST           reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    FUNC            reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    TYPE            reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    STRUCT          reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    INTERFACE       reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    $end            reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)


state 24

    (8) block_decl -> function_decl SEMICOLON .

    LET             reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    CONST           reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    FUNC            reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    TYPE            reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    STRUCT          reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    INTERFACE       reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    $end            reduce using rule 8 (block_decl -> function_decl SEMICOLON .)


state 25

    (21) function_def -> function_decl block_statement .

    LET             reduce using rule 21 (function_def -> function_decl block_statement .)
    CONST           reduce using rule 21 (function_def -> function_decl block_statement .)
    FUNC            reduce using rule 21 (function_def -> function_decl block_statement .)
    TYPE            reduce using rule 21 (function_def -> function_decl block_statement .)
    STRUCT          reduce using rule 21 (function_def -> function_decl block_statement .)
    INTERFACE       reduce using rule 21 (function_def -> function_decl block_statement .)
    $end            reduce using rule 21 (function_def -> function_decl block_statement .)
    ID              reduce using rule 21 (function_def -> function_decl block_statement .)
    RBRACE          reduce using rule 21 (function_def -> function_decl block_statement .)


state 26

    (94) block_statement -> LBRACE . statement_nest RBRACE
    (95) statement_nest -> . statement statement_nest
    (96) statement_nest -> . empty
    (86) statement -> . decl_statement
    (87) statement -> . block_statement
    (88) statement -> . expression_statement
    (89) statement -> . if_statement
    (90) statement -> . iteration_statement
    (91) statement -> . jump_statement
    (174) empty -> .
    (92) decl_statement -> . variable_decl SEMICOLON
    (93) decl_statement -> . constant_decl SEMICOLON
    (94) block_statement -> . LBRACE statement_nest RBRACE
    (97) expression_statement -> . expression_opt SEMICOLON
    (100) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (103) iteration_statement -> . while_clause
    (104) iteration_statement -> . for_clause
    (109) jump_statement -> . BREAK SEMICOLON
    (110) jump_statement -> . CONTINUE SEMICOLON
    (111) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (98) expression_opt -> . expression
    (99) expression_opt -> . empty
    (105) while_clause -> . WHILE LPAREN expression RPAREN statement
    (106) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    RBRACE          reduce using rule 174 (empty -> .)
    SEMICOLON       reduce using rule 174 (empty -> .)
    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 51
    CONTINUE        shift and go to state 52
    RETURN          shift and go to state 53
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    statement_nest                 shift and go to state 34
    statement                      shift and go to state 35
    empty                          shift and go to state 36
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    expression_opt                 shift and go to state 45
    expression                     shift and go to state 48
    while_clause                   shift and go to state 49
    for_clause                     shift and go to state 50
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 27

    (13) variable_decl -> LET declarator . declarator_nest
    (14) declarator_nest -> . COMMA declarator declarator_nest
    (15) declarator_nest -> . empty
    (174) empty -> .

    COMMA           shift and go to state 113
    SEMICOLON       reduce using rule 174 (empty -> .)

    declarator_nest                shift and go to state 112
    empty                          shift and go to state 114

state 28

    (17) declarator -> ID . type_spec_colon_opt ASSIGN expression
    (18) type_spec_colon_opt -> . COLON type_spec
    (19) type_spec_colon_opt -> . empty
    (174) empty -> .

    COLON           shift and go to state 116
    ASSIGN          reduce using rule 174 (empty -> .)

    type_spec_colon_opt            shift and go to state 115
    empty                          shift and go to state 117

state 29

    (16) constant_decl -> CONST declarator . declarator_nest
    (14) declarator_nest -> . COMMA declarator declarator_nest
    (15) declarator_nest -> . empty
    (174) empty -> .

    COMMA           shift and go to state 113
    SEMICOLON       reduce using rule 174 (empty -> .)

    declarator_nest                shift and go to state 118
    empty                          shift and go to state 114

state 30

    (20) function_decl -> FUNC ID . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    function_sign                  shift and go to state 119
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 31

    (12) type_alias_decl -> TYPE ID . ASSIGN type_spec

    ASSIGN          shift and go to state 121


state 32

    (51) struct_decl -> STRUCT ID . new_struct generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE
    (52) new_struct -> .

    LESS            reduce using rule 52 (new_struct -> .)
    COLON           reduce using rule 52 (new_struct -> .)
    LBRACE          reduce using rule 52 (new_struct -> .)

    new_struct                     shift and go to state 122

state 33

    (55) interface_decl -> INTERFACE ID . new_interface generics_type_list_opt LBRACE interface_member_decl_nest RBRACE
    (56) new_interface -> .

    LESS            reduce using rule 56 (new_interface -> .)
    LBRACE          reduce using rule 56 (new_interface -> .)

    new_interface                  shift and go to state 123

state 34

    (94) block_statement -> LBRACE statement_nest . RBRACE

    RBRACE          shift and go to state 124


state 35

    (95) statement_nest -> statement . statement_nest
    (95) statement_nest -> . statement statement_nest
    (96) statement_nest -> . empty
    (86) statement -> . decl_statement
    (87) statement -> . block_statement
    (88) statement -> . expression_statement
    (89) statement -> . if_statement
    (90) statement -> . iteration_statement
    (91) statement -> . jump_statement
    (174) empty -> .
    (92) decl_statement -> . variable_decl SEMICOLON
    (93) decl_statement -> . constant_decl SEMICOLON
    (94) block_statement -> . LBRACE statement_nest RBRACE
    (97) expression_statement -> . expression_opt SEMICOLON
    (100) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (103) iteration_statement -> . while_clause
    (104) iteration_statement -> . for_clause
    (109) jump_statement -> . BREAK SEMICOLON
    (110) jump_statement -> . CONTINUE SEMICOLON
    (111) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (98) expression_opt -> . expression
    (99) expression_opt -> . empty
    (105) while_clause -> . WHILE LPAREN expression RPAREN statement
    (106) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    RBRACE          reduce using rule 174 (empty -> .)
    SEMICOLON       reduce using rule 174 (empty -> .)
    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 51
    CONTINUE        shift and go to state 52
    RETURN          shift and go to state 53
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    statement                      shift and go to state 35
    statement_nest                 shift and go to state 125
    empty                          shift and go to state 36
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    expression_opt                 shift and go to state 45
    expression                     shift and go to state 48
    while_clause                   shift and go to state 49
    for_clause                     shift and go to state 50
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 36

    (96) statement_nest -> empty .
    (99) expression_opt -> empty .
    (58) generics_type_list_opt -> empty .

    RBRACE          reduce using rule 96 (statement_nest -> empty .)
    SEMICOLON       reduce using rule 99 (expression_opt -> empty .)
    LPAREN          reduce using rule 58 (generics_type_list_opt -> empty .)


state 37

    (86) statement -> decl_statement .

    LBRACE          reduce using rule 86 (statement -> decl_statement .)
    IF              reduce using rule 86 (statement -> decl_statement .)
    BREAK           reduce using rule 86 (statement -> decl_statement .)
    CONTINUE        reduce using rule 86 (statement -> decl_statement .)
    RETURN          reduce using rule 86 (statement -> decl_statement .)
    LET             reduce using rule 86 (statement -> decl_statement .)
    CONST           reduce using rule 86 (statement -> decl_statement .)
    WHILE           reduce using rule 86 (statement -> decl_statement .)
    FOR             reduce using rule 86 (statement -> decl_statement .)
    NOT             reduce using rule 86 (statement -> decl_statement .)
    LOGICAL_NOT     reduce using rule 86 (statement -> decl_statement .)
    PLUS            reduce using rule 86 (statement -> decl_statement .)
    MINUS           reduce using rule 86 (statement -> decl_statement .)
    INT             reduce using rule 86 (statement -> decl_statement .)
    HEXADECIMAL     reduce using rule 86 (statement -> decl_statement .)
    FLOAT           reduce using rule 86 (statement -> decl_statement .)
    DOUBLE          reduce using rule 86 (statement -> decl_statement .)
    STRING          reduce using rule 86 (statement -> decl_statement .)
    ID              reduce using rule 86 (statement -> decl_statement .)
    LPAREN          reduce using rule 86 (statement -> decl_statement .)
    FUNC            reduce using rule 86 (statement -> decl_statement .)
    IN              reduce using rule 86 (statement -> decl_statement .)
    OUT             reduce using rule 86 (statement -> decl_statement .)
    VOID            reduce using rule 86 (statement -> decl_statement .)
    BOOL            reduce using rule 86 (statement -> decl_statement .)
    I8              reduce using rule 86 (statement -> decl_statement .)
    U8              reduce using rule 86 (statement -> decl_statement .)
    I16             reduce using rule 86 (statement -> decl_statement .)
    U16             reduce using rule 86 (statement -> decl_statement .)
    I32             reduce using rule 86 (statement -> decl_statement .)
    U32             reduce using rule 86 (statement -> decl_statement .)
    I64             reduce using rule 86 (statement -> decl_statement .)
    U64             reduce using rule 86 (statement -> decl_statement .)
    F16             reduce using rule 86 (statement -> decl_statement .)
    F32             reduce using rule 86 (statement -> decl_statement .)
    F64             reduce using rule 86 (statement -> decl_statement .)
    INTERFACEID     reduce using rule 86 (statement -> decl_statement .)
    STRUCTID        reduce using rule 86 (statement -> decl_statement .)
    GENERICID       reduce using rule 86 (statement -> decl_statement .)
    TYPEALIASID     reduce using rule 86 (statement -> decl_statement .)
    LESS            reduce using rule 86 (statement -> decl_statement .)
    SEMICOLON       reduce using rule 86 (statement -> decl_statement .)
    RBRACE          reduce using rule 86 (statement -> decl_statement .)
    ELSE            reduce using rule 86 (statement -> decl_statement .)


state 38

    (87) statement -> block_statement .

    LBRACE          reduce using rule 87 (statement -> block_statement .)
    IF              reduce using rule 87 (statement -> block_statement .)
    BREAK           reduce using rule 87 (statement -> block_statement .)
    CONTINUE        reduce using rule 87 (statement -> block_statement .)
    RETURN          reduce using rule 87 (statement -> block_statement .)
    LET             reduce using rule 87 (statement -> block_statement .)
    CONST           reduce using rule 87 (statement -> block_statement .)
    WHILE           reduce using rule 87 (statement -> block_statement .)
    FOR             reduce using rule 87 (statement -> block_statement .)
    NOT             reduce using rule 87 (statement -> block_statement .)
    LOGICAL_NOT     reduce using rule 87 (statement -> block_statement .)
    PLUS            reduce using rule 87 (statement -> block_statement .)
    MINUS           reduce using rule 87 (statement -> block_statement .)
    INT             reduce using rule 87 (statement -> block_statement .)
    HEXADECIMAL     reduce using rule 87 (statement -> block_statement .)
    FLOAT           reduce using rule 87 (statement -> block_statement .)
    DOUBLE          reduce using rule 87 (statement -> block_statement .)
    STRING          reduce using rule 87 (statement -> block_statement .)
    ID              reduce using rule 87 (statement -> block_statement .)
    LPAREN          reduce using rule 87 (statement -> block_statement .)
    FUNC            reduce using rule 87 (statement -> block_statement .)
    IN              reduce using rule 87 (statement -> block_statement .)
    OUT             reduce using rule 87 (statement -> block_statement .)
    VOID            reduce using rule 87 (statement -> block_statement .)
    BOOL            reduce using rule 87 (statement -> block_statement .)
    I8              reduce using rule 87 (statement -> block_statement .)
    U8              reduce using rule 87 (statement -> block_statement .)
    I16             reduce using rule 87 (statement -> block_statement .)
    U16             reduce using rule 87 (statement -> block_statement .)
    I32             reduce using rule 87 (statement -> block_statement .)
    U32             reduce using rule 87 (statement -> block_statement .)
    I64             reduce using rule 87 (statement -> block_statement .)
    U64             reduce using rule 87 (statement -> block_statement .)
    F16             reduce using rule 87 (statement -> block_statement .)
    F32             reduce using rule 87 (statement -> block_statement .)
    F64             reduce using rule 87 (statement -> block_statement .)
    INTERFACEID     reduce using rule 87 (statement -> block_statement .)
    STRUCTID        reduce using rule 87 (statement -> block_statement .)
    GENERICID       reduce using rule 87 (statement -> block_statement .)
    TYPEALIASID     reduce using rule 87 (statement -> block_statement .)
    LESS            reduce using rule 87 (statement -> block_statement .)
    SEMICOLON       reduce using rule 87 (statement -> block_statement .)
    RBRACE          reduce using rule 87 (statement -> block_statement .)
    ELSE            reduce using rule 87 (statement -> block_statement .)


state 39

    (88) statement -> expression_statement .

    LBRACE          reduce using rule 88 (statement -> expression_statement .)
    IF              reduce using rule 88 (statement -> expression_statement .)
    BREAK           reduce using rule 88 (statement -> expression_statement .)
    CONTINUE        reduce using rule 88 (statement -> expression_statement .)
    RETURN          reduce using rule 88 (statement -> expression_statement .)
    LET             reduce using rule 88 (statement -> expression_statement .)
    CONST           reduce using rule 88 (statement -> expression_statement .)
    WHILE           reduce using rule 88 (statement -> expression_statement .)
    FOR             reduce using rule 88 (statement -> expression_statement .)
    NOT             reduce using rule 88 (statement -> expression_statement .)
    LOGICAL_NOT     reduce using rule 88 (statement -> expression_statement .)
    PLUS            reduce using rule 88 (statement -> expression_statement .)
    MINUS           reduce using rule 88 (statement -> expression_statement .)
    INT             reduce using rule 88 (statement -> expression_statement .)
    HEXADECIMAL     reduce using rule 88 (statement -> expression_statement .)
    FLOAT           reduce using rule 88 (statement -> expression_statement .)
    DOUBLE          reduce using rule 88 (statement -> expression_statement .)
    STRING          reduce using rule 88 (statement -> expression_statement .)
    ID              reduce using rule 88 (statement -> expression_statement .)
    LPAREN          reduce using rule 88 (statement -> expression_statement .)
    FUNC            reduce using rule 88 (statement -> expression_statement .)
    IN              reduce using rule 88 (statement -> expression_statement .)
    OUT             reduce using rule 88 (statement -> expression_statement .)
    VOID            reduce using rule 88 (statement -> expression_statement .)
    BOOL            reduce using rule 88 (statement -> expression_statement .)
    I8              reduce using rule 88 (statement -> expression_statement .)
    U8              reduce using rule 88 (statement -> expression_statement .)
    I16             reduce using rule 88 (statement -> expression_statement .)
    U16             reduce using rule 88 (statement -> expression_statement .)
    I32             reduce using rule 88 (statement -> expression_statement .)
    U32             reduce using rule 88 (statement -> expression_statement .)
    I64             reduce using rule 88 (statement -> expression_statement .)
    U64             reduce using rule 88 (statement -> expression_statement .)
    F16             reduce using rule 88 (statement -> expression_statement .)
    F32             reduce using rule 88 (statement -> expression_statement .)
    F64             reduce using rule 88 (statement -> expression_statement .)
    INTERFACEID     reduce using rule 88 (statement -> expression_statement .)
    STRUCTID        reduce using rule 88 (statement -> expression_statement .)
    GENERICID       reduce using rule 88 (statement -> expression_statement .)
    TYPEALIASID     reduce using rule 88 (statement -> expression_statement .)
    LESS            reduce using rule 88 (statement -> expression_statement .)
    SEMICOLON       reduce using rule 88 (statement -> expression_statement .)
    RBRACE          reduce using rule 88 (statement -> expression_statement .)
    ELSE            reduce using rule 88 (statement -> expression_statement .)


state 40

    (89) statement -> if_statement .

    LBRACE          reduce using rule 89 (statement -> if_statement .)
    IF              reduce using rule 89 (statement -> if_statement .)
    BREAK           reduce using rule 89 (statement -> if_statement .)
    CONTINUE        reduce using rule 89 (statement -> if_statement .)
    RETURN          reduce using rule 89 (statement -> if_statement .)
    LET             reduce using rule 89 (statement -> if_statement .)
    CONST           reduce using rule 89 (statement -> if_statement .)
    WHILE           reduce using rule 89 (statement -> if_statement .)
    FOR             reduce using rule 89 (statement -> if_statement .)
    NOT             reduce using rule 89 (statement -> if_statement .)
    LOGICAL_NOT     reduce using rule 89 (statement -> if_statement .)
    PLUS            reduce using rule 89 (statement -> if_statement .)
    MINUS           reduce using rule 89 (statement -> if_statement .)
    INT             reduce using rule 89 (statement -> if_statement .)
    HEXADECIMAL     reduce using rule 89 (statement -> if_statement .)
    FLOAT           reduce using rule 89 (statement -> if_statement .)
    DOUBLE          reduce using rule 89 (statement -> if_statement .)
    STRING          reduce using rule 89 (statement -> if_statement .)
    ID              reduce using rule 89 (statement -> if_statement .)
    LPAREN          reduce using rule 89 (statement -> if_statement .)
    FUNC            reduce using rule 89 (statement -> if_statement .)
    IN              reduce using rule 89 (statement -> if_statement .)
    OUT             reduce using rule 89 (statement -> if_statement .)
    VOID            reduce using rule 89 (statement -> if_statement .)
    BOOL            reduce using rule 89 (statement -> if_statement .)
    I8              reduce using rule 89 (statement -> if_statement .)
    U8              reduce using rule 89 (statement -> if_statement .)
    I16             reduce using rule 89 (statement -> if_statement .)
    U16             reduce using rule 89 (statement -> if_statement .)
    I32             reduce using rule 89 (statement -> if_statement .)
    U32             reduce using rule 89 (statement -> if_statement .)
    I64             reduce using rule 89 (statement -> if_statement .)
    U64             reduce using rule 89 (statement -> if_statement .)
    F16             reduce using rule 89 (statement -> if_statement .)
    F32             reduce using rule 89 (statement -> if_statement .)
    F64             reduce using rule 89 (statement -> if_statement .)
    INTERFACEID     reduce using rule 89 (statement -> if_statement .)
    STRUCTID        reduce using rule 89 (statement -> if_statement .)
    GENERICID       reduce using rule 89 (statement -> if_statement .)
    TYPEALIASID     reduce using rule 89 (statement -> if_statement .)
    LESS            reduce using rule 89 (statement -> if_statement .)
    SEMICOLON       reduce using rule 89 (statement -> if_statement .)
    RBRACE          reduce using rule 89 (statement -> if_statement .)
    ELSE            reduce using rule 89 (statement -> if_statement .)


state 41

    (90) statement -> iteration_statement .

    LBRACE          reduce using rule 90 (statement -> iteration_statement .)
    IF              reduce using rule 90 (statement -> iteration_statement .)
    BREAK           reduce using rule 90 (statement -> iteration_statement .)
    CONTINUE        reduce using rule 90 (statement -> iteration_statement .)
    RETURN          reduce using rule 90 (statement -> iteration_statement .)
    LET             reduce using rule 90 (statement -> iteration_statement .)
    CONST           reduce using rule 90 (statement -> iteration_statement .)
    WHILE           reduce using rule 90 (statement -> iteration_statement .)
    FOR             reduce using rule 90 (statement -> iteration_statement .)
    NOT             reduce using rule 90 (statement -> iteration_statement .)
    LOGICAL_NOT     reduce using rule 90 (statement -> iteration_statement .)
    PLUS            reduce using rule 90 (statement -> iteration_statement .)
    MINUS           reduce using rule 90 (statement -> iteration_statement .)
    INT             reduce using rule 90 (statement -> iteration_statement .)
    HEXADECIMAL     reduce using rule 90 (statement -> iteration_statement .)
    FLOAT           reduce using rule 90 (statement -> iteration_statement .)
    DOUBLE          reduce using rule 90 (statement -> iteration_statement .)
    STRING          reduce using rule 90 (statement -> iteration_statement .)
    ID              reduce using rule 90 (statement -> iteration_statement .)
    LPAREN          reduce using rule 90 (statement -> iteration_statement .)
    FUNC            reduce using rule 90 (statement -> iteration_statement .)
    IN              reduce using rule 90 (statement -> iteration_statement .)
    OUT             reduce using rule 90 (statement -> iteration_statement .)
    VOID            reduce using rule 90 (statement -> iteration_statement .)
    BOOL            reduce using rule 90 (statement -> iteration_statement .)
    I8              reduce using rule 90 (statement -> iteration_statement .)
    U8              reduce using rule 90 (statement -> iteration_statement .)
    I16             reduce using rule 90 (statement -> iteration_statement .)
    U16             reduce using rule 90 (statement -> iteration_statement .)
    I32             reduce using rule 90 (statement -> iteration_statement .)
    U32             reduce using rule 90 (statement -> iteration_statement .)
    I64             reduce using rule 90 (statement -> iteration_statement .)
    U64             reduce using rule 90 (statement -> iteration_statement .)
    F16             reduce using rule 90 (statement -> iteration_statement .)
    F32             reduce using rule 90 (statement -> iteration_statement .)
    F64             reduce using rule 90 (statement -> iteration_statement .)
    INTERFACEID     reduce using rule 90 (statement -> iteration_statement .)
    STRUCTID        reduce using rule 90 (statement -> iteration_statement .)
    GENERICID       reduce using rule 90 (statement -> iteration_statement .)
    TYPEALIASID     reduce using rule 90 (statement -> iteration_statement .)
    LESS            reduce using rule 90 (statement -> iteration_statement .)
    SEMICOLON       reduce using rule 90 (statement -> iteration_statement .)
    RBRACE          reduce using rule 90 (statement -> iteration_statement .)
    ELSE            reduce using rule 90 (statement -> iteration_statement .)


state 42

    (91) statement -> jump_statement .

    LBRACE          reduce using rule 91 (statement -> jump_statement .)
    IF              reduce using rule 91 (statement -> jump_statement .)
    BREAK           reduce using rule 91 (statement -> jump_statement .)
    CONTINUE        reduce using rule 91 (statement -> jump_statement .)
    RETURN          reduce using rule 91 (statement -> jump_statement .)
    LET             reduce using rule 91 (statement -> jump_statement .)
    CONST           reduce using rule 91 (statement -> jump_statement .)
    WHILE           reduce using rule 91 (statement -> jump_statement .)
    FOR             reduce using rule 91 (statement -> jump_statement .)
    NOT             reduce using rule 91 (statement -> jump_statement .)
    LOGICAL_NOT     reduce using rule 91 (statement -> jump_statement .)
    PLUS            reduce using rule 91 (statement -> jump_statement .)
    MINUS           reduce using rule 91 (statement -> jump_statement .)
    INT             reduce using rule 91 (statement -> jump_statement .)
    HEXADECIMAL     reduce using rule 91 (statement -> jump_statement .)
    FLOAT           reduce using rule 91 (statement -> jump_statement .)
    DOUBLE          reduce using rule 91 (statement -> jump_statement .)
    STRING          reduce using rule 91 (statement -> jump_statement .)
    ID              reduce using rule 91 (statement -> jump_statement .)
    LPAREN          reduce using rule 91 (statement -> jump_statement .)
    FUNC            reduce using rule 91 (statement -> jump_statement .)
    IN              reduce using rule 91 (statement -> jump_statement .)
    OUT             reduce using rule 91 (statement -> jump_statement .)
    VOID            reduce using rule 91 (statement -> jump_statement .)
    BOOL            reduce using rule 91 (statement -> jump_statement .)
    I8              reduce using rule 91 (statement -> jump_statement .)
    U8              reduce using rule 91 (statement -> jump_statement .)
    I16             reduce using rule 91 (statement -> jump_statement .)
    U16             reduce using rule 91 (statement -> jump_statement .)
    I32             reduce using rule 91 (statement -> jump_statement .)
    U32             reduce using rule 91 (statement -> jump_statement .)
    I64             reduce using rule 91 (statement -> jump_statement .)
    U64             reduce using rule 91 (statement -> jump_statement .)
    F16             reduce using rule 91 (statement -> jump_statement .)
    F32             reduce using rule 91 (statement -> jump_statement .)
    F64             reduce using rule 91 (statement -> jump_statement .)
    INTERFACEID     reduce using rule 91 (statement -> jump_statement .)
    STRUCTID        reduce using rule 91 (statement -> jump_statement .)
    GENERICID       reduce using rule 91 (statement -> jump_statement .)
    TYPEALIASID     reduce using rule 91 (statement -> jump_statement .)
    LESS            reduce using rule 91 (statement -> jump_statement .)
    SEMICOLON       reduce using rule 91 (statement -> jump_statement .)
    RBRACE          reduce using rule 91 (statement -> jump_statement .)
    ELSE            reduce using rule 91 (statement -> jump_statement .)


state 43

    (92) decl_statement -> variable_decl . SEMICOLON

    SEMICOLON       shift and go to state 126


state 44

    (93) decl_statement -> constant_decl . SEMICOLON

    SEMICOLON       shift and go to state 127


state 45

    (97) expression_statement -> expression_opt . SEMICOLON

    SEMICOLON       shift and go to state 128


state 46

    (100) if_statement -> IF . LPAREN expression RPAREN statement statement_else_opt

    LPAREN          shift and go to state 129


state 47

    (154) operand -> LPAREN . expression RPAREN
    (157) cast_expr -> LPAREN . type_spec RPAREN expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 130
    type_spec                      shift and go to state 131
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 48

    (98) expression_opt -> expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    SEMICOLON       reduce using rule 98 (expression_opt -> expression .)
    ASSIGN          shift and go to state 132
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_OR      shift and go to state 143
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150


state 49

    (103) iteration_statement -> while_clause .

    LBRACE          reduce using rule 103 (iteration_statement -> while_clause .)
    IF              reduce using rule 103 (iteration_statement -> while_clause .)
    BREAK           reduce using rule 103 (iteration_statement -> while_clause .)
    CONTINUE        reduce using rule 103 (iteration_statement -> while_clause .)
    RETURN          reduce using rule 103 (iteration_statement -> while_clause .)
    LET             reduce using rule 103 (iteration_statement -> while_clause .)
    CONST           reduce using rule 103 (iteration_statement -> while_clause .)
    WHILE           reduce using rule 103 (iteration_statement -> while_clause .)
    FOR             reduce using rule 103 (iteration_statement -> while_clause .)
    NOT             reduce using rule 103 (iteration_statement -> while_clause .)
    LOGICAL_NOT     reduce using rule 103 (iteration_statement -> while_clause .)
    PLUS            reduce using rule 103 (iteration_statement -> while_clause .)
    MINUS           reduce using rule 103 (iteration_statement -> while_clause .)
    INT             reduce using rule 103 (iteration_statement -> while_clause .)
    HEXADECIMAL     reduce using rule 103 (iteration_statement -> while_clause .)
    FLOAT           reduce using rule 103 (iteration_statement -> while_clause .)
    DOUBLE          reduce using rule 103 (iteration_statement -> while_clause .)
    STRING          reduce using rule 103 (iteration_statement -> while_clause .)
    ID              reduce using rule 103 (iteration_statement -> while_clause .)
    LPAREN          reduce using rule 103 (iteration_statement -> while_clause .)
    FUNC            reduce using rule 103 (iteration_statement -> while_clause .)
    IN              reduce using rule 103 (iteration_statement -> while_clause .)
    OUT             reduce using rule 103 (iteration_statement -> while_clause .)
    VOID            reduce using rule 103 (iteration_statement -> while_clause .)
    BOOL            reduce using rule 103 (iteration_statement -> while_clause .)
    I8              reduce using rule 103 (iteration_statement -> while_clause .)
    U8              reduce using rule 103 (iteration_statement -> while_clause .)
    I16             reduce using rule 103 (iteration_statement -> while_clause .)
    U16             reduce using rule 103 (iteration_statement -> while_clause .)
    I32             reduce using rule 103 (iteration_statement -> while_clause .)
    U32             reduce using rule 103 (iteration_statement -> while_clause .)
    I64             reduce using rule 103 (iteration_statement -> while_clause .)
    U64             reduce using rule 103 (iteration_statement -> while_clause .)
    F16             reduce using rule 103 (iteration_statement -> while_clause .)
    F32             reduce using rule 103 (iteration_statement -> while_clause .)
    F64             reduce using rule 103 (iteration_statement -> while_clause .)
    INTERFACEID     reduce using rule 103 (iteration_statement -> while_clause .)
    STRUCTID        reduce using rule 103 (iteration_statement -> while_clause .)
    GENERICID       reduce using rule 103 (iteration_statement -> while_clause .)
    TYPEALIASID     reduce using rule 103 (iteration_statement -> while_clause .)
    LESS            reduce using rule 103 (iteration_statement -> while_clause .)
    SEMICOLON       reduce using rule 103 (iteration_statement -> while_clause .)
    RBRACE          reduce using rule 103 (iteration_statement -> while_clause .)
    ELSE            reduce using rule 103 (iteration_statement -> while_clause .)


state 50

    (104) iteration_statement -> for_clause .

    LBRACE          reduce using rule 104 (iteration_statement -> for_clause .)
    IF              reduce using rule 104 (iteration_statement -> for_clause .)
    BREAK           reduce using rule 104 (iteration_statement -> for_clause .)
    CONTINUE        reduce using rule 104 (iteration_statement -> for_clause .)
    RETURN          reduce using rule 104 (iteration_statement -> for_clause .)
    LET             reduce using rule 104 (iteration_statement -> for_clause .)
    CONST           reduce using rule 104 (iteration_statement -> for_clause .)
    WHILE           reduce using rule 104 (iteration_statement -> for_clause .)
    FOR             reduce using rule 104 (iteration_statement -> for_clause .)
    NOT             reduce using rule 104 (iteration_statement -> for_clause .)
    LOGICAL_NOT     reduce using rule 104 (iteration_statement -> for_clause .)
    PLUS            reduce using rule 104 (iteration_statement -> for_clause .)
    MINUS           reduce using rule 104 (iteration_statement -> for_clause .)
    INT             reduce using rule 104 (iteration_statement -> for_clause .)
    HEXADECIMAL     reduce using rule 104 (iteration_statement -> for_clause .)
    FLOAT           reduce using rule 104 (iteration_statement -> for_clause .)
    DOUBLE          reduce using rule 104 (iteration_statement -> for_clause .)
    STRING          reduce using rule 104 (iteration_statement -> for_clause .)
    ID              reduce using rule 104 (iteration_statement -> for_clause .)
    LPAREN          reduce using rule 104 (iteration_statement -> for_clause .)
    FUNC            reduce using rule 104 (iteration_statement -> for_clause .)
    IN              reduce using rule 104 (iteration_statement -> for_clause .)
    OUT             reduce using rule 104 (iteration_statement -> for_clause .)
    VOID            reduce using rule 104 (iteration_statement -> for_clause .)
    BOOL            reduce using rule 104 (iteration_statement -> for_clause .)
    I8              reduce using rule 104 (iteration_statement -> for_clause .)
    U8              reduce using rule 104 (iteration_statement -> for_clause .)
    I16             reduce using rule 104 (iteration_statement -> for_clause .)
    U16             reduce using rule 104 (iteration_statement -> for_clause .)
    I32             reduce using rule 104 (iteration_statement -> for_clause .)
    U32             reduce using rule 104 (iteration_statement -> for_clause .)
    I64             reduce using rule 104 (iteration_statement -> for_clause .)
    U64             reduce using rule 104 (iteration_statement -> for_clause .)
    F16             reduce using rule 104 (iteration_statement -> for_clause .)
    F32             reduce using rule 104 (iteration_statement -> for_clause .)
    F64             reduce using rule 104 (iteration_statement -> for_clause .)
    INTERFACEID     reduce using rule 104 (iteration_statement -> for_clause .)
    STRUCTID        reduce using rule 104 (iteration_statement -> for_clause .)
    GENERICID       reduce using rule 104 (iteration_statement -> for_clause .)
    TYPEALIASID     reduce using rule 104 (iteration_statement -> for_clause .)
    LESS            reduce using rule 104 (iteration_statement -> for_clause .)
    SEMICOLON       reduce using rule 104 (iteration_statement -> for_clause .)
    RBRACE          reduce using rule 104 (iteration_statement -> for_clause .)
    ELSE            reduce using rule 104 (iteration_statement -> for_clause .)


state 51

    (109) jump_statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 151


state 52

    (110) jump_statement -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 152


state 53

    (111) jump_statement -> RETURN . expression_opt SEMICOLON
    (98) expression_opt -> . expression
    (99) expression_opt -> . empty
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (174) empty -> .
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    SEMICOLON       reduce using rule 174 (empty -> .)
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression_opt                 shift and go to state 153
    expression                     shift and go to state 48
    empty                          shift and go to state 154
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 54

    (105) while_clause -> WHILE . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 155


state 55

    (106) for_clause -> FOR . LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement

    LPAREN          shift and go to state 156


state 56

    (112) expression -> assign_expr .

    ASSIGN          reduce using rule 112 (expression -> assign_expr .)
    PLUS            reduce using rule 112 (expression -> assign_expr .)
    MINUS           reduce using rule 112 (expression -> assign_expr .)
    MUL             reduce using rule 112 (expression -> assign_expr .)
    DIV             reduce using rule 112 (expression -> assign_expr .)
    AND             reduce using rule 112 (expression -> assign_expr .)
    OR              reduce using rule 112 (expression -> assign_expr .)
    XOR             reduce using rule 112 (expression -> assign_expr .)
    MOD             reduce using rule 112 (expression -> assign_expr .)
    LSHIFT          reduce using rule 112 (expression -> assign_expr .)
    RSHIFT          reduce using rule 112 (expression -> assign_expr .)
    LOGICAL_OR      reduce using rule 112 (expression -> assign_expr .)
    LOGICAL_AND     reduce using rule 112 (expression -> assign_expr .)
    NOT_EQUAL       reduce using rule 112 (expression -> assign_expr .)
    EQUAL           reduce using rule 112 (expression -> assign_expr .)
    LESS_EQUAL      reduce using rule 112 (expression -> assign_expr .)
    LESS            reduce using rule 112 (expression -> assign_expr .)
    GREATER_EQUAL   reduce using rule 112 (expression -> assign_expr .)
    GREATER         reduce using rule 112 (expression -> assign_expr .)
    SEMICOLON       reduce using rule 112 (expression -> assign_expr .)
    RPAREN          reduce using rule 112 (expression -> assign_expr .)
    LPAREN          reduce using rule 112 (expression -> assign_expr .)
    GENERICMARK     reduce using rule 112 (expression -> assign_expr .)
    LBRACKET        reduce using rule 112 (expression -> assign_expr .)
    DOT             reduce using rule 112 (expression -> assign_expr .)
    COMMA           reduce using rule 112 (expression -> assign_expr .)
    RBRACKET        reduce using rule 112 (expression -> assign_expr .)


state 57

    (113) expression -> binary_expr .

    ASSIGN          reduce using rule 113 (expression -> binary_expr .)
    PLUS            reduce using rule 113 (expression -> binary_expr .)
    MINUS           reduce using rule 113 (expression -> binary_expr .)
    MUL             reduce using rule 113 (expression -> binary_expr .)
    DIV             reduce using rule 113 (expression -> binary_expr .)
    AND             reduce using rule 113 (expression -> binary_expr .)
    OR              reduce using rule 113 (expression -> binary_expr .)
    XOR             reduce using rule 113 (expression -> binary_expr .)
    MOD             reduce using rule 113 (expression -> binary_expr .)
    LSHIFT          reduce using rule 113 (expression -> binary_expr .)
    RSHIFT          reduce using rule 113 (expression -> binary_expr .)
    LOGICAL_OR      reduce using rule 113 (expression -> binary_expr .)
    LOGICAL_AND     reduce using rule 113 (expression -> binary_expr .)
    NOT_EQUAL       reduce using rule 113 (expression -> binary_expr .)
    EQUAL           reduce using rule 113 (expression -> binary_expr .)
    LESS_EQUAL      reduce using rule 113 (expression -> binary_expr .)
    LESS            reduce using rule 113 (expression -> binary_expr .)
    GREATER_EQUAL   reduce using rule 113 (expression -> binary_expr .)
    GREATER         reduce using rule 113 (expression -> binary_expr .)
    SEMICOLON       reduce using rule 113 (expression -> binary_expr .)
    RPAREN          reduce using rule 113 (expression -> binary_expr .)
    LPAREN          reduce using rule 113 (expression -> binary_expr .)
    GENERICMARK     reduce using rule 113 (expression -> binary_expr .)
    LBRACKET        reduce using rule 113 (expression -> binary_expr .)
    DOT             reduce using rule 113 (expression -> binary_expr .)
    COMMA           reduce using rule 113 (expression -> binary_expr .)
    RBRACKET        reduce using rule 113 (expression -> binary_expr .)


state 58

    (114) expression -> unary_expr .

    ASSIGN          reduce using rule 114 (expression -> unary_expr .)
    PLUS            reduce using rule 114 (expression -> unary_expr .)
    MINUS           reduce using rule 114 (expression -> unary_expr .)
    MUL             reduce using rule 114 (expression -> unary_expr .)
    DIV             reduce using rule 114 (expression -> unary_expr .)
    AND             reduce using rule 114 (expression -> unary_expr .)
    OR              reduce using rule 114 (expression -> unary_expr .)
    XOR             reduce using rule 114 (expression -> unary_expr .)
    MOD             reduce using rule 114 (expression -> unary_expr .)
    LSHIFT          reduce using rule 114 (expression -> unary_expr .)
    RSHIFT          reduce using rule 114 (expression -> unary_expr .)
    LOGICAL_OR      reduce using rule 114 (expression -> unary_expr .)
    LOGICAL_AND     reduce using rule 114 (expression -> unary_expr .)
    NOT_EQUAL       reduce using rule 114 (expression -> unary_expr .)
    EQUAL           reduce using rule 114 (expression -> unary_expr .)
    LESS_EQUAL      reduce using rule 114 (expression -> unary_expr .)
    LESS            reduce using rule 114 (expression -> unary_expr .)
    GREATER_EQUAL   reduce using rule 114 (expression -> unary_expr .)
    GREATER         reduce using rule 114 (expression -> unary_expr .)
    SEMICOLON       reduce using rule 114 (expression -> unary_expr .)
    RPAREN          reduce using rule 114 (expression -> unary_expr .)
    LPAREN          reduce using rule 114 (expression -> unary_expr .)
    GENERICMARK     reduce using rule 114 (expression -> unary_expr .)
    LBRACKET        reduce using rule 114 (expression -> unary_expr .)
    DOT             reduce using rule 114 (expression -> unary_expr .)
    COMMA           reduce using rule 114 (expression -> unary_expr .)
    RBRACKET        reduce using rule 114 (expression -> unary_expr .)


state 59

    (115) expression -> primary_expr .
    (161) call_expr -> primary_expr . LPAREN parameter_list_opt RPAREN
    (162) call_expr -> primary_expr . GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> primary_expr . LBRACKET expression RBRACKET
    (155) member_expr -> primary_expr . DOT ID

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for GENERICMARK resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
    ASSIGN          reduce using rule 115 (expression -> primary_expr .)
    PLUS            reduce using rule 115 (expression -> primary_expr .)
    MINUS           reduce using rule 115 (expression -> primary_expr .)
    MUL             reduce using rule 115 (expression -> primary_expr .)
    DIV             reduce using rule 115 (expression -> primary_expr .)
    AND             reduce using rule 115 (expression -> primary_expr .)
    OR              reduce using rule 115 (expression -> primary_expr .)
    XOR             reduce using rule 115 (expression -> primary_expr .)
    MOD             reduce using rule 115 (expression -> primary_expr .)
    LSHIFT          reduce using rule 115 (expression -> primary_expr .)
    RSHIFT          reduce using rule 115 (expression -> primary_expr .)
    LOGICAL_OR      reduce using rule 115 (expression -> primary_expr .)
    LOGICAL_AND     reduce using rule 115 (expression -> primary_expr .)
    NOT_EQUAL       reduce using rule 115 (expression -> primary_expr .)
    EQUAL           reduce using rule 115 (expression -> primary_expr .)
    LESS_EQUAL      reduce using rule 115 (expression -> primary_expr .)
    LESS            reduce using rule 115 (expression -> primary_expr .)
    GREATER_EQUAL   reduce using rule 115 (expression -> primary_expr .)
    GREATER         reduce using rule 115 (expression -> primary_expr .)
    SEMICOLON       reduce using rule 115 (expression -> primary_expr .)
    RPAREN          reduce using rule 115 (expression -> primary_expr .)
    COMMA           reduce using rule 115 (expression -> primary_expr .)
    RBRACKET        reduce using rule 115 (expression -> primary_expr .)
    LPAREN          shift and go to state 157
    GENERICMARK     shift and go to state 158
    LBRACKET        shift and go to state 159
    DOT             shift and go to state 160

  ! LPAREN          [ reduce using rule 115 (expression -> primary_expr .) ]
  ! GENERICMARK     [ reduce using rule 115 (expression -> primary_expr .) ]
  ! LBRACKET        [ reduce using rule 115 (expression -> primary_expr .) ]
  ! DOT             [ reduce using rule 115 (expression -> primary_expr .) ]


state 60

    (138) unary_operation -> PLUS .

    INT             reduce using rule 138 (unary_operation -> PLUS .)
    HEXADECIMAL     reduce using rule 138 (unary_operation -> PLUS .)
    FLOAT           reduce using rule 138 (unary_operation -> PLUS .)
    DOUBLE          reduce using rule 138 (unary_operation -> PLUS .)
    STRING          reduce using rule 138 (unary_operation -> PLUS .)
    ID              reduce using rule 138 (unary_operation -> PLUS .)
    LPAREN          reduce using rule 138 (unary_operation -> PLUS .)
    FUNC            reduce using rule 138 (unary_operation -> PLUS .)
    IN              reduce using rule 138 (unary_operation -> PLUS .)
    OUT             reduce using rule 138 (unary_operation -> PLUS .)
    VOID            reduce using rule 138 (unary_operation -> PLUS .)
    BOOL            reduce using rule 138 (unary_operation -> PLUS .)
    I8              reduce using rule 138 (unary_operation -> PLUS .)
    U8              reduce using rule 138 (unary_operation -> PLUS .)
    I16             reduce using rule 138 (unary_operation -> PLUS .)
    U16             reduce using rule 138 (unary_operation -> PLUS .)
    I32             reduce using rule 138 (unary_operation -> PLUS .)
    U32             reduce using rule 138 (unary_operation -> PLUS .)
    I64             reduce using rule 138 (unary_operation -> PLUS .)
    U64             reduce using rule 138 (unary_operation -> PLUS .)
    F16             reduce using rule 138 (unary_operation -> PLUS .)
    F32             reduce using rule 138 (unary_operation -> PLUS .)
    F64             reduce using rule 138 (unary_operation -> PLUS .)
    INTERFACEID     reduce using rule 138 (unary_operation -> PLUS .)
    STRUCTID        reduce using rule 138 (unary_operation -> PLUS .)
    GENERICID       reduce using rule 138 (unary_operation -> PLUS .)
    TYPEALIASID     reduce using rule 138 (unary_operation -> PLUS .)
    LESS            reduce using rule 138 (unary_operation -> PLUS .)


state 61

    (139) unary_operation -> MINUS .

    INT             reduce using rule 139 (unary_operation -> MINUS .)
    HEXADECIMAL     reduce using rule 139 (unary_operation -> MINUS .)
    FLOAT           reduce using rule 139 (unary_operation -> MINUS .)
    DOUBLE          reduce using rule 139 (unary_operation -> MINUS .)
    STRING          reduce using rule 139 (unary_operation -> MINUS .)
    ID              reduce using rule 139 (unary_operation -> MINUS .)
    LPAREN          reduce using rule 139 (unary_operation -> MINUS .)
    FUNC            reduce using rule 139 (unary_operation -> MINUS .)
    IN              reduce using rule 139 (unary_operation -> MINUS .)
    OUT             reduce using rule 139 (unary_operation -> MINUS .)
    VOID            reduce using rule 139 (unary_operation -> MINUS .)
    BOOL            reduce using rule 139 (unary_operation -> MINUS .)
    I8              reduce using rule 139 (unary_operation -> MINUS .)
    U8              reduce using rule 139 (unary_operation -> MINUS .)
    I16             reduce using rule 139 (unary_operation -> MINUS .)
    U16             reduce using rule 139 (unary_operation -> MINUS .)
    I32             reduce using rule 139 (unary_operation -> MINUS .)
    U32             reduce using rule 139 (unary_operation -> MINUS .)
    I64             reduce using rule 139 (unary_operation -> MINUS .)
    U64             reduce using rule 139 (unary_operation -> MINUS .)
    F16             reduce using rule 139 (unary_operation -> MINUS .)
    F32             reduce using rule 139 (unary_operation -> MINUS .)
    F64             reduce using rule 139 (unary_operation -> MINUS .)
    INTERFACEID     reduce using rule 139 (unary_operation -> MINUS .)
    STRUCTID        reduce using rule 139 (unary_operation -> MINUS .)
    GENERICID       reduce using rule 139 (unary_operation -> MINUS .)
    TYPEALIASID     reduce using rule 139 (unary_operation -> MINUS .)
    LESS            reduce using rule 139 (unary_operation -> MINUS .)


state 62

    (79) generics_type_list -> LESS . generics_type generics_type_comma_nest GREATER
    (82) generics_type -> . ID generics_type_range_colon_opt

    ID              shift and go to state 162

    generics_type                  shift and go to state 161

state 63

    (135) unary_expr -> unary_operation . primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    primary_expr                   shift and go to state 163
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 64

    (140) primary_expr -> operand .

    LPAREN          reduce using rule 140 (primary_expr -> operand .)
    GENERICMARK     reduce using rule 140 (primary_expr -> operand .)
    LBRACKET        reduce using rule 140 (primary_expr -> operand .)
    DOT             reduce using rule 140 (primary_expr -> operand .)
    ASSIGN          reduce using rule 140 (primary_expr -> operand .)
    PLUS            reduce using rule 140 (primary_expr -> operand .)
    MINUS           reduce using rule 140 (primary_expr -> operand .)
    MUL             reduce using rule 140 (primary_expr -> operand .)
    DIV             reduce using rule 140 (primary_expr -> operand .)
    AND             reduce using rule 140 (primary_expr -> operand .)
    OR              reduce using rule 140 (primary_expr -> operand .)
    XOR             reduce using rule 140 (primary_expr -> operand .)
    MOD             reduce using rule 140 (primary_expr -> operand .)
    LSHIFT          reduce using rule 140 (primary_expr -> operand .)
    RSHIFT          reduce using rule 140 (primary_expr -> operand .)
    LOGICAL_OR      reduce using rule 140 (primary_expr -> operand .)
    LOGICAL_AND     reduce using rule 140 (primary_expr -> operand .)
    NOT_EQUAL       reduce using rule 140 (primary_expr -> operand .)
    EQUAL           reduce using rule 140 (primary_expr -> operand .)
    LESS_EQUAL      reduce using rule 140 (primary_expr -> operand .)
    LESS            reduce using rule 140 (primary_expr -> operand .)
    GREATER_EQUAL   reduce using rule 140 (primary_expr -> operand .)
    GREATER         reduce using rule 140 (primary_expr -> operand .)
    SEMICOLON       reduce using rule 140 (primary_expr -> operand .)
    RPAREN          reduce using rule 140 (primary_expr -> operand .)
    COMMA           reduce using rule 140 (primary_expr -> operand .)
    RBRACKET        reduce using rule 140 (primary_expr -> operand .)


state 65

    (141) primary_expr -> call_expr .

    LPAREN          reduce using rule 141 (primary_expr -> call_expr .)
    GENERICMARK     reduce using rule 141 (primary_expr -> call_expr .)
    LBRACKET        reduce using rule 141 (primary_expr -> call_expr .)
    DOT             reduce using rule 141 (primary_expr -> call_expr .)
    ASSIGN          reduce using rule 141 (primary_expr -> call_expr .)
    PLUS            reduce using rule 141 (primary_expr -> call_expr .)
    MINUS           reduce using rule 141 (primary_expr -> call_expr .)
    MUL             reduce using rule 141 (primary_expr -> call_expr .)
    DIV             reduce using rule 141 (primary_expr -> call_expr .)
    AND             reduce using rule 141 (primary_expr -> call_expr .)
    OR              reduce using rule 141 (primary_expr -> call_expr .)
    XOR             reduce using rule 141 (primary_expr -> call_expr .)
    MOD             reduce using rule 141 (primary_expr -> call_expr .)
    LSHIFT          reduce using rule 141 (primary_expr -> call_expr .)
    RSHIFT          reduce using rule 141 (primary_expr -> call_expr .)
    LOGICAL_OR      reduce using rule 141 (primary_expr -> call_expr .)
    LOGICAL_AND     reduce using rule 141 (primary_expr -> call_expr .)
    NOT_EQUAL       reduce using rule 141 (primary_expr -> call_expr .)
    EQUAL           reduce using rule 141 (primary_expr -> call_expr .)
    LESS_EQUAL      reduce using rule 141 (primary_expr -> call_expr .)
    LESS            reduce using rule 141 (primary_expr -> call_expr .)
    GREATER_EQUAL   reduce using rule 141 (primary_expr -> call_expr .)
    GREATER         reduce using rule 141 (primary_expr -> call_expr .)
    SEMICOLON       reduce using rule 141 (primary_expr -> call_expr .)
    RPAREN          reduce using rule 141 (primary_expr -> call_expr .)
    COMMA           reduce using rule 141 (primary_expr -> call_expr .)
    RBRACKET        reduce using rule 141 (primary_expr -> call_expr .)


state 66

    (142) primary_expr -> index_expr .

    LPAREN          reduce using rule 142 (primary_expr -> index_expr .)
    GENERICMARK     reduce using rule 142 (primary_expr -> index_expr .)
    LBRACKET        reduce using rule 142 (primary_expr -> index_expr .)
    DOT             reduce using rule 142 (primary_expr -> index_expr .)
    ASSIGN          reduce using rule 142 (primary_expr -> index_expr .)
    PLUS            reduce using rule 142 (primary_expr -> index_expr .)
    MINUS           reduce using rule 142 (primary_expr -> index_expr .)
    MUL             reduce using rule 142 (primary_expr -> index_expr .)
    DIV             reduce using rule 142 (primary_expr -> index_expr .)
    AND             reduce using rule 142 (primary_expr -> index_expr .)
    OR              reduce using rule 142 (primary_expr -> index_expr .)
    XOR             reduce using rule 142 (primary_expr -> index_expr .)
    MOD             reduce using rule 142 (primary_expr -> index_expr .)
    LSHIFT          reduce using rule 142 (primary_expr -> index_expr .)
    RSHIFT          reduce using rule 142 (primary_expr -> index_expr .)
    LOGICAL_OR      reduce using rule 142 (primary_expr -> index_expr .)
    LOGICAL_AND     reduce using rule 142 (primary_expr -> index_expr .)
    NOT_EQUAL       reduce using rule 142 (primary_expr -> index_expr .)
    EQUAL           reduce using rule 142 (primary_expr -> index_expr .)
    LESS_EQUAL      reduce using rule 142 (primary_expr -> index_expr .)
    LESS            reduce using rule 142 (primary_expr -> index_expr .)
    GREATER_EQUAL   reduce using rule 142 (primary_expr -> index_expr .)
    GREATER         reduce using rule 142 (primary_expr -> index_expr .)
    SEMICOLON       reduce using rule 142 (primary_expr -> index_expr .)
    RPAREN          reduce using rule 142 (primary_expr -> index_expr .)
    COMMA           reduce using rule 142 (primary_expr -> index_expr .)
    RBRACKET        reduce using rule 142 (primary_expr -> index_expr .)


state 67

    (143) primary_expr -> cast_expr .

    LPAREN          reduce using rule 143 (primary_expr -> cast_expr .)
    GENERICMARK     reduce using rule 143 (primary_expr -> cast_expr .)
    LBRACKET        reduce using rule 143 (primary_expr -> cast_expr .)
    DOT             reduce using rule 143 (primary_expr -> cast_expr .)
    ASSIGN          reduce using rule 143 (primary_expr -> cast_expr .)
    PLUS            reduce using rule 143 (primary_expr -> cast_expr .)
    MINUS           reduce using rule 143 (primary_expr -> cast_expr .)
    MUL             reduce using rule 143 (primary_expr -> cast_expr .)
    DIV             reduce using rule 143 (primary_expr -> cast_expr .)
    AND             reduce using rule 143 (primary_expr -> cast_expr .)
    OR              reduce using rule 143 (primary_expr -> cast_expr .)
    XOR             reduce using rule 143 (primary_expr -> cast_expr .)
    MOD             reduce using rule 143 (primary_expr -> cast_expr .)
    LSHIFT          reduce using rule 143 (primary_expr -> cast_expr .)
    RSHIFT          reduce using rule 143 (primary_expr -> cast_expr .)
    LOGICAL_OR      reduce using rule 143 (primary_expr -> cast_expr .)
    LOGICAL_AND     reduce using rule 143 (primary_expr -> cast_expr .)
    NOT_EQUAL       reduce using rule 143 (primary_expr -> cast_expr .)
    EQUAL           reduce using rule 143 (primary_expr -> cast_expr .)
    LESS_EQUAL      reduce using rule 143 (primary_expr -> cast_expr .)
    LESS            reduce using rule 143 (primary_expr -> cast_expr .)
    GREATER_EQUAL   reduce using rule 143 (primary_expr -> cast_expr .)
    GREATER         reduce using rule 143 (primary_expr -> cast_expr .)
    SEMICOLON       reduce using rule 143 (primary_expr -> cast_expr .)
    RPAREN          reduce using rule 143 (primary_expr -> cast_expr .)
    COMMA           reduce using rule 143 (primary_expr -> cast_expr .)
    RBRACKET        reduce using rule 143 (primary_expr -> cast_expr .)


state 68

    (144) primary_expr -> new_expr .

    LPAREN          reduce using rule 144 (primary_expr -> new_expr .)
    GENERICMARK     reduce using rule 144 (primary_expr -> new_expr .)
    LBRACKET        reduce using rule 144 (primary_expr -> new_expr .)
    DOT             reduce using rule 144 (primary_expr -> new_expr .)
    ASSIGN          reduce using rule 144 (primary_expr -> new_expr .)
    PLUS            reduce using rule 144 (primary_expr -> new_expr .)
    MINUS           reduce using rule 144 (primary_expr -> new_expr .)
    MUL             reduce using rule 144 (primary_expr -> new_expr .)
    DIV             reduce using rule 144 (primary_expr -> new_expr .)
    AND             reduce using rule 144 (primary_expr -> new_expr .)
    OR              reduce using rule 144 (primary_expr -> new_expr .)
    XOR             reduce using rule 144 (primary_expr -> new_expr .)
    MOD             reduce using rule 144 (primary_expr -> new_expr .)
    LSHIFT          reduce using rule 144 (primary_expr -> new_expr .)
    RSHIFT          reduce using rule 144 (primary_expr -> new_expr .)
    LOGICAL_OR      reduce using rule 144 (primary_expr -> new_expr .)
    LOGICAL_AND     reduce using rule 144 (primary_expr -> new_expr .)
    NOT_EQUAL       reduce using rule 144 (primary_expr -> new_expr .)
    EQUAL           reduce using rule 144 (primary_expr -> new_expr .)
    LESS_EQUAL      reduce using rule 144 (primary_expr -> new_expr .)
    LESS            reduce using rule 144 (primary_expr -> new_expr .)
    GREATER_EQUAL   reduce using rule 144 (primary_expr -> new_expr .)
    GREATER         reduce using rule 144 (primary_expr -> new_expr .)
    SEMICOLON       reduce using rule 144 (primary_expr -> new_expr .)
    RPAREN          reduce using rule 144 (primary_expr -> new_expr .)
    COMMA           reduce using rule 144 (primary_expr -> new_expr .)
    RBRACKET        reduce using rule 144 (primary_expr -> new_expr .)


state 69

    (145) primary_expr -> member_expr .

    LPAREN          reduce using rule 145 (primary_expr -> member_expr .)
    GENERICMARK     reduce using rule 145 (primary_expr -> member_expr .)
    LBRACKET        reduce using rule 145 (primary_expr -> member_expr .)
    DOT             reduce using rule 145 (primary_expr -> member_expr .)
    ASSIGN          reduce using rule 145 (primary_expr -> member_expr .)
    PLUS            reduce using rule 145 (primary_expr -> member_expr .)
    MINUS           reduce using rule 145 (primary_expr -> member_expr .)
    MUL             reduce using rule 145 (primary_expr -> member_expr .)
    DIV             reduce using rule 145 (primary_expr -> member_expr .)
    AND             reduce using rule 145 (primary_expr -> member_expr .)
    OR              reduce using rule 145 (primary_expr -> member_expr .)
    XOR             reduce using rule 145 (primary_expr -> member_expr .)
    MOD             reduce using rule 145 (primary_expr -> member_expr .)
    LSHIFT          reduce using rule 145 (primary_expr -> member_expr .)
    RSHIFT          reduce using rule 145 (primary_expr -> member_expr .)
    LOGICAL_OR      reduce using rule 145 (primary_expr -> member_expr .)
    LOGICAL_AND     reduce using rule 145 (primary_expr -> member_expr .)
    NOT_EQUAL       reduce using rule 145 (primary_expr -> member_expr .)
    EQUAL           reduce using rule 145 (primary_expr -> member_expr .)
    LESS_EQUAL      reduce using rule 145 (primary_expr -> member_expr .)
    LESS            reduce using rule 145 (primary_expr -> member_expr .)
    GREATER_EQUAL   reduce using rule 145 (primary_expr -> member_expr .)
    GREATER         reduce using rule 145 (primary_expr -> member_expr .)
    SEMICOLON       reduce using rule 145 (primary_expr -> member_expr .)
    RPAREN          reduce using rule 145 (primary_expr -> member_expr .)
    COMMA           reduce using rule 145 (primary_expr -> member_expr .)
    RBRACKET        reduce using rule 145 (primary_expr -> member_expr .)


state 70

    (146) primary_expr -> lambda_expr .

    LPAREN          reduce using rule 146 (primary_expr -> lambda_expr .)
    GENERICMARK     reduce using rule 146 (primary_expr -> lambda_expr .)
    LBRACKET        reduce using rule 146 (primary_expr -> lambda_expr .)
    DOT             reduce using rule 146 (primary_expr -> lambda_expr .)
    ASSIGN          reduce using rule 146 (primary_expr -> lambda_expr .)
    PLUS            reduce using rule 146 (primary_expr -> lambda_expr .)
    MINUS           reduce using rule 146 (primary_expr -> lambda_expr .)
    MUL             reduce using rule 146 (primary_expr -> lambda_expr .)
    DIV             reduce using rule 146 (primary_expr -> lambda_expr .)
    AND             reduce using rule 146 (primary_expr -> lambda_expr .)
    OR              reduce using rule 146 (primary_expr -> lambda_expr .)
    XOR             reduce using rule 146 (primary_expr -> lambda_expr .)
    MOD             reduce using rule 146 (primary_expr -> lambda_expr .)
    LSHIFT          reduce using rule 146 (primary_expr -> lambda_expr .)
    RSHIFT          reduce using rule 146 (primary_expr -> lambda_expr .)
    LOGICAL_OR      reduce using rule 146 (primary_expr -> lambda_expr .)
    LOGICAL_AND     reduce using rule 146 (primary_expr -> lambda_expr .)
    NOT_EQUAL       reduce using rule 146 (primary_expr -> lambda_expr .)
    EQUAL           reduce using rule 146 (primary_expr -> lambda_expr .)
    LESS_EQUAL      reduce using rule 146 (primary_expr -> lambda_expr .)
    LESS            reduce using rule 146 (primary_expr -> lambda_expr .)
    GREATER_EQUAL   reduce using rule 146 (primary_expr -> lambda_expr .)
    GREATER         reduce using rule 146 (primary_expr -> lambda_expr .)
    SEMICOLON       reduce using rule 146 (primary_expr -> lambda_expr .)
    RPAREN          reduce using rule 146 (primary_expr -> lambda_expr .)
    COMMA           reduce using rule 146 (primary_expr -> lambda_expr .)
    RBRACKET        reduce using rule 146 (primary_expr -> lambda_expr .)


state 71

    (147) primary_expr -> io_expr .

    LPAREN          reduce using rule 147 (primary_expr -> io_expr .)
    GENERICMARK     reduce using rule 147 (primary_expr -> io_expr .)
    LBRACKET        reduce using rule 147 (primary_expr -> io_expr .)
    DOT             reduce using rule 147 (primary_expr -> io_expr .)
    ASSIGN          reduce using rule 147 (primary_expr -> io_expr .)
    PLUS            reduce using rule 147 (primary_expr -> io_expr .)
    MINUS           reduce using rule 147 (primary_expr -> io_expr .)
    MUL             reduce using rule 147 (primary_expr -> io_expr .)
    DIV             reduce using rule 147 (primary_expr -> io_expr .)
    AND             reduce using rule 147 (primary_expr -> io_expr .)
    OR              reduce using rule 147 (primary_expr -> io_expr .)
    XOR             reduce using rule 147 (primary_expr -> io_expr .)
    MOD             reduce using rule 147 (primary_expr -> io_expr .)
    LSHIFT          reduce using rule 147 (primary_expr -> io_expr .)
    RSHIFT          reduce using rule 147 (primary_expr -> io_expr .)
    LOGICAL_OR      reduce using rule 147 (primary_expr -> io_expr .)
    LOGICAL_AND     reduce using rule 147 (primary_expr -> io_expr .)
    NOT_EQUAL       reduce using rule 147 (primary_expr -> io_expr .)
    EQUAL           reduce using rule 147 (primary_expr -> io_expr .)
    LESS_EQUAL      reduce using rule 147 (primary_expr -> io_expr .)
    LESS            reduce using rule 147 (primary_expr -> io_expr .)
    GREATER_EQUAL   reduce using rule 147 (primary_expr -> io_expr .)
    GREATER         reduce using rule 147 (primary_expr -> io_expr .)
    SEMICOLON       reduce using rule 147 (primary_expr -> io_expr .)
    RPAREN          reduce using rule 147 (primary_expr -> io_expr .)
    COMMA           reduce using rule 147 (primary_expr -> io_expr .)
    RBRACKET        reduce using rule 147 (primary_expr -> io_expr .)


state 72

    (136) unary_operation -> NOT .

    INT             reduce using rule 136 (unary_operation -> NOT .)
    HEXADECIMAL     reduce using rule 136 (unary_operation -> NOT .)
    FLOAT           reduce using rule 136 (unary_operation -> NOT .)
    DOUBLE          reduce using rule 136 (unary_operation -> NOT .)
    STRING          reduce using rule 136 (unary_operation -> NOT .)
    ID              reduce using rule 136 (unary_operation -> NOT .)
    LPAREN          reduce using rule 136 (unary_operation -> NOT .)
    FUNC            reduce using rule 136 (unary_operation -> NOT .)
    IN              reduce using rule 136 (unary_operation -> NOT .)
    OUT             reduce using rule 136 (unary_operation -> NOT .)
    VOID            reduce using rule 136 (unary_operation -> NOT .)
    BOOL            reduce using rule 136 (unary_operation -> NOT .)
    I8              reduce using rule 136 (unary_operation -> NOT .)
    U8              reduce using rule 136 (unary_operation -> NOT .)
    I16             reduce using rule 136 (unary_operation -> NOT .)
    U16             reduce using rule 136 (unary_operation -> NOT .)
    I32             reduce using rule 136 (unary_operation -> NOT .)
    U32             reduce using rule 136 (unary_operation -> NOT .)
    I64             reduce using rule 136 (unary_operation -> NOT .)
    U64             reduce using rule 136 (unary_operation -> NOT .)
    F16             reduce using rule 136 (unary_operation -> NOT .)
    F32             reduce using rule 136 (unary_operation -> NOT .)
    F64             reduce using rule 136 (unary_operation -> NOT .)
    INTERFACEID     reduce using rule 136 (unary_operation -> NOT .)
    STRUCTID        reduce using rule 136 (unary_operation -> NOT .)
    GENERICID       reduce using rule 136 (unary_operation -> NOT .)
    TYPEALIASID     reduce using rule 136 (unary_operation -> NOT .)
    LESS            reduce using rule 136 (unary_operation -> NOT .)


state 73

    (137) unary_operation -> LOGICAL_NOT .

    INT             reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    HEXADECIMAL     reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    FLOAT           reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    DOUBLE          reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    STRING          reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    ID              reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    LPAREN          reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    FUNC            reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    IN              reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    OUT             reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    VOID            reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    BOOL            reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    I8              reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    U8              reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    I16             reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    U16             reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    I32             reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    U32             reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    I64             reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    U64             reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    F16             reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    F32             reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    F64             reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    INTERFACEID     reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    STRUCTID        reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    GENERICID       reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    TYPEALIASID     reduce using rule 137 (unary_operation -> LOGICAL_NOT .)
    LESS            reduce using rule 137 (unary_operation -> LOGICAL_NOT .)


state 74

    (148) operand -> INT .

    LPAREN          reduce using rule 148 (operand -> INT .)
    GENERICMARK     reduce using rule 148 (operand -> INT .)
    LBRACKET        reduce using rule 148 (operand -> INT .)
    DOT             reduce using rule 148 (operand -> INT .)
    ASSIGN          reduce using rule 148 (operand -> INT .)
    PLUS            reduce using rule 148 (operand -> INT .)
    MINUS           reduce using rule 148 (operand -> INT .)
    MUL             reduce using rule 148 (operand -> INT .)
    DIV             reduce using rule 148 (operand -> INT .)
    AND             reduce using rule 148 (operand -> INT .)
    OR              reduce using rule 148 (operand -> INT .)
    XOR             reduce using rule 148 (operand -> INT .)
    MOD             reduce using rule 148 (operand -> INT .)
    LSHIFT          reduce using rule 148 (operand -> INT .)
    RSHIFT          reduce using rule 148 (operand -> INT .)
    LOGICAL_OR      reduce using rule 148 (operand -> INT .)
    LOGICAL_AND     reduce using rule 148 (operand -> INT .)
    NOT_EQUAL       reduce using rule 148 (operand -> INT .)
    EQUAL           reduce using rule 148 (operand -> INT .)
    LESS_EQUAL      reduce using rule 148 (operand -> INT .)
    LESS            reduce using rule 148 (operand -> INT .)
    GREATER_EQUAL   reduce using rule 148 (operand -> INT .)
    GREATER         reduce using rule 148 (operand -> INT .)
    SEMICOLON       reduce using rule 148 (operand -> INT .)
    RPAREN          reduce using rule 148 (operand -> INT .)
    COMMA           reduce using rule 148 (operand -> INT .)
    RBRACKET        reduce using rule 148 (operand -> INT .)


state 75

    (149) operand -> HEXADECIMAL .

    LPAREN          reduce using rule 149 (operand -> HEXADECIMAL .)
    GENERICMARK     reduce using rule 149 (operand -> HEXADECIMAL .)
    LBRACKET        reduce using rule 149 (operand -> HEXADECIMAL .)
    DOT             reduce using rule 149 (operand -> HEXADECIMAL .)
    ASSIGN          reduce using rule 149 (operand -> HEXADECIMAL .)
    PLUS            reduce using rule 149 (operand -> HEXADECIMAL .)
    MINUS           reduce using rule 149 (operand -> HEXADECIMAL .)
    MUL             reduce using rule 149 (operand -> HEXADECIMAL .)
    DIV             reduce using rule 149 (operand -> HEXADECIMAL .)
    AND             reduce using rule 149 (operand -> HEXADECIMAL .)
    OR              reduce using rule 149 (operand -> HEXADECIMAL .)
    XOR             reduce using rule 149 (operand -> HEXADECIMAL .)
    MOD             reduce using rule 149 (operand -> HEXADECIMAL .)
    LSHIFT          reduce using rule 149 (operand -> HEXADECIMAL .)
    RSHIFT          reduce using rule 149 (operand -> HEXADECIMAL .)
    LOGICAL_OR      reduce using rule 149 (operand -> HEXADECIMAL .)
    LOGICAL_AND     reduce using rule 149 (operand -> HEXADECIMAL .)
    NOT_EQUAL       reduce using rule 149 (operand -> HEXADECIMAL .)
    EQUAL           reduce using rule 149 (operand -> HEXADECIMAL .)
    LESS_EQUAL      reduce using rule 149 (operand -> HEXADECIMAL .)
    LESS            reduce using rule 149 (operand -> HEXADECIMAL .)
    GREATER_EQUAL   reduce using rule 149 (operand -> HEXADECIMAL .)
    GREATER         reduce using rule 149 (operand -> HEXADECIMAL .)
    SEMICOLON       reduce using rule 149 (operand -> HEXADECIMAL .)
    RPAREN          reduce using rule 149 (operand -> HEXADECIMAL .)
    COMMA           reduce using rule 149 (operand -> HEXADECIMAL .)
    RBRACKET        reduce using rule 149 (operand -> HEXADECIMAL .)


state 76

    (150) operand -> FLOAT .

    LPAREN          reduce using rule 150 (operand -> FLOAT .)
    GENERICMARK     reduce using rule 150 (operand -> FLOAT .)
    LBRACKET        reduce using rule 150 (operand -> FLOAT .)
    DOT             reduce using rule 150 (operand -> FLOAT .)
    ASSIGN          reduce using rule 150 (operand -> FLOAT .)
    PLUS            reduce using rule 150 (operand -> FLOAT .)
    MINUS           reduce using rule 150 (operand -> FLOAT .)
    MUL             reduce using rule 150 (operand -> FLOAT .)
    DIV             reduce using rule 150 (operand -> FLOAT .)
    AND             reduce using rule 150 (operand -> FLOAT .)
    OR              reduce using rule 150 (operand -> FLOAT .)
    XOR             reduce using rule 150 (operand -> FLOAT .)
    MOD             reduce using rule 150 (operand -> FLOAT .)
    LSHIFT          reduce using rule 150 (operand -> FLOAT .)
    RSHIFT          reduce using rule 150 (operand -> FLOAT .)
    LOGICAL_OR      reduce using rule 150 (operand -> FLOAT .)
    LOGICAL_AND     reduce using rule 150 (operand -> FLOAT .)
    NOT_EQUAL       reduce using rule 150 (operand -> FLOAT .)
    EQUAL           reduce using rule 150 (operand -> FLOAT .)
    LESS_EQUAL      reduce using rule 150 (operand -> FLOAT .)
    LESS            reduce using rule 150 (operand -> FLOAT .)
    GREATER_EQUAL   reduce using rule 150 (operand -> FLOAT .)
    GREATER         reduce using rule 150 (operand -> FLOAT .)
    SEMICOLON       reduce using rule 150 (operand -> FLOAT .)
    RPAREN          reduce using rule 150 (operand -> FLOAT .)
    COMMA           reduce using rule 150 (operand -> FLOAT .)
    RBRACKET        reduce using rule 150 (operand -> FLOAT .)


state 77

    (151) operand -> DOUBLE .

    LPAREN          reduce using rule 151 (operand -> DOUBLE .)
    GENERICMARK     reduce using rule 151 (operand -> DOUBLE .)
    LBRACKET        reduce using rule 151 (operand -> DOUBLE .)
    DOT             reduce using rule 151 (operand -> DOUBLE .)
    ASSIGN          reduce using rule 151 (operand -> DOUBLE .)
    PLUS            reduce using rule 151 (operand -> DOUBLE .)
    MINUS           reduce using rule 151 (operand -> DOUBLE .)
    MUL             reduce using rule 151 (operand -> DOUBLE .)
    DIV             reduce using rule 151 (operand -> DOUBLE .)
    AND             reduce using rule 151 (operand -> DOUBLE .)
    OR              reduce using rule 151 (operand -> DOUBLE .)
    XOR             reduce using rule 151 (operand -> DOUBLE .)
    MOD             reduce using rule 151 (operand -> DOUBLE .)
    LSHIFT          reduce using rule 151 (operand -> DOUBLE .)
    RSHIFT          reduce using rule 151 (operand -> DOUBLE .)
    LOGICAL_OR      reduce using rule 151 (operand -> DOUBLE .)
    LOGICAL_AND     reduce using rule 151 (operand -> DOUBLE .)
    NOT_EQUAL       reduce using rule 151 (operand -> DOUBLE .)
    EQUAL           reduce using rule 151 (operand -> DOUBLE .)
    LESS_EQUAL      reduce using rule 151 (operand -> DOUBLE .)
    LESS            reduce using rule 151 (operand -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 151 (operand -> DOUBLE .)
    GREATER         reduce using rule 151 (operand -> DOUBLE .)
    SEMICOLON       reduce using rule 151 (operand -> DOUBLE .)
    RPAREN          reduce using rule 151 (operand -> DOUBLE .)
    COMMA           reduce using rule 151 (operand -> DOUBLE .)
    RBRACKET        reduce using rule 151 (operand -> DOUBLE .)


state 78

    (152) operand -> STRING .

    LPAREN          reduce using rule 152 (operand -> STRING .)
    GENERICMARK     reduce using rule 152 (operand -> STRING .)
    LBRACKET        reduce using rule 152 (operand -> STRING .)
    DOT             reduce using rule 152 (operand -> STRING .)
    ASSIGN          reduce using rule 152 (operand -> STRING .)
    PLUS            reduce using rule 152 (operand -> STRING .)
    MINUS           reduce using rule 152 (operand -> STRING .)
    MUL             reduce using rule 152 (operand -> STRING .)
    DIV             reduce using rule 152 (operand -> STRING .)
    AND             reduce using rule 152 (operand -> STRING .)
    OR              reduce using rule 152 (operand -> STRING .)
    XOR             reduce using rule 152 (operand -> STRING .)
    MOD             reduce using rule 152 (operand -> STRING .)
    LSHIFT          reduce using rule 152 (operand -> STRING .)
    RSHIFT          reduce using rule 152 (operand -> STRING .)
    LOGICAL_OR      reduce using rule 152 (operand -> STRING .)
    LOGICAL_AND     reduce using rule 152 (operand -> STRING .)
    NOT_EQUAL       reduce using rule 152 (operand -> STRING .)
    EQUAL           reduce using rule 152 (operand -> STRING .)
    LESS_EQUAL      reduce using rule 152 (operand -> STRING .)
    LESS            reduce using rule 152 (operand -> STRING .)
    GREATER_EQUAL   reduce using rule 152 (operand -> STRING .)
    GREATER         reduce using rule 152 (operand -> STRING .)
    SEMICOLON       reduce using rule 152 (operand -> STRING .)
    RPAREN          reduce using rule 152 (operand -> STRING .)
    COMMA           reduce using rule 152 (operand -> STRING .)
    RBRACKET        reduce using rule 152 (operand -> STRING .)


state 79

    (153) operand -> ID .

    LPAREN          reduce using rule 153 (operand -> ID .)
    GENERICMARK     reduce using rule 153 (operand -> ID .)
    LBRACKET        reduce using rule 153 (operand -> ID .)
    DOT             reduce using rule 153 (operand -> ID .)
    ASSIGN          reduce using rule 153 (operand -> ID .)
    PLUS            reduce using rule 153 (operand -> ID .)
    MINUS           reduce using rule 153 (operand -> ID .)
    MUL             reduce using rule 153 (operand -> ID .)
    DIV             reduce using rule 153 (operand -> ID .)
    AND             reduce using rule 153 (operand -> ID .)
    OR              reduce using rule 153 (operand -> ID .)
    XOR             reduce using rule 153 (operand -> ID .)
    MOD             reduce using rule 153 (operand -> ID .)
    LSHIFT          reduce using rule 153 (operand -> ID .)
    RSHIFT          reduce using rule 153 (operand -> ID .)
    LOGICAL_OR      reduce using rule 153 (operand -> ID .)
    LOGICAL_AND     reduce using rule 153 (operand -> ID .)
    NOT_EQUAL       reduce using rule 153 (operand -> ID .)
    EQUAL           reduce using rule 153 (operand -> ID .)
    LESS_EQUAL      reduce using rule 153 (operand -> ID .)
    LESS            reduce using rule 153 (operand -> ID .)
    GREATER_EQUAL   reduce using rule 153 (operand -> ID .)
    GREATER         reduce using rule 153 (operand -> ID .)
    SEMICOLON       reduce using rule 153 (operand -> ID .)
    RPAREN          reduce using rule 153 (operand -> ID .)
    COMMA           reduce using rule 153 (operand -> ID .)
    RBRACKET        reduce using rule 153 (operand -> ID .)


state 80

    (158) new_expr -> type_spec . LPAREN parameter_list_opt RPAREN
    (46) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> type_spec . REF

    LPAREN          shift and go to state 164
    LBRACKET        shift and go to state 165
    REF             shift and go to state 166


state 81

    (170) lambda_expr -> FUNC . function_sign block_statement
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    function_sign                  shift and go to state 167
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 82

    (50) function_type -> function_sign .

    LPAREN          reduce using rule 50 (function_type -> function_sign .)
    LBRACKET        reduce using rule 50 (function_type -> function_sign .)
    REF             reduce using rule 50 (function_type -> function_sign .)
    RPAREN          reduce using rule 50 (function_type -> function_sign .)
    ASSIGN          reduce using rule 50 (function_type -> function_sign .)
    COMMA           reduce using rule 50 (function_type -> function_sign .)
    SEMICOLON       reduce using rule 50 (function_type -> function_sign .)
    GREATER         reduce using rule 50 (function_type -> function_sign .)
    LESS            reduce using rule 50 (function_type -> function_sign .)
    LBRACE          reduce using rule 50 (function_type -> function_sign .)


state 83

    (171) io_expr -> in_out . LESS type_spec GREATER LPAREN STRING RPAREN

    LESS            shift and go to state 168


state 84

    (22) type_spec -> simple_type .

    LPAREN          reduce using rule 22 (type_spec -> simple_type .)
    LBRACKET        reduce using rule 22 (type_spec -> simple_type .)
    REF             reduce using rule 22 (type_spec -> simple_type .)
    RPAREN          reduce using rule 22 (type_spec -> simple_type .)
    ASSIGN          reduce using rule 22 (type_spec -> simple_type .)
    COMMA           reduce using rule 22 (type_spec -> simple_type .)
    SEMICOLON       reduce using rule 22 (type_spec -> simple_type .)
    GREATER         reduce using rule 22 (type_spec -> simple_type .)
    LESS            reduce using rule 22 (type_spec -> simple_type .)
    LBRACE          reduce using rule 22 (type_spec -> simple_type .)


state 85

    (23) type_spec -> complex_type .

    LPAREN          reduce using rule 23 (type_spec -> complex_type .)
    LBRACKET        reduce using rule 23 (type_spec -> complex_type .)
    REF             reduce using rule 23 (type_spec -> complex_type .)
    RPAREN          reduce using rule 23 (type_spec -> complex_type .)
    ASSIGN          reduce using rule 23 (type_spec -> complex_type .)
    COMMA           reduce using rule 23 (type_spec -> complex_type .)
    SEMICOLON       reduce using rule 23 (type_spec -> complex_type .)
    GREATER         reduce using rule 23 (type_spec -> complex_type .)
    LESS            reduce using rule 23 (type_spec -> complex_type .)
    LBRACE          reduce using rule 23 (type_spec -> complex_type .)


state 86

    (24) type_spec -> generic_type .

    LPAREN          reduce using rule 24 (type_spec -> generic_type .)
    LBRACKET        reduce using rule 24 (type_spec -> generic_type .)
    REF             reduce using rule 24 (type_spec -> generic_type .)
    RPAREN          reduce using rule 24 (type_spec -> generic_type .)
    ASSIGN          reduce using rule 24 (type_spec -> generic_type .)
    COMMA           reduce using rule 24 (type_spec -> generic_type .)
    SEMICOLON       reduce using rule 24 (type_spec -> generic_type .)
    GREATER         reduce using rule 24 (type_spec -> generic_type .)
    LESS            reduce using rule 24 (type_spec -> generic_type .)
    LBRACE          reduce using rule 24 (type_spec -> generic_type .)


state 87

    (25) type_spec -> alias_type .

    LPAREN          reduce using rule 25 (type_spec -> alias_type .)
    LBRACKET        reduce using rule 25 (type_spec -> alias_type .)
    REF             reduce using rule 25 (type_spec -> alias_type .)
    RPAREN          reduce using rule 25 (type_spec -> alias_type .)
    ASSIGN          reduce using rule 25 (type_spec -> alias_type .)
    COMMA           reduce using rule 25 (type_spec -> alias_type .)
    SEMICOLON       reduce using rule 25 (type_spec -> alias_type .)
    GREATER         reduce using rule 25 (type_spec -> alias_type .)
    LESS            reduce using rule 25 (type_spec -> alias_type .)
    LBRACE          reduce using rule 25 (type_spec -> alias_type .)


state 88

    (26) type_spec -> array_type .

    LPAREN          reduce using rule 26 (type_spec -> array_type .)
    LBRACKET        reduce using rule 26 (type_spec -> array_type .)
    REF             reduce using rule 26 (type_spec -> array_type .)
    RPAREN          reduce using rule 26 (type_spec -> array_type .)
    ASSIGN          reduce using rule 26 (type_spec -> array_type .)
    COMMA           reduce using rule 26 (type_spec -> array_type .)
    SEMICOLON       reduce using rule 26 (type_spec -> array_type .)
    GREATER         reduce using rule 26 (type_spec -> array_type .)
    LESS            reduce using rule 26 (type_spec -> array_type .)
    LBRACE          reduce using rule 26 (type_spec -> array_type .)


state 89

    (27) type_spec -> reference_type .

    LPAREN          reduce using rule 27 (type_spec -> reference_type .)
    LBRACKET        reduce using rule 27 (type_spec -> reference_type .)
    REF             reduce using rule 27 (type_spec -> reference_type .)
    RPAREN          reduce using rule 27 (type_spec -> reference_type .)
    ASSIGN          reduce using rule 27 (type_spec -> reference_type .)
    COMMA           reduce using rule 27 (type_spec -> reference_type .)
    SEMICOLON       reduce using rule 27 (type_spec -> reference_type .)
    GREATER         reduce using rule 27 (type_spec -> reference_type .)
    LESS            reduce using rule 27 (type_spec -> reference_type .)
    LBRACE          reduce using rule 27 (type_spec -> reference_type .)


state 90

    (28) type_spec -> function_type .

    LPAREN          reduce using rule 28 (type_spec -> function_type .)
    LBRACKET        reduce using rule 28 (type_spec -> function_type .)
    REF             reduce using rule 28 (type_spec -> function_type .)
    RPAREN          reduce using rule 28 (type_spec -> function_type .)
    ASSIGN          reduce using rule 28 (type_spec -> function_type .)
    COMMA           reduce using rule 28 (type_spec -> function_type .)
    SEMICOLON       reduce using rule 28 (type_spec -> function_type .)
    GREATER         reduce using rule 28 (type_spec -> function_type .)
    LESS            reduce using rule 28 (type_spec -> function_type .)
    LBRACE          reduce using rule 28 (type_spec -> function_type .)


state 91

    (172) in_out -> IN .

    LESS            reduce using rule 172 (in_out -> IN .)


state 92

    (173) in_out -> OUT .

    LESS            reduce using rule 173 (in_out -> OUT .)


state 93

    (29) simple_type -> VOID .

    LPAREN          reduce using rule 29 (simple_type -> VOID .)
    LBRACKET        reduce using rule 29 (simple_type -> VOID .)
    REF             reduce using rule 29 (simple_type -> VOID .)
    RPAREN          reduce using rule 29 (simple_type -> VOID .)
    ASSIGN          reduce using rule 29 (simple_type -> VOID .)
    COMMA           reduce using rule 29 (simple_type -> VOID .)
    SEMICOLON       reduce using rule 29 (simple_type -> VOID .)
    GREATER         reduce using rule 29 (simple_type -> VOID .)
    LESS            reduce using rule 29 (simple_type -> VOID .)
    LBRACE          reduce using rule 29 (simple_type -> VOID .)


state 94

    (30) simple_type -> BOOL .

    LPAREN          reduce using rule 30 (simple_type -> BOOL .)
    LBRACKET        reduce using rule 30 (simple_type -> BOOL .)
    REF             reduce using rule 30 (simple_type -> BOOL .)
    RPAREN          reduce using rule 30 (simple_type -> BOOL .)
    ASSIGN          reduce using rule 30 (simple_type -> BOOL .)
    COMMA           reduce using rule 30 (simple_type -> BOOL .)
    SEMICOLON       reduce using rule 30 (simple_type -> BOOL .)
    GREATER         reduce using rule 30 (simple_type -> BOOL .)
    LESS            reduce using rule 30 (simple_type -> BOOL .)
    LBRACE          reduce using rule 30 (simple_type -> BOOL .)


state 95

    (31) simple_type -> I8 .

    LPAREN          reduce using rule 31 (simple_type -> I8 .)
    LBRACKET        reduce using rule 31 (simple_type -> I8 .)
    REF             reduce using rule 31 (simple_type -> I8 .)
    RPAREN          reduce using rule 31 (simple_type -> I8 .)
    ASSIGN          reduce using rule 31 (simple_type -> I8 .)
    COMMA           reduce using rule 31 (simple_type -> I8 .)
    SEMICOLON       reduce using rule 31 (simple_type -> I8 .)
    GREATER         reduce using rule 31 (simple_type -> I8 .)
    LESS            reduce using rule 31 (simple_type -> I8 .)
    LBRACE          reduce using rule 31 (simple_type -> I8 .)


state 96

    (32) simple_type -> U8 .

    LPAREN          reduce using rule 32 (simple_type -> U8 .)
    LBRACKET        reduce using rule 32 (simple_type -> U8 .)
    REF             reduce using rule 32 (simple_type -> U8 .)
    RPAREN          reduce using rule 32 (simple_type -> U8 .)
    ASSIGN          reduce using rule 32 (simple_type -> U8 .)
    COMMA           reduce using rule 32 (simple_type -> U8 .)
    SEMICOLON       reduce using rule 32 (simple_type -> U8 .)
    GREATER         reduce using rule 32 (simple_type -> U8 .)
    LESS            reduce using rule 32 (simple_type -> U8 .)
    LBRACE          reduce using rule 32 (simple_type -> U8 .)


state 97

    (33) simple_type -> I16 .

    LPAREN          reduce using rule 33 (simple_type -> I16 .)
    LBRACKET        reduce using rule 33 (simple_type -> I16 .)
    REF             reduce using rule 33 (simple_type -> I16 .)
    RPAREN          reduce using rule 33 (simple_type -> I16 .)
    ASSIGN          reduce using rule 33 (simple_type -> I16 .)
    COMMA           reduce using rule 33 (simple_type -> I16 .)
    SEMICOLON       reduce using rule 33 (simple_type -> I16 .)
    GREATER         reduce using rule 33 (simple_type -> I16 .)
    LESS            reduce using rule 33 (simple_type -> I16 .)
    LBRACE          reduce using rule 33 (simple_type -> I16 .)


state 98

    (34) simple_type -> U16 .

    LPAREN          reduce using rule 34 (simple_type -> U16 .)
    LBRACKET        reduce using rule 34 (simple_type -> U16 .)
    REF             reduce using rule 34 (simple_type -> U16 .)
    RPAREN          reduce using rule 34 (simple_type -> U16 .)
    ASSIGN          reduce using rule 34 (simple_type -> U16 .)
    COMMA           reduce using rule 34 (simple_type -> U16 .)
    SEMICOLON       reduce using rule 34 (simple_type -> U16 .)
    GREATER         reduce using rule 34 (simple_type -> U16 .)
    LESS            reduce using rule 34 (simple_type -> U16 .)
    LBRACE          reduce using rule 34 (simple_type -> U16 .)


state 99

    (35) simple_type -> I32 .

    LPAREN          reduce using rule 35 (simple_type -> I32 .)
    LBRACKET        reduce using rule 35 (simple_type -> I32 .)
    REF             reduce using rule 35 (simple_type -> I32 .)
    RPAREN          reduce using rule 35 (simple_type -> I32 .)
    ASSIGN          reduce using rule 35 (simple_type -> I32 .)
    COMMA           reduce using rule 35 (simple_type -> I32 .)
    SEMICOLON       reduce using rule 35 (simple_type -> I32 .)
    GREATER         reduce using rule 35 (simple_type -> I32 .)
    LESS            reduce using rule 35 (simple_type -> I32 .)
    LBRACE          reduce using rule 35 (simple_type -> I32 .)


state 100

    (36) simple_type -> U32 .

    LPAREN          reduce using rule 36 (simple_type -> U32 .)
    LBRACKET        reduce using rule 36 (simple_type -> U32 .)
    REF             reduce using rule 36 (simple_type -> U32 .)
    RPAREN          reduce using rule 36 (simple_type -> U32 .)
    ASSIGN          reduce using rule 36 (simple_type -> U32 .)
    COMMA           reduce using rule 36 (simple_type -> U32 .)
    SEMICOLON       reduce using rule 36 (simple_type -> U32 .)
    GREATER         reduce using rule 36 (simple_type -> U32 .)
    LESS            reduce using rule 36 (simple_type -> U32 .)
    LBRACE          reduce using rule 36 (simple_type -> U32 .)


state 101

    (37) simple_type -> I64 .

    LPAREN          reduce using rule 37 (simple_type -> I64 .)
    LBRACKET        reduce using rule 37 (simple_type -> I64 .)
    REF             reduce using rule 37 (simple_type -> I64 .)
    RPAREN          reduce using rule 37 (simple_type -> I64 .)
    ASSIGN          reduce using rule 37 (simple_type -> I64 .)
    COMMA           reduce using rule 37 (simple_type -> I64 .)
    SEMICOLON       reduce using rule 37 (simple_type -> I64 .)
    GREATER         reduce using rule 37 (simple_type -> I64 .)
    LESS            reduce using rule 37 (simple_type -> I64 .)
    LBRACE          reduce using rule 37 (simple_type -> I64 .)


state 102

    (38) simple_type -> U64 .

    LPAREN          reduce using rule 38 (simple_type -> U64 .)
    LBRACKET        reduce using rule 38 (simple_type -> U64 .)
    REF             reduce using rule 38 (simple_type -> U64 .)
    RPAREN          reduce using rule 38 (simple_type -> U64 .)
    ASSIGN          reduce using rule 38 (simple_type -> U64 .)
    COMMA           reduce using rule 38 (simple_type -> U64 .)
    SEMICOLON       reduce using rule 38 (simple_type -> U64 .)
    GREATER         reduce using rule 38 (simple_type -> U64 .)
    LESS            reduce using rule 38 (simple_type -> U64 .)
    LBRACE          reduce using rule 38 (simple_type -> U64 .)


state 103

    (39) simple_type -> F16 .

    LPAREN          reduce using rule 39 (simple_type -> F16 .)
    LBRACKET        reduce using rule 39 (simple_type -> F16 .)
    REF             reduce using rule 39 (simple_type -> F16 .)
    RPAREN          reduce using rule 39 (simple_type -> F16 .)
    ASSIGN          reduce using rule 39 (simple_type -> F16 .)
    COMMA           reduce using rule 39 (simple_type -> F16 .)
    SEMICOLON       reduce using rule 39 (simple_type -> F16 .)
    GREATER         reduce using rule 39 (simple_type -> F16 .)
    LESS            reduce using rule 39 (simple_type -> F16 .)
    LBRACE          reduce using rule 39 (simple_type -> F16 .)


state 104

    (40) simple_type -> F32 .

    LPAREN          reduce using rule 40 (simple_type -> F32 .)
    LBRACKET        reduce using rule 40 (simple_type -> F32 .)
    REF             reduce using rule 40 (simple_type -> F32 .)
    RPAREN          reduce using rule 40 (simple_type -> F32 .)
    ASSIGN          reduce using rule 40 (simple_type -> F32 .)
    COMMA           reduce using rule 40 (simple_type -> F32 .)
    SEMICOLON       reduce using rule 40 (simple_type -> F32 .)
    GREATER         reduce using rule 40 (simple_type -> F32 .)
    LESS            reduce using rule 40 (simple_type -> F32 .)
    LBRACE          reduce using rule 40 (simple_type -> F32 .)


state 105

    (41) simple_type -> F64 .

    LPAREN          reduce using rule 41 (simple_type -> F64 .)
    LBRACKET        reduce using rule 41 (simple_type -> F64 .)
    REF             reduce using rule 41 (simple_type -> F64 .)
    RPAREN          reduce using rule 41 (simple_type -> F64 .)
    ASSIGN          reduce using rule 41 (simple_type -> F64 .)
    COMMA           reduce using rule 41 (simple_type -> F64 .)
    SEMICOLON       reduce using rule 41 (simple_type -> F64 .)
    GREATER         reduce using rule 41 (simple_type -> F64 .)
    LESS            reduce using rule 41 (simple_type -> F64 .)
    LBRACE          reduce using rule 41 (simple_type -> F64 .)


state 106

    (42) complex_type -> INTERFACEID . generics_specialization_list_opt
    (163) generics_specialization_list_opt -> . LESS type_spec type_spec_comma_nest GREATER
    (164) generics_specialization_list_opt -> . empty
    (174) empty -> .

  ! shift/reduce conflict for LESS resolved as shift
    LESS            shift and go to state 170
    LPAREN          reduce using rule 174 (empty -> .)
    LBRACKET        reduce using rule 174 (empty -> .)
    REF             reduce using rule 174 (empty -> .)
    RPAREN          reduce using rule 174 (empty -> .)
    ASSIGN          reduce using rule 174 (empty -> .)
    COMMA           reduce using rule 174 (empty -> .)
    SEMICOLON       reduce using rule 174 (empty -> .)
    GREATER         reduce using rule 174 (empty -> .)
    LBRACE          reduce using rule 174 (empty -> .)

  ! LESS            [ reduce using rule 174 (empty -> .) ]

    generics_specialization_list_opt shift and go to state 169
    empty                          shift and go to state 171

state 107

    (43) complex_type -> STRUCTID . generics_specialization_list_opt
    (163) generics_specialization_list_opt -> . LESS type_spec type_spec_comma_nest GREATER
    (164) generics_specialization_list_opt -> . empty
    (174) empty -> .

  ! shift/reduce conflict for LESS resolved as shift
    LESS            shift and go to state 170
    LPAREN          reduce using rule 174 (empty -> .)
    LBRACKET        reduce using rule 174 (empty -> .)
    REF             reduce using rule 174 (empty -> .)
    RPAREN          reduce using rule 174 (empty -> .)
    ASSIGN          reduce using rule 174 (empty -> .)
    COMMA           reduce using rule 174 (empty -> .)
    SEMICOLON       reduce using rule 174 (empty -> .)
    GREATER         reduce using rule 174 (empty -> .)
    LBRACE          reduce using rule 174 (empty -> .)

  ! LESS            [ reduce using rule 174 (empty -> .) ]

    generics_specialization_list_opt shift and go to state 172
    empty                          shift and go to state 171

state 108

    (44) generic_type -> GENERICID .

    LPAREN          reduce using rule 44 (generic_type -> GENERICID .)
    LBRACKET        reduce using rule 44 (generic_type -> GENERICID .)
    REF             reduce using rule 44 (generic_type -> GENERICID .)
    RPAREN          reduce using rule 44 (generic_type -> GENERICID .)
    ASSIGN          reduce using rule 44 (generic_type -> GENERICID .)
    COMMA           reduce using rule 44 (generic_type -> GENERICID .)
    SEMICOLON       reduce using rule 44 (generic_type -> GENERICID .)
    GREATER         reduce using rule 44 (generic_type -> GENERICID .)
    LESS            reduce using rule 44 (generic_type -> GENERICID .)
    LBRACE          reduce using rule 44 (generic_type -> GENERICID .)


state 109

    (45) alias_type -> TYPEALIASID .

    LPAREN          reduce using rule 45 (alias_type -> TYPEALIASID .)
    LBRACKET        reduce using rule 45 (alias_type -> TYPEALIASID .)
    REF             reduce using rule 45 (alias_type -> TYPEALIASID .)
    RPAREN          reduce using rule 45 (alias_type -> TYPEALIASID .)
    ASSIGN          reduce using rule 45 (alias_type -> TYPEALIASID .)
    COMMA           reduce using rule 45 (alias_type -> TYPEALIASID .)
    SEMICOLON       reduce using rule 45 (alias_type -> TYPEALIASID .)
    GREATER         reduce using rule 45 (alias_type -> TYPEALIASID .)
    LESS            reduce using rule 45 (alias_type -> TYPEALIASID .)
    LBRACE          reduce using rule 45 (alias_type -> TYPEALIASID .)


state 110

    (71) function_sign -> generics_type_list_opt . LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt

    LPAREN          shift and go to state 173


state 111

    (57) generics_type_list_opt -> generics_type_list .

    LPAREN          reduce using rule 57 (generics_type_list_opt -> generics_type_list .)
    COLON           reduce using rule 57 (generics_type_list_opt -> generics_type_list .)
    LBRACE          reduce using rule 57 (generics_type_list_opt -> generics_type_list .)


state 112

    (13) variable_decl -> LET declarator declarator_nest .

    SEMICOLON       reduce using rule 13 (variable_decl -> LET declarator declarator_nest .)


state 113

    (14) declarator_nest -> COMMA . declarator declarator_nest
    (17) declarator -> . ID type_spec_colon_opt ASSIGN expression

    ID              shift and go to state 28

    declarator                     shift and go to state 174

state 114

    (15) declarator_nest -> empty .

    SEMICOLON       reduce using rule 15 (declarator_nest -> empty .)


state 115

    (17) declarator -> ID type_spec_colon_opt . ASSIGN expression

    ASSIGN          shift and go to state 175


state 116

    (18) type_spec_colon_opt -> COLON . type_spec
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    type_spec                      shift and go to state 176
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    function_sign                  shift and go to state 82
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 117

    (19) type_spec_colon_opt -> empty .

    ASSIGN          reduce using rule 19 (type_spec_colon_opt -> empty .)
    COMMA           reduce using rule 19 (type_spec_colon_opt -> empty .)
    RPAREN          reduce using rule 19 (type_spec_colon_opt -> empty .)


state 118

    (16) constant_decl -> CONST declarator declarator_nest .

    SEMICOLON       reduce using rule 16 (constant_decl -> CONST declarator declarator_nest .)


state 119

    (20) function_decl -> FUNC ID function_sign .

    SEMICOLON       reduce using rule 20 (function_decl -> FUNC ID function_sign .)
    LBRACE          reduce using rule 20 (function_decl -> FUNC ID function_sign .)


state 120

    (58) generics_type_list_opt -> empty .

    LPAREN          reduce using rule 58 (generics_type_list_opt -> empty .)
    COLON           reduce using rule 58 (generics_type_list_opt -> empty .)
    LBRACE          reduce using rule 58 (generics_type_list_opt -> empty .)


state 121

    (12) type_alias_decl -> TYPE ID ASSIGN . type_spec
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    type_spec                      shift and go to state 177
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    function_sign                  shift and go to state 82
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 122

    (51) struct_decl -> STRUCT ID new_struct . generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    LESS            shift and go to state 62
    COLON           reduce using rule 174 (empty -> .)
    LBRACE          reduce using rule 174 (empty -> .)

    generics_type_list_opt         shift and go to state 178
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 123

    (55) interface_decl -> INTERFACE ID new_interface . generics_type_list_opt LBRACE interface_member_decl_nest RBRACE
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    LESS            shift and go to state 62
    LBRACE          reduce using rule 174 (empty -> .)

    generics_type_list_opt         shift and go to state 179
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 124

    (94) block_statement -> LBRACE statement_nest RBRACE .

    LET             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    CONST           reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    FUNC            reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    TYPE            reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    STRUCT          reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    INTERFACE       reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    $end            reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    LBRACE          reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    IF              reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    BREAK           reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    CONTINUE        reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    RETURN          reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    WHILE           reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    FOR             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    NOT             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    LOGICAL_NOT     reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    PLUS            reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    MINUS           reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    INT             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    HEXADECIMAL     reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    FLOAT           reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    DOUBLE          reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    STRING          reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    ID              reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    LPAREN          reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    IN              reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    OUT             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    VOID            reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    BOOL            reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    I8              reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    U8              reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    I16             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    U16             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    I32             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    U32             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    I64             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    U64             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    F16             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    F32             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    F64             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    INTERFACEID     reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    STRUCTID        reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    GENERICID       reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    TYPEALIASID     reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    LESS            reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    SEMICOLON       reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    RBRACE          reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    GENERICMARK     reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    LBRACKET        reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    DOT             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    ASSIGN          reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    MUL             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    DIV             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    AND             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    OR              reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    XOR             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    MOD             reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    LSHIFT          reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    RSHIFT          reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    LOGICAL_OR      reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    LOGICAL_AND     reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    NOT_EQUAL       reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    EQUAL           reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    LESS_EQUAL      reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    GREATER_EQUAL   reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    GREATER         reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    RPAREN          reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    COMMA           reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    RBRACKET        reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)
    ELSE            reduce using rule 94 (block_statement -> LBRACE statement_nest RBRACE .)


state 125

    (95) statement_nest -> statement statement_nest .

    RBRACE          reduce using rule 95 (statement_nest -> statement statement_nest .)


state 126

    (92) decl_statement -> variable_decl SEMICOLON .

    LBRACE          reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    IF              reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    BREAK           reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    CONTINUE        reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    RETURN          reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    LET             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    CONST           reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    WHILE           reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    FOR             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    NOT             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    LOGICAL_NOT     reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    PLUS            reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    MINUS           reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    INT             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    HEXADECIMAL     reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    FLOAT           reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    DOUBLE          reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    STRING          reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    ID              reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    LPAREN          reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    FUNC            reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    IN              reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    OUT             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    VOID            reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    BOOL            reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    I8              reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    U8              reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    I16             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    U16             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    I32             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    U32             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    I64             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    U64             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    F16             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    F32             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    F64             reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    INTERFACEID     reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    STRUCTID        reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    GENERICID       reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    TYPEALIASID     reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    LESS            reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    SEMICOLON       reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    RBRACE          reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)
    ELSE            reduce using rule 92 (decl_statement -> variable_decl SEMICOLON .)


state 127

    (93) decl_statement -> constant_decl SEMICOLON .

    LBRACE          reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    IF              reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    BREAK           reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    CONTINUE        reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    RETURN          reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    LET             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    CONST           reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    WHILE           reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    FOR             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    NOT             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    LOGICAL_NOT     reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    PLUS            reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    MINUS           reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    INT             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    HEXADECIMAL     reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    FLOAT           reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    DOUBLE          reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    STRING          reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    ID              reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    LPAREN          reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    FUNC            reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    IN              reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    OUT             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    VOID            reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    BOOL            reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    I8              reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    U8              reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    I16             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    U16             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    I32             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    U32             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    I64             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    U64             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    F16             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    F32             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    F64             reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    INTERFACEID     reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    STRUCTID        reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    GENERICID       reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    TYPEALIASID     reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    LESS            reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    SEMICOLON       reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    RBRACE          reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)
    ELSE            reduce using rule 93 (decl_statement -> constant_decl SEMICOLON .)


state 128

    (97) expression_statement -> expression_opt SEMICOLON .

    LBRACE          reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    IF              reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    BREAK           reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    CONTINUE        reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    RETURN          reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    LET             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    CONST           reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    WHILE           reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    FOR             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    NOT             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    LOGICAL_NOT     reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    PLUS            reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    MINUS           reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    INT             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    HEXADECIMAL     reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    FLOAT           reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    DOUBLE          reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    STRING          reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    ID              reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    LPAREN          reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    FUNC            reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    IN              reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    OUT             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    VOID            reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    BOOL            reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    I8              reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    U8              reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    I16             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    U16             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    I32             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    U32             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    I64             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    U64             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    F16             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    F32             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    F64             reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    INTERFACEID     reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    STRUCTID        reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    GENERICID       reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    TYPEALIASID     reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    LESS            reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    SEMICOLON       reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    RBRACE          reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)
    ELSE            reduce using rule 97 (expression_statement -> expression_opt SEMICOLON .)


state 129

    (100) if_statement -> IF LPAREN . expression RPAREN statement statement_else_opt
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 180
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 130

    (154) operand -> LPAREN expression . RPAREN
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    RPAREN          shift and go to state 181
    ASSIGN          shift and go to state 132
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_OR      shift and go to state 143
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150


state 131

    (157) cast_expr -> LPAREN type_spec . RPAREN expression
    (46) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> type_spec . REF
    (158) new_expr -> type_spec . LPAREN parameter_list_opt RPAREN

    RPAREN          shift and go to state 182
    LBRACKET        shift and go to state 165
    REF             shift and go to state 166
    LPAREN          shift and go to state 164


state 132

    (116) assign_expr -> expression ASSIGN . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 183
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 133

    (117) binary_expr -> expression PLUS . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 184
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 134

    (118) binary_expr -> expression MINUS . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 185
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 135

    (119) binary_expr -> expression MUL . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 186
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 136

    (120) binary_expr -> expression DIV . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 187
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 137

    (121) binary_expr -> expression AND . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 188
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 138

    (122) binary_expr -> expression OR . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 189
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 139

    (123) binary_expr -> expression XOR . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 190
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 140

    (124) binary_expr -> expression MOD . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 191
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 141

    (125) binary_expr -> expression LSHIFT . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 192
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 142

    (126) binary_expr -> expression RSHIFT . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 193
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 143

    (127) binary_expr -> expression LOGICAL_OR . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 194
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 144

    (128) binary_expr -> expression LOGICAL_AND . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 195
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 145

    (129) binary_expr -> expression NOT_EQUAL . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 196
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 146

    (130) binary_expr -> expression EQUAL . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 197
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 147

    (131) binary_expr -> expression LESS_EQUAL . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 198
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 148

    (132) binary_expr -> expression LESS . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 199
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 149

    (133) binary_expr -> expression GREATER_EQUAL . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 200
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 150

    (134) binary_expr -> expression GREATER . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 201
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 151

    (109) jump_statement -> BREAK SEMICOLON .

    LBRACE          reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    IF              reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    LET             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    CONST           reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    NOT             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    LOGICAL_NOT     reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    PLUS            reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    MINUS           reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    INT             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    HEXADECIMAL     reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    DOUBLE          reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    STRING          reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    ID              reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    FUNC            reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    IN              reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    OUT             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    VOID            reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    BOOL            reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    I8              reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    U8              reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    I16             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    U16             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    I32             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    U32             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    I64             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    U64             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    F16             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    F32             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    F64             reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    INTERFACEID     reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    STRUCTID        reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    GENERICID       reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    TYPEALIASID     reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    LESS            reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 109 (jump_statement -> BREAK SEMICOLON .)


state 152

    (110) jump_statement -> CONTINUE SEMICOLON .

    LBRACE          reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    IF              reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    LET             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    CONST           reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    NOT             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    LOGICAL_NOT     reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    PLUS            reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    MINUS           reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    INT             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    HEXADECIMAL     reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    DOUBLE          reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    ID              reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    FUNC            reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    IN              reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    OUT             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    BOOL            reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    I8              reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    U8              reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    I16             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    U16             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    I32             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    U32             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    I64             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    U64             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    F16             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    F32             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    F64             reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    INTERFACEID     reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    STRUCTID        reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    GENERICID       reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    TYPEALIASID     reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    LESS            reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 110 (jump_statement -> CONTINUE SEMICOLON .)


state 153

    (111) jump_statement -> RETURN expression_opt . SEMICOLON

    SEMICOLON       shift and go to state 202


state 154

    (99) expression_opt -> empty .
    (58) generics_type_list_opt -> empty .

    SEMICOLON       reduce using rule 99 (expression_opt -> empty .)
    LPAREN          reduce using rule 58 (generics_type_list_opt -> empty .)


state 155

    (105) while_clause -> WHILE LPAREN . expression RPAREN statement
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 203
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 156

    (106) for_clause -> FOR LPAREN . for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (107) for_init_statement -> . expression_statement
    (108) for_init_statement -> . decl_statement
    (97) expression_statement -> . expression_opt SEMICOLON
    (92) decl_statement -> . variable_decl SEMICOLON
    (93) decl_statement -> . constant_decl SEMICOLON
    (98) expression_opt -> . expression
    (99) expression_opt -> . empty
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (174) empty -> .
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    LET             shift and go to state 13
    CONST           shift and go to state 14
    SEMICOLON       reduce using rule 174 (empty -> .)
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    for_init_statement             shift and go to state 204
    expression_opt                 shift and go to state 45
    expression                     shift and go to state 48
    expression_statement           shift and go to state 205
    decl_statement                 shift and go to state 206
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    empty                          shift and go to state 154
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 157

    (161) call_expr -> primary_expr LPAREN . parameter_list_opt RPAREN
    (159) parameter_list_opt -> . parameter_list
    (160) parameter_list_opt -> . empty
    (167) parameter_list -> . expression expression_comma_nest
    (174) empty -> .
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          reduce using rule 174 (empty -> .)
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    primary_expr                   shift and go to state 59
    parameter_list_opt             shift and go to state 207
    parameter_list                 shift and go to state 208
    empty                          shift and go to state 209
    expression                     shift and go to state 210
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 158

    (162) call_expr -> primary_expr GENERICMARK . LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN

    LESS            shift and go to state 211


state 159

    (156) index_expr -> primary_expr LBRACKET . expression RBRACKET
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    primary_expr                   shift and go to state 59
    expression                     shift and go to state 212
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 160

    (155) member_expr -> primary_expr DOT . ID

    ID              shift and go to state 213


state 161

    (79) generics_type_list -> LESS generics_type . generics_type_comma_nest GREATER
    (80) generics_type_comma_nest -> . COMMA generics_type generics_type_comma_nest
    (81) generics_type_comma_nest -> . empty
    (174) empty -> .

    COMMA           shift and go to state 215
    GREATER         reduce using rule 174 (empty -> .)

    generics_type_comma_nest       shift and go to state 214
    empty                          shift and go to state 216

state 162

    (82) generics_type -> ID . generics_type_range_colon_opt
    (83) generics_type_range_colon_opt -> . COLON generics_type_range
    (84) generics_type_range_colon_opt -> . empty
    (174) empty -> .

    COLON           shift and go to state 218
    COMMA           reduce using rule 174 (empty -> .)
    GREATER         reduce using rule 174 (empty -> .)

    generics_type_range_colon_opt  shift and go to state 217
    empty                          shift and go to state 219

state 163

    (135) unary_expr -> unary_operation primary_expr .
    (161) call_expr -> primary_expr . LPAREN parameter_list_opt RPAREN
    (162) call_expr -> primary_expr . GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> primary_expr . LBRACKET expression RBRACKET
    (155) member_expr -> primary_expr . DOT ID

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for GENERICMARK resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
    ASSIGN          reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    PLUS            reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    MINUS           reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    MUL             reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    DIV             reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    AND             reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    OR              reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    XOR             reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    MOD             reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    LSHIFT          reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    RSHIFT          reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    LOGICAL_OR      reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    LOGICAL_AND     reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    NOT_EQUAL       reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    EQUAL           reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    LESS_EQUAL      reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    LESS            reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    GREATER_EQUAL   reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    GREATER         reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    SEMICOLON       reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    RPAREN          reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    COMMA           reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    RBRACKET        reduce using rule 135 (unary_expr -> unary_operation primary_expr .)
    LPAREN          shift and go to state 157
    GENERICMARK     shift and go to state 158
    LBRACKET        shift and go to state 159
    DOT             shift and go to state 160

  ! LPAREN          [ reduce using rule 135 (unary_expr -> unary_operation primary_expr .) ]
  ! GENERICMARK     [ reduce using rule 135 (unary_expr -> unary_operation primary_expr .) ]
  ! LBRACKET        [ reduce using rule 135 (unary_expr -> unary_operation primary_expr .) ]
  ! DOT             [ reduce using rule 135 (unary_expr -> unary_operation primary_expr .) ]


state 164

    (158) new_expr -> type_spec LPAREN . parameter_list_opt RPAREN
    (159) parameter_list_opt -> . parameter_list
    (160) parameter_list_opt -> . empty
    (167) parameter_list -> . expression expression_comma_nest
    (174) empty -> .
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          reduce using rule 174 (empty -> .)
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    type_spec                      shift and go to state 80
    parameter_list_opt             shift and go to state 220
    parameter_list                 shift and go to state 208
    empty                          shift and go to state 209
    expression                     shift and go to state 210
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 165

    (46) array_type -> type_spec LBRACKET . int_literal_opt RBRACKET
    (47) int_literal_opt -> . INT
    (48) int_literal_opt -> . empty
    (174) empty -> .

    INT             shift and go to state 222
    RBRACKET        reduce using rule 174 (empty -> .)

    int_literal_opt                shift and go to state 221
    empty                          shift and go to state 223

state 166

    (49) reference_type -> type_spec REF .

    LPAREN          reduce using rule 49 (reference_type -> type_spec REF .)
    LBRACKET        reduce using rule 49 (reference_type -> type_spec REF .)
    REF             reduce using rule 49 (reference_type -> type_spec REF .)
    RPAREN          reduce using rule 49 (reference_type -> type_spec REF .)
    ASSIGN          reduce using rule 49 (reference_type -> type_spec REF .)
    COMMA           reduce using rule 49 (reference_type -> type_spec REF .)
    SEMICOLON       reduce using rule 49 (reference_type -> type_spec REF .)
    GREATER         reduce using rule 49 (reference_type -> type_spec REF .)
    LESS            reduce using rule 49 (reference_type -> type_spec REF .)
    LBRACE          reduce using rule 49 (reference_type -> type_spec REF .)


state 167

    (170) lambda_expr -> FUNC function_sign . block_statement
    (94) block_statement -> . LBRACE statement_nest RBRACE

    LBRACE          shift and go to state 26

    block_statement                shift and go to state 224

state 168

    (171) io_expr -> in_out LESS . type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    type_spec                      shift and go to state 225
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    function_sign                  shift and go to state 82
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 169

    (42) complex_type -> INTERFACEID generics_specialization_list_opt .

    LPAREN          reduce using rule 42 (complex_type -> INTERFACEID generics_specialization_list_opt .)
    LBRACKET        reduce using rule 42 (complex_type -> INTERFACEID generics_specialization_list_opt .)
    REF             reduce using rule 42 (complex_type -> INTERFACEID generics_specialization_list_opt .)
    RPAREN          reduce using rule 42 (complex_type -> INTERFACEID generics_specialization_list_opt .)
    ASSIGN          reduce using rule 42 (complex_type -> INTERFACEID generics_specialization_list_opt .)
    COMMA           reduce using rule 42 (complex_type -> INTERFACEID generics_specialization_list_opt .)
    SEMICOLON       reduce using rule 42 (complex_type -> INTERFACEID generics_specialization_list_opt .)
    GREATER         reduce using rule 42 (complex_type -> INTERFACEID generics_specialization_list_opt .)
    LBRACE          reduce using rule 42 (complex_type -> INTERFACEID generics_specialization_list_opt .)
    LESS            reduce using rule 42 (complex_type -> INTERFACEID generics_specialization_list_opt .)


state 170

    (163) generics_specialization_list_opt -> LESS . type_spec type_spec_comma_nest GREATER
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    type_spec                      shift and go to state 226
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    function_sign                  shift and go to state 82
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 171

    (164) generics_specialization_list_opt -> empty .

    LPAREN          reduce using rule 164 (generics_specialization_list_opt -> empty .)
    LBRACKET        reduce using rule 164 (generics_specialization_list_opt -> empty .)
    REF             reduce using rule 164 (generics_specialization_list_opt -> empty .)
    RPAREN          reduce using rule 164 (generics_specialization_list_opt -> empty .)
    ASSIGN          reduce using rule 164 (generics_specialization_list_opt -> empty .)
    COMMA           reduce using rule 164 (generics_specialization_list_opt -> empty .)
    SEMICOLON       reduce using rule 164 (generics_specialization_list_opt -> empty .)
    GREATER         reduce using rule 164 (generics_specialization_list_opt -> empty .)
    LBRACE          reduce using rule 164 (generics_specialization_list_opt -> empty .)
    LESS            reduce using rule 164 (generics_specialization_list_opt -> empty .)


state 172

    (43) complex_type -> STRUCTID generics_specialization_list_opt .

    LPAREN          reduce using rule 43 (complex_type -> STRUCTID generics_specialization_list_opt .)
    LBRACKET        reduce using rule 43 (complex_type -> STRUCTID generics_specialization_list_opt .)
    REF             reduce using rule 43 (complex_type -> STRUCTID generics_specialization_list_opt .)
    RPAREN          reduce using rule 43 (complex_type -> STRUCTID generics_specialization_list_opt .)
    ASSIGN          reduce using rule 43 (complex_type -> STRUCTID generics_specialization_list_opt .)
    COMMA           reduce using rule 43 (complex_type -> STRUCTID generics_specialization_list_opt .)
    SEMICOLON       reduce using rule 43 (complex_type -> STRUCTID generics_specialization_list_opt .)
    GREATER         reduce using rule 43 (complex_type -> STRUCTID generics_specialization_list_opt .)
    LBRACE          reduce using rule 43 (complex_type -> STRUCTID generics_specialization_list_opt .)
    LESS            reduce using rule 43 (complex_type -> STRUCTID generics_specialization_list_opt .)


state 173

    (71) function_sign -> generics_type_list_opt LPAREN . parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (72) parameter_decl_list_opt -> . parameter_decl parameter_decl_comma_nest
    (73) parameter_decl_list_opt -> . empty
    (78) parameter_decl -> . ID type_spec_colon_opt
    (174) empty -> .

    ID              shift and go to state 230
    RPAREN          reduce using rule 174 (empty -> .)

    parameter_decl_list_opt        shift and go to state 227
    parameter_decl                 shift and go to state 228
    empty                          shift and go to state 229

state 174

    (14) declarator_nest -> COMMA declarator . declarator_nest
    (14) declarator_nest -> . COMMA declarator declarator_nest
    (15) declarator_nest -> . empty
    (174) empty -> .

    COMMA           shift and go to state 113
    SEMICOLON       reduce using rule 174 (empty -> .)

    declarator_nest                shift and go to state 231
    empty                          shift and go to state 114

state 175

    (17) declarator -> ID type_spec_colon_opt ASSIGN . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 232
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 176

    (18) type_spec_colon_opt -> COLON type_spec .
    (46) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> type_spec . REF

    ASSIGN          reduce using rule 18 (type_spec_colon_opt -> COLON type_spec .)
    COMMA           reduce using rule 18 (type_spec_colon_opt -> COLON type_spec .)
    RPAREN          reduce using rule 18 (type_spec_colon_opt -> COLON type_spec .)
    LBRACKET        shift and go to state 165
    REF             shift and go to state 166


state 177

    (12) type_alias_decl -> TYPE ID ASSIGN type_spec .
    (46) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> type_spec . REF

    SEMICOLON       reduce using rule 12 (type_alias_decl -> TYPE ID ASSIGN type_spec .)
    LBRACKET        shift and go to state 165
    REF             shift and go to state 166


state 178

    (51) struct_decl -> STRUCT ID new_struct generics_type_list_opt . complex_type_colon_opt LBRACE member_decl_nest RBRACE
    (53) complex_type_colon_opt -> . COLON complex_type
    (54) complex_type_colon_opt -> . empty
    (174) empty -> .

    COLON           shift and go to state 234
    LBRACE          reduce using rule 174 (empty -> .)

    complex_type_colon_opt         shift and go to state 233
    empty                          shift and go to state 235

state 179

    (55) interface_decl -> INTERFACE ID new_interface generics_type_list_opt . LBRACE interface_member_decl_nest RBRACE

    LBRACE          shift and go to state 236


state 180

    (100) if_statement -> IF LPAREN expression . RPAREN statement statement_else_opt
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    RPAREN          shift and go to state 237
    ASSIGN          shift and go to state 132
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_OR      shift and go to state 143
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150


state 181

    (154) operand -> LPAREN expression RPAREN .

    LPAREN          reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    GENERICMARK     reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    DOT             reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    ASSIGN          reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    MUL             reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    DIV             reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    AND             reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    OR              reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    XOR             reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    MOD             reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    LOGICAL_OR      reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    LOGICAL_AND     reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    LESS_EQUAL      reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    LESS            reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    GREATER_EQUAL   reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 154 (operand -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 154 (operand -> LPAREN expression RPAREN .)


state 182

    (157) cast_expr -> LPAREN type_spec RPAREN . expression
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    type_spec                      shift and go to state 80
    expression                     shift and go to state 238
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 183

    (116) assign_expr -> expression ASSIGN expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
    SEMICOLON       reduce using rule 116 (assign_expr -> expression ASSIGN expression .)
    RPAREN          reduce using rule 116 (assign_expr -> expression ASSIGN expression .)
    LPAREN          reduce using rule 116 (assign_expr -> expression ASSIGN expression .)
    GENERICMARK     reduce using rule 116 (assign_expr -> expression ASSIGN expression .)
    LBRACKET        reduce using rule 116 (assign_expr -> expression ASSIGN expression .)
    DOT             reduce using rule 116 (assign_expr -> expression ASSIGN expression .)
    COMMA           reduce using rule 116 (assign_expr -> expression ASSIGN expression .)
    RBRACKET        reduce using rule 116 (assign_expr -> expression ASSIGN expression .)
    ASSIGN          shift and go to state 132
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_OR      shift and go to state 143
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150

  ! ASSIGN          [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! MUL             [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! DIV             [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! AND             [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! OR              [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! XOR             [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! MOD             [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! LSHIFT          [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! RSHIFT          [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! LOGICAL_OR      [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! LOGICAL_AND     [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! NOT_EQUAL       [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! EQUAL           [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! LESS_EQUAL      [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! LESS            [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]
  ! GREATER         [ reduce using rule 116 (assign_expr -> expression ASSIGN expression .) ]


state 184

    (117) binary_expr -> expression PLUS expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 117 (binary_expr -> expression PLUS expression .)
    PLUS            reduce using rule 117 (binary_expr -> expression PLUS expression .)
    MINUS           reduce using rule 117 (binary_expr -> expression PLUS expression .)
    AND             reduce using rule 117 (binary_expr -> expression PLUS expression .)
    OR              reduce using rule 117 (binary_expr -> expression PLUS expression .)
    XOR             reduce using rule 117 (binary_expr -> expression PLUS expression .)
    LSHIFT          reduce using rule 117 (binary_expr -> expression PLUS expression .)
    RSHIFT          reduce using rule 117 (binary_expr -> expression PLUS expression .)
    LOGICAL_OR      reduce using rule 117 (binary_expr -> expression PLUS expression .)
    LOGICAL_AND     reduce using rule 117 (binary_expr -> expression PLUS expression .)
    NOT_EQUAL       reduce using rule 117 (binary_expr -> expression PLUS expression .)
    EQUAL           reduce using rule 117 (binary_expr -> expression PLUS expression .)
    LESS_EQUAL      reduce using rule 117 (binary_expr -> expression PLUS expression .)
    LESS            reduce using rule 117 (binary_expr -> expression PLUS expression .)
    GREATER_EQUAL   reduce using rule 117 (binary_expr -> expression PLUS expression .)
    GREATER         reduce using rule 117 (binary_expr -> expression PLUS expression .)
    SEMICOLON       reduce using rule 117 (binary_expr -> expression PLUS expression .)
    RPAREN          reduce using rule 117 (binary_expr -> expression PLUS expression .)
    LPAREN          reduce using rule 117 (binary_expr -> expression PLUS expression .)
    GENERICMARK     reduce using rule 117 (binary_expr -> expression PLUS expression .)
    LBRACKET        reduce using rule 117 (binary_expr -> expression PLUS expression .)
    DOT             reduce using rule 117 (binary_expr -> expression PLUS expression .)
    COMMA           reduce using rule 117 (binary_expr -> expression PLUS expression .)
    RBRACKET        reduce using rule 117 (binary_expr -> expression PLUS expression .)
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    MOD             shift and go to state 140

  ! MUL             [ reduce using rule 117 (binary_expr -> expression PLUS expression .) ]
  ! DIV             [ reduce using rule 117 (binary_expr -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 117 (binary_expr -> expression PLUS expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! PLUS            [ shift and go to state 133 ]
  ! MINUS           [ shift and go to state 134 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LSHIFT          [ shift and go to state 141 ]
  ! RSHIFT          [ shift and go to state 142 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]
  ! LESS_EQUAL      [ shift and go to state 147 ]
  ! LESS            [ shift and go to state 148 ]
  ! GREATER_EQUAL   [ shift and go to state 149 ]
  ! GREATER         [ shift and go to state 150 ]


state 185

    (118) binary_expr -> expression MINUS expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 118 (binary_expr -> expression MINUS expression .)
    PLUS            reduce using rule 118 (binary_expr -> expression MINUS expression .)
    MINUS           reduce using rule 118 (binary_expr -> expression MINUS expression .)
    AND             reduce using rule 118 (binary_expr -> expression MINUS expression .)
    OR              reduce using rule 118 (binary_expr -> expression MINUS expression .)
    XOR             reduce using rule 118 (binary_expr -> expression MINUS expression .)
    LSHIFT          reduce using rule 118 (binary_expr -> expression MINUS expression .)
    RSHIFT          reduce using rule 118 (binary_expr -> expression MINUS expression .)
    LOGICAL_OR      reduce using rule 118 (binary_expr -> expression MINUS expression .)
    LOGICAL_AND     reduce using rule 118 (binary_expr -> expression MINUS expression .)
    NOT_EQUAL       reduce using rule 118 (binary_expr -> expression MINUS expression .)
    EQUAL           reduce using rule 118 (binary_expr -> expression MINUS expression .)
    LESS_EQUAL      reduce using rule 118 (binary_expr -> expression MINUS expression .)
    LESS            reduce using rule 118 (binary_expr -> expression MINUS expression .)
    GREATER_EQUAL   reduce using rule 118 (binary_expr -> expression MINUS expression .)
    GREATER         reduce using rule 118 (binary_expr -> expression MINUS expression .)
    SEMICOLON       reduce using rule 118 (binary_expr -> expression MINUS expression .)
    RPAREN          reduce using rule 118 (binary_expr -> expression MINUS expression .)
    LPAREN          reduce using rule 118 (binary_expr -> expression MINUS expression .)
    GENERICMARK     reduce using rule 118 (binary_expr -> expression MINUS expression .)
    LBRACKET        reduce using rule 118 (binary_expr -> expression MINUS expression .)
    DOT             reduce using rule 118 (binary_expr -> expression MINUS expression .)
    COMMA           reduce using rule 118 (binary_expr -> expression MINUS expression .)
    RBRACKET        reduce using rule 118 (binary_expr -> expression MINUS expression .)
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    MOD             shift and go to state 140

  ! MUL             [ reduce using rule 118 (binary_expr -> expression MINUS expression .) ]
  ! DIV             [ reduce using rule 118 (binary_expr -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 118 (binary_expr -> expression MINUS expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! PLUS            [ shift and go to state 133 ]
  ! MINUS           [ shift and go to state 134 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LSHIFT          [ shift and go to state 141 ]
  ! RSHIFT          [ shift and go to state 142 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]
  ! LESS_EQUAL      [ shift and go to state 147 ]
  ! LESS            [ shift and go to state 148 ]
  ! GREATER_EQUAL   [ shift and go to state 149 ]
  ! GREATER         [ shift and go to state 150 ]


state 186

    (119) binary_expr -> expression MUL expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 119 (binary_expr -> expression MUL expression .)
    PLUS            reduce using rule 119 (binary_expr -> expression MUL expression .)
    MINUS           reduce using rule 119 (binary_expr -> expression MUL expression .)
    MUL             reduce using rule 119 (binary_expr -> expression MUL expression .)
    DIV             reduce using rule 119 (binary_expr -> expression MUL expression .)
    AND             reduce using rule 119 (binary_expr -> expression MUL expression .)
    OR              reduce using rule 119 (binary_expr -> expression MUL expression .)
    XOR             reduce using rule 119 (binary_expr -> expression MUL expression .)
    MOD             reduce using rule 119 (binary_expr -> expression MUL expression .)
    LSHIFT          reduce using rule 119 (binary_expr -> expression MUL expression .)
    RSHIFT          reduce using rule 119 (binary_expr -> expression MUL expression .)
    LOGICAL_OR      reduce using rule 119 (binary_expr -> expression MUL expression .)
    LOGICAL_AND     reduce using rule 119 (binary_expr -> expression MUL expression .)
    NOT_EQUAL       reduce using rule 119 (binary_expr -> expression MUL expression .)
    EQUAL           reduce using rule 119 (binary_expr -> expression MUL expression .)
    LESS_EQUAL      reduce using rule 119 (binary_expr -> expression MUL expression .)
    LESS            reduce using rule 119 (binary_expr -> expression MUL expression .)
    GREATER_EQUAL   reduce using rule 119 (binary_expr -> expression MUL expression .)
    GREATER         reduce using rule 119 (binary_expr -> expression MUL expression .)
    SEMICOLON       reduce using rule 119 (binary_expr -> expression MUL expression .)
    RPAREN          reduce using rule 119 (binary_expr -> expression MUL expression .)
    LPAREN          reduce using rule 119 (binary_expr -> expression MUL expression .)
    GENERICMARK     reduce using rule 119 (binary_expr -> expression MUL expression .)
    LBRACKET        reduce using rule 119 (binary_expr -> expression MUL expression .)
    DOT             reduce using rule 119 (binary_expr -> expression MUL expression .)
    COMMA           reduce using rule 119 (binary_expr -> expression MUL expression .)
    RBRACKET        reduce using rule 119 (binary_expr -> expression MUL expression .)

  ! ASSIGN          [ shift and go to state 132 ]
  ! PLUS            [ shift and go to state 133 ]
  ! MINUS           [ shift and go to state 134 ]
  ! MUL             [ shift and go to state 135 ]
  ! DIV             [ shift and go to state 136 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! MOD             [ shift and go to state 140 ]
  ! LSHIFT          [ shift and go to state 141 ]
  ! RSHIFT          [ shift and go to state 142 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]
  ! LESS_EQUAL      [ shift and go to state 147 ]
  ! LESS            [ shift and go to state 148 ]
  ! GREATER_EQUAL   [ shift and go to state 149 ]
  ! GREATER         [ shift and go to state 150 ]


state 187

    (120) binary_expr -> expression DIV expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 120 (binary_expr -> expression DIV expression .)
    PLUS            reduce using rule 120 (binary_expr -> expression DIV expression .)
    MINUS           reduce using rule 120 (binary_expr -> expression DIV expression .)
    MUL             reduce using rule 120 (binary_expr -> expression DIV expression .)
    DIV             reduce using rule 120 (binary_expr -> expression DIV expression .)
    AND             reduce using rule 120 (binary_expr -> expression DIV expression .)
    OR              reduce using rule 120 (binary_expr -> expression DIV expression .)
    XOR             reduce using rule 120 (binary_expr -> expression DIV expression .)
    MOD             reduce using rule 120 (binary_expr -> expression DIV expression .)
    LSHIFT          reduce using rule 120 (binary_expr -> expression DIV expression .)
    RSHIFT          reduce using rule 120 (binary_expr -> expression DIV expression .)
    LOGICAL_OR      reduce using rule 120 (binary_expr -> expression DIV expression .)
    LOGICAL_AND     reduce using rule 120 (binary_expr -> expression DIV expression .)
    NOT_EQUAL       reduce using rule 120 (binary_expr -> expression DIV expression .)
    EQUAL           reduce using rule 120 (binary_expr -> expression DIV expression .)
    LESS_EQUAL      reduce using rule 120 (binary_expr -> expression DIV expression .)
    LESS            reduce using rule 120 (binary_expr -> expression DIV expression .)
    GREATER_EQUAL   reduce using rule 120 (binary_expr -> expression DIV expression .)
    GREATER         reduce using rule 120 (binary_expr -> expression DIV expression .)
    SEMICOLON       reduce using rule 120 (binary_expr -> expression DIV expression .)
    RPAREN          reduce using rule 120 (binary_expr -> expression DIV expression .)
    LPAREN          reduce using rule 120 (binary_expr -> expression DIV expression .)
    GENERICMARK     reduce using rule 120 (binary_expr -> expression DIV expression .)
    LBRACKET        reduce using rule 120 (binary_expr -> expression DIV expression .)
    DOT             reduce using rule 120 (binary_expr -> expression DIV expression .)
    COMMA           reduce using rule 120 (binary_expr -> expression DIV expression .)
    RBRACKET        reduce using rule 120 (binary_expr -> expression DIV expression .)

  ! ASSIGN          [ shift and go to state 132 ]
  ! PLUS            [ shift and go to state 133 ]
  ! MINUS           [ shift and go to state 134 ]
  ! MUL             [ shift and go to state 135 ]
  ! DIV             [ shift and go to state 136 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! MOD             [ shift and go to state 140 ]
  ! LSHIFT          [ shift and go to state 141 ]
  ! RSHIFT          [ shift and go to state 142 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]
  ! LESS_EQUAL      [ shift and go to state 147 ]
  ! LESS            [ shift and go to state 148 ]
  ! GREATER_EQUAL   [ shift and go to state 149 ]
  ! GREATER         [ shift and go to state 150 ]


state 188

    (121) binary_expr -> expression AND expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 121 (binary_expr -> expression AND expression .)
    AND             reduce using rule 121 (binary_expr -> expression AND expression .)
    OR              reduce using rule 121 (binary_expr -> expression AND expression .)
    XOR             reduce using rule 121 (binary_expr -> expression AND expression .)
    LOGICAL_OR      reduce using rule 121 (binary_expr -> expression AND expression .)
    LOGICAL_AND     reduce using rule 121 (binary_expr -> expression AND expression .)
    SEMICOLON       reduce using rule 121 (binary_expr -> expression AND expression .)
    RPAREN          reduce using rule 121 (binary_expr -> expression AND expression .)
    LPAREN          reduce using rule 121 (binary_expr -> expression AND expression .)
    GENERICMARK     reduce using rule 121 (binary_expr -> expression AND expression .)
    LBRACKET        reduce using rule 121 (binary_expr -> expression AND expression .)
    DOT             reduce using rule 121 (binary_expr -> expression AND expression .)
    COMMA           reduce using rule 121 (binary_expr -> expression AND expression .)
    RBRACKET        reduce using rule 121 (binary_expr -> expression AND expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150

  ! PLUS            [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! MUL             [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! DIV             [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! MOD             [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! LSHIFT          [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! RSHIFT          [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! NOT_EQUAL       [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! EQUAL           [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! LESS_EQUAL      [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! LESS            [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! GREATER         [ reduce using rule 121 (binary_expr -> expression AND expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]


state 189

    (122) binary_expr -> expression OR expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 122 (binary_expr -> expression OR expression .)
    OR              reduce using rule 122 (binary_expr -> expression OR expression .)
    LOGICAL_OR      reduce using rule 122 (binary_expr -> expression OR expression .)
    LOGICAL_AND     reduce using rule 122 (binary_expr -> expression OR expression .)
    SEMICOLON       reduce using rule 122 (binary_expr -> expression OR expression .)
    RPAREN          reduce using rule 122 (binary_expr -> expression OR expression .)
    LPAREN          reduce using rule 122 (binary_expr -> expression OR expression .)
    GENERICMARK     reduce using rule 122 (binary_expr -> expression OR expression .)
    LBRACKET        reduce using rule 122 (binary_expr -> expression OR expression .)
    DOT             reduce using rule 122 (binary_expr -> expression OR expression .)
    COMMA           reduce using rule 122 (binary_expr -> expression OR expression .)
    RBRACKET        reduce using rule 122 (binary_expr -> expression OR expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150

  ! PLUS            [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! MUL             [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! DIV             [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! AND             [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! XOR             [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! MOD             [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! LSHIFT          [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! RSHIFT          [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! NOT_EQUAL       [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! EQUAL           [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! LESS_EQUAL      [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! LESS            [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! GREATER         [ reduce using rule 122 (binary_expr -> expression OR expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! OR              [ shift and go to state 138 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]


state 190

    (123) binary_expr -> expression XOR expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 123 (binary_expr -> expression XOR expression .)
    OR              reduce using rule 123 (binary_expr -> expression XOR expression .)
    XOR             reduce using rule 123 (binary_expr -> expression XOR expression .)
    LOGICAL_OR      reduce using rule 123 (binary_expr -> expression XOR expression .)
    LOGICAL_AND     reduce using rule 123 (binary_expr -> expression XOR expression .)
    SEMICOLON       reduce using rule 123 (binary_expr -> expression XOR expression .)
    RPAREN          reduce using rule 123 (binary_expr -> expression XOR expression .)
    LPAREN          reduce using rule 123 (binary_expr -> expression XOR expression .)
    GENERICMARK     reduce using rule 123 (binary_expr -> expression XOR expression .)
    LBRACKET        reduce using rule 123 (binary_expr -> expression XOR expression .)
    DOT             reduce using rule 123 (binary_expr -> expression XOR expression .)
    COMMA           reduce using rule 123 (binary_expr -> expression XOR expression .)
    RBRACKET        reduce using rule 123 (binary_expr -> expression XOR expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150

  ! PLUS            [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! MINUS           [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! MUL             [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! DIV             [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! AND             [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! MOD             [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! LSHIFT          [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! RSHIFT          [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! NOT_EQUAL       [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! EQUAL           [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! LESS_EQUAL      [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! LESS            [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! GREATER         [ reduce using rule 123 (binary_expr -> expression XOR expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]


state 191

    (124) binary_expr -> expression MOD expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 124 (binary_expr -> expression MOD expression .)
    PLUS            reduce using rule 124 (binary_expr -> expression MOD expression .)
    MINUS           reduce using rule 124 (binary_expr -> expression MOD expression .)
    MUL             reduce using rule 124 (binary_expr -> expression MOD expression .)
    DIV             reduce using rule 124 (binary_expr -> expression MOD expression .)
    AND             reduce using rule 124 (binary_expr -> expression MOD expression .)
    OR              reduce using rule 124 (binary_expr -> expression MOD expression .)
    XOR             reduce using rule 124 (binary_expr -> expression MOD expression .)
    MOD             reduce using rule 124 (binary_expr -> expression MOD expression .)
    LSHIFT          reduce using rule 124 (binary_expr -> expression MOD expression .)
    RSHIFT          reduce using rule 124 (binary_expr -> expression MOD expression .)
    LOGICAL_OR      reduce using rule 124 (binary_expr -> expression MOD expression .)
    LOGICAL_AND     reduce using rule 124 (binary_expr -> expression MOD expression .)
    NOT_EQUAL       reduce using rule 124 (binary_expr -> expression MOD expression .)
    EQUAL           reduce using rule 124 (binary_expr -> expression MOD expression .)
    LESS_EQUAL      reduce using rule 124 (binary_expr -> expression MOD expression .)
    LESS            reduce using rule 124 (binary_expr -> expression MOD expression .)
    GREATER_EQUAL   reduce using rule 124 (binary_expr -> expression MOD expression .)
    GREATER         reduce using rule 124 (binary_expr -> expression MOD expression .)
    SEMICOLON       reduce using rule 124 (binary_expr -> expression MOD expression .)
    RPAREN          reduce using rule 124 (binary_expr -> expression MOD expression .)
    LPAREN          reduce using rule 124 (binary_expr -> expression MOD expression .)
    GENERICMARK     reduce using rule 124 (binary_expr -> expression MOD expression .)
    LBRACKET        reduce using rule 124 (binary_expr -> expression MOD expression .)
    DOT             reduce using rule 124 (binary_expr -> expression MOD expression .)
    COMMA           reduce using rule 124 (binary_expr -> expression MOD expression .)
    RBRACKET        reduce using rule 124 (binary_expr -> expression MOD expression .)

  ! ASSIGN          [ shift and go to state 132 ]
  ! PLUS            [ shift and go to state 133 ]
  ! MINUS           [ shift and go to state 134 ]
  ! MUL             [ shift and go to state 135 ]
  ! DIV             [ shift and go to state 136 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! MOD             [ shift and go to state 140 ]
  ! LSHIFT          [ shift and go to state 141 ]
  ! RSHIFT          [ shift and go to state 142 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]
  ! LESS_EQUAL      [ shift and go to state 147 ]
  ! LESS            [ shift and go to state 148 ]
  ! GREATER_EQUAL   [ shift and go to state 149 ]
  ! GREATER         [ shift and go to state 150 ]


state 192

    (125) binary_expr -> expression LSHIFT expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    AND             reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    OR              reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    XOR             reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    LSHIFT          reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    RSHIFT          reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    LOGICAL_OR      reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    LOGICAL_AND     reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    NOT_EQUAL       reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    EQUAL           reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    LESS_EQUAL      reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    LESS            reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    GREATER_EQUAL   reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    GREATER         reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    SEMICOLON       reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    RPAREN          reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    LPAREN          reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    GENERICMARK     reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    LBRACKET        reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    DOT             reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    COMMA           reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    RBRACKET        reduce using rule 125 (binary_expr -> expression LSHIFT expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    MOD             shift and go to state 140

  ! PLUS            [ reduce using rule 125 (binary_expr -> expression LSHIFT expression .) ]
  ! MINUS           [ reduce using rule 125 (binary_expr -> expression LSHIFT expression .) ]
  ! MUL             [ reduce using rule 125 (binary_expr -> expression LSHIFT expression .) ]
  ! DIV             [ reduce using rule 125 (binary_expr -> expression LSHIFT expression .) ]
  ! MOD             [ reduce using rule 125 (binary_expr -> expression LSHIFT expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LSHIFT          [ shift and go to state 141 ]
  ! RSHIFT          [ shift and go to state 142 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]
  ! LESS_EQUAL      [ shift and go to state 147 ]
  ! LESS            [ shift and go to state 148 ]
  ! GREATER_EQUAL   [ shift and go to state 149 ]
  ! GREATER         [ shift and go to state 150 ]


state 193

    (126) binary_expr -> expression RSHIFT expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    AND             reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    OR              reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    XOR             reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    LSHIFT          reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    RSHIFT          reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    LOGICAL_OR      reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    LOGICAL_AND     reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    NOT_EQUAL       reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    EQUAL           reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    LESS_EQUAL      reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    LESS            reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    GREATER_EQUAL   reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    GREATER         reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    SEMICOLON       reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    RPAREN          reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    LPAREN          reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    GENERICMARK     reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    LBRACKET        reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    DOT             reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    COMMA           reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    RBRACKET        reduce using rule 126 (binary_expr -> expression RSHIFT expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    MOD             shift and go to state 140

  ! PLUS            [ reduce using rule 126 (binary_expr -> expression RSHIFT expression .) ]
  ! MINUS           [ reduce using rule 126 (binary_expr -> expression RSHIFT expression .) ]
  ! MUL             [ reduce using rule 126 (binary_expr -> expression RSHIFT expression .) ]
  ! DIV             [ reduce using rule 126 (binary_expr -> expression RSHIFT expression .) ]
  ! MOD             [ reduce using rule 126 (binary_expr -> expression RSHIFT expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LSHIFT          [ shift and go to state 141 ]
  ! RSHIFT          [ shift and go to state 142 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]
  ! LESS_EQUAL      [ shift and go to state 147 ]
  ! LESS            [ shift and go to state 148 ]
  ! GREATER_EQUAL   [ shift and go to state 149 ]
  ! GREATER         [ shift and go to state 150 ]


state 194

    (127) binary_expr -> expression LOGICAL_OR expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .)
    LOGICAL_OR      reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .)
    SEMICOLON       reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .)
    RPAREN          reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .)
    LPAREN          reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .)
    GENERICMARK     reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .)
    LBRACKET        reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .)
    DOT             reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .)
    COMMA           reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .)
    RBRACKET        reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150

  ! PLUS            [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! MINUS           [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! MUL             [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! DIV             [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! AND             [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! OR              [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! XOR             [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! MOD             [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! LSHIFT          [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! RSHIFT          [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! LOGICAL_AND     [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! NOT_EQUAL       [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! EQUAL           [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! LESS_EQUAL      [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! LESS            [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! GREATER         [ reduce using rule 127 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]


state 195

    (128) binary_expr -> expression LOGICAL_AND expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .)
    LOGICAL_OR      reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .)
    LOGICAL_AND     reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .)
    SEMICOLON       reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .)
    RPAREN          reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .)
    LPAREN          reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .)
    GENERICMARK     reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .)
    LBRACKET        reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .)
    DOT             reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .)
    COMMA           reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .)
    RBRACKET        reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150

  ! PLUS            [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! MINUS           [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! MUL             [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! DIV             [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! AND             [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! OR              [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! XOR             [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! MOD             [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! LSHIFT          [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! RSHIFT          [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! NOT_EQUAL       [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! EQUAL           [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! LESS_EQUAL      [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! LESS            [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! GREATER         [ reduce using rule 128 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]


state 196

    (129) binary_expr -> expression NOT_EQUAL expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    AND             reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    OR              reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    XOR             reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    LOGICAL_OR      reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    LOGICAL_AND     reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    NOT_EQUAL       reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    EQUAL           reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    SEMICOLON       reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    RPAREN          reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    LPAREN          reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    GENERICMARK     reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    LBRACKET        reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    DOT             reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    COMMA           reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    RBRACKET        reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150

  ! PLUS            [ reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! MUL             [ reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! DIV             [ reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! MOD             [ reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! LSHIFT          [ reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! RSHIFT          [ reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! LESS            [ reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 129 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]


state 197

    (130) binary_expr -> expression EQUAL expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    AND             reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    OR              reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    XOR             reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    LOGICAL_OR      reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    LOGICAL_AND     reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    NOT_EQUAL       reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    EQUAL           reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    SEMICOLON       reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    RPAREN          reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    LPAREN          reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    GENERICMARK     reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    LBRACKET        reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    DOT             reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    COMMA           reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    RBRACKET        reduce using rule 130 (binary_expr -> expression EQUAL expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150

  ! PLUS            [ reduce using rule 130 (binary_expr -> expression EQUAL expression .) ]
  ! MINUS           [ reduce using rule 130 (binary_expr -> expression EQUAL expression .) ]
  ! MUL             [ reduce using rule 130 (binary_expr -> expression EQUAL expression .) ]
  ! DIV             [ reduce using rule 130 (binary_expr -> expression EQUAL expression .) ]
  ! MOD             [ reduce using rule 130 (binary_expr -> expression EQUAL expression .) ]
  ! LSHIFT          [ reduce using rule 130 (binary_expr -> expression EQUAL expression .) ]
  ! RSHIFT          [ reduce using rule 130 (binary_expr -> expression EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 130 (binary_expr -> expression EQUAL expression .) ]
  ! LESS            [ reduce using rule 130 (binary_expr -> expression EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 130 (binary_expr -> expression EQUAL expression .) ]
  ! GREATER         [ reduce using rule 130 (binary_expr -> expression EQUAL expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]


state 198

    (131) binary_expr -> expression LESS_EQUAL expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    AND             reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    OR              reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    XOR             reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    LOGICAL_OR      reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    LOGICAL_AND     reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    NOT_EQUAL       reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    EQUAL           reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    LESS_EQUAL      reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    LESS            reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    GREATER_EQUAL   reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    GREATER         reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    SEMICOLON       reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    RPAREN          reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    LPAREN          reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    GENERICMARK     reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    LBRACKET        reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    DOT             reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    COMMA           reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    RBRACKET        reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142

  ! PLUS            [ reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! MUL             [ reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! DIV             [ reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! MOD             [ reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! LSHIFT          [ reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! RSHIFT          [ reduce using rule 131 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]
  ! LESS_EQUAL      [ shift and go to state 147 ]
  ! LESS            [ shift and go to state 148 ]
  ! GREATER_EQUAL   [ shift and go to state 149 ]
  ! GREATER         [ shift and go to state 150 ]


state 199

    (132) binary_expr -> expression LESS expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 132 (binary_expr -> expression LESS expression .)
    AND             reduce using rule 132 (binary_expr -> expression LESS expression .)
    OR              reduce using rule 132 (binary_expr -> expression LESS expression .)
    XOR             reduce using rule 132 (binary_expr -> expression LESS expression .)
    LOGICAL_OR      reduce using rule 132 (binary_expr -> expression LESS expression .)
    LOGICAL_AND     reduce using rule 132 (binary_expr -> expression LESS expression .)
    NOT_EQUAL       reduce using rule 132 (binary_expr -> expression LESS expression .)
    EQUAL           reduce using rule 132 (binary_expr -> expression LESS expression .)
    LESS_EQUAL      reduce using rule 132 (binary_expr -> expression LESS expression .)
    LESS            reduce using rule 132 (binary_expr -> expression LESS expression .)
    GREATER_EQUAL   reduce using rule 132 (binary_expr -> expression LESS expression .)
    GREATER         reduce using rule 132 (binary_expr -> expression LESS expression .)
    SEMICOLON       reduce using rule 132 (binary_expr -> expression LESS expression .)
    RPAREN          reduce using rule 132 (binary_expr -> expression LESS expression .)
    LPAREN          reduce using rule 132 (binary_expr -> expression LESS expression .)
    GENERICMARK     reduce using rule 132 (binary_expr -> expression LESS expression .)
    LBRACKET        reduce using rule 132 (binary_expr -> expression LESS expression .)
    DOT             reduce using rule 132 (binary_expr -> expression LESS expression .)
    COMMA           reduce using rule 132 (binary_expr -> expression LESS expression .)
    RBRACKET        reduce using rule 132 (binary_expr -> expression LESS expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142

  ! PLUS            [ reduce using rule 132 (binary_expr -> expression LESS expression .) ]
  ! MINUS           [ reduce using rule 132 (binary_expr -> expression LESS expression .) ]
  ! MUL             [ reduce using rule 132 (binary_expr -> expression LESS expression .) ]
  ! DIV             [ reduce using rule 132 (binary_expr -> expression LESS expression .) ]
  ! MOD             [ reduce using rule 132 (binary_expr -> expression LESS expression .) ]
  ! LSHIFT          [ reduce using rule 132 (binary_expr -> expression LESS expression .) ]
  ! RSHIFT          [ reduce using rule 132 (binary_expr -> expression LESS expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]
  ! LESS_EQUAL      [ shift and go to state 147 ]
  ! LESS            [ shift and go to state 148 ]
  ! GREATER_EQUAL   [ shift and go to state 149 ]
  ! GREATER         [ shift and go to state 150 ]


state 200

    (133) binary_expr -> expression GREATER_EQUAL expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    AND             reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    OR              reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    XOR             reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    LOGICAL_OR      reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    LOGICAL_AND     reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    NOT_EQUAL       reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    EQUAL           reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    LESS_EQUAL      reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    LESS            reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    GREATER_EQUAL   reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    GREATER         reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    SEMICOLON       reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    RPAREN          reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    LPAREN          reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    GENERICMARK     reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    LBRACKET        reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    DOT             reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    COMMA           reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    RBRACKET        reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142

  ! PLUS            [ reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! MUL             [ reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! DIV             [ reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! MOD             [ reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! LSHIFT          [ reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! RSHIFT          [ reduce using rule 133 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]
  ! LESS_EQUAL      [ shift and go to state 147 ]
  ! LESS            [ shift and go to state 148 ]
  ! GREATER_EQUAL   [ shift and go to state 149 ]
  ! GREATER         [ shift and go to state 150 ]


state 201

    (134) binary_expr -> expression GREATER expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 134 (binary_expr -> expression GREATER expression .)
    AND             reduce using rule 134 (binary_expr -> expression GREATER expression .)
    OR              reduce using rule 134 (binary_expr -> expression GREATER expression .)
    XOR             reduce using rule 134 (binary_expr -> expression GREATER expression .)
    LOGICAL_OR      reduce using rule 134 (binary_expr -> expression GREATER expression .)
    LOGICAL_AND     reduce using rule 134 (binary_expr -> expression GREATER expression .)
    NOT_EQUAL       reduce using rule 134 (binary_expr -> expression GREATER expression .)
    EQUAL           reduce using rule 134 (binary_expr -> expression GREATER expression .)
    LESS_EQUAL      reduce using rule 134 (binary_expr -> expression GREATER expression .)
    LESS            reduce using rule 134 (binary_expr -> expression GREATER expression .)
    GREATER_EQUAL   reduce using rule 134 (binary_expr -> expression GREATER expression .)
    GREATER         reduce using rule 134 (binary_expr -> expression GREATER expression .)
    SEMICOLON       reduce using rule 134 (binary_expr -> expression GREATER expression .)
    RPAREN          reduce using rule 134 (binary_expr -> expression GREATER expression .)
    LPAREN          reduce using rule 134 (binary_expr -> expression GREATER expression .)
    GENERICMARK     reduce using rule 134 (binary_expr -> expression GREATER expression .)
    LBRACKET        reduce using rule 134 (binary_expr -> expression GREATER expression .)
    DOT             reduce using rule 134 (binary_expr -> expression GREATER expression .)
    COMMA           reduce using rule 134 (binary_expr -> expression GREATER expression .)
    RBRACKET        reduce using rule 134 (binary_expr -> expression GREATER expression .)
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142

  ! PLUS            [ reduce using rule 134 (binary_expr -> expression GREATER expression .) ]
  ! MINUS           [ reduce using rule 134 (binary_expr -> expression GREATER expression .) ]
  ! MUL             [ reduce using rule 134 (binary_expr -> expression GREATER expression .) ]
  ! DIV             [ reduce using rule 134 (binary_expr -> expression GREATER expression .) ]
  ! MOD             [ reduce using rule 134 (binary_expr -> expression GREATER expression .) ]
  ! LSHIFT          [ reduce using rule 134 (binary_expr -> expression GREATER expression .) ]
  ! RSHIFT          [ reduce using rule 134 (binary_expr -> expression GREATER expression .) ]
  ! ASSIGN          [ shift and go to state 132 ]
  ! AND             [ shift and go to state 137 ]
  ! OR              [ shift and go to state 138 ]
  ! XOR             [ shift and go to state 139 ]
  ! LOGICAL_OR      [ shift and go to state 143 ]
  ! LOGICAL_AND     [ shift and go to state 144 ]
  ! NOT_EQUAL       [ shift and go to state 145 ]
  ! EQUAL           [ shift and go to state 146 ]
  ! LESS_EQUAL      [ shift and go to state 147 ]
  ! LESS            [ shift and go to state 148 ]
  ! GREATER_EQUAL   [ shift and go to state 149 ]
  ! GREATER         [ shift and go to state 150 ]


state 202

    (111) jump_statement -> RETURN expression_opt SEMICOLON .

    LBRACE          reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    IF              reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    BREAK           reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    CONTINUE        reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    RETURN          reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    LET             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    CONST           reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    WHILE           reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    FOR             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    NOT             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    LOGICAL_NOT     reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    PLUS            reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    MINUS           reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    INT             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    HEXADECIMAL     reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    FLOAT           reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    DOUBLE          reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    STRING          reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    ID              reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    LPAREN          reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    FUNC            reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    IN              reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    OUT             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    VOID            reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    BOOL            reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    I8              reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    U8              reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    I16             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    U16             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    I32             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    U32             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    I64             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    U64             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    F16             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    F32             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    F64             reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    INTERFACEID     reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    STRUCTID        reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    GENERICID       reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    TYPEALIASID     reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    LESS            reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    SEMICOLON       reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    RBRACE          reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)
    ELSE            reduce using rule 111 (jump_statement -> RETURN expression_opt SEMICOLON .)


state 203

    (105) while_clause -> WHILE LPAREN expression . RPAREN statement
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    RPAREN          shift and go to state 239
    ASSIGN          shift and go to state 132
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_OR      shift and go to state 143
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150


state 204

    (106) for_clause -> FOR LPAREN for_init_statement . expression_opt SEMICOLON expression RPAREN statement
    (98) expression_opt -> . expression
    (99) expression_opt -> . empty
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (174) empty -> .
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    SEMICOLON       reduce using rule 174 (empty -> .)
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression_opt                 shift and go to state 240
    expression                     shift and go to state 48
    empty                          shift and go to state 154
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 205

    (107) for_init_statement -> expression_statement .

    NOT             reduce using rule 107 (for_init_statement -> expression_statement .)
    LOGICAL_NOT     reduce using rule 107 (for_init_statement -> expression_statement .)
    PLUS            reduce using rule 107 (for_init_statement -> expression_statement .)
    MINUS           reduce using rule 107 (for_init_statement -> expression_statement .)
    INT             reduce using rule 107 (for_init_statement -> expression_statement .)
    HEXADECIMAL     reduce using rule 107 (for_init_statement -> expression_statement .)
    FLOAT           reduce using rule 107 (for_init_statement -> expression_statement .)
    DOUBLE          reduce using rule 107 (for_init_statement -> expression_statement .)
    STRING          reduce using rule 107 (for_init_statement -> expression_statement .)
    ID              reduce using rule 107 (for_init_statement -> expression_statement .)
    LPAREN          reduce using rule 107 (for_init_statement -> expression_statement .)
    FUNC            reduce using rule 107 (for_init_statement -> expression_statement .)
    IN              reduce using rule 107 (for_init_statement -> expression_statement .)
    OUT             reduce using rule 107 (for_init_statement -> expression_statement .)
    VOID            reduce using rule 107 (for_init_statement -> expression_statement .)
    BOOL            reduce using rule 107 (for_init_statement -> expression_statement .)
    I8              reduce using rule 107 (for_init_statement -> expression_statement .)
    U8              reduce using rule 107 (for_init_statement -> expression_statement .)
    I16             reduce using rule 107 (for_init_statement -> expression_statement .)
    U16             reduce using rule 107 (for_init_statement -> expression_statement .)
    I32             reduce using rule 107 (for_init_statement -> expression_statement .)
    U32             reduce using rule 107 (for_init_statement -> expression_statement .)
    I64             reduce using rule 107 (for_init_statement -> expression_statement .)
    U64             reduce using rule 107 (for_init_statement -> expression_statement .)
    F16             reduce using rule 107 (for_init_statement -> expression_statement .)
    F32             reduce using rule 107 (for_init_statement -> expression_statement .)
    F64             reduce using rule 107 (for_init_statement -> expression_statement .)
    INTERFACEID     reduce using rule 107 (for_init_statement -> expression_statement .)
    STRUCTID        reduce using rule 107 (for_init_statement -> expression_statement .)
    GENERICID       reduce using rule 107 (for_init_statement -> expression_statement .)
    TYPEALIASID     reduce using rule 107 (for_init_statement -> expression_statement .)
    LESS            reduce using rule 107 (for_init_statement -> expression_statement .)
    SEMICOLON       reduce using rule 107 (for_init_statement -> expression_statement .)


state 206

    (108) for_init_statement -> decl_statement .

    NOT             reduce using rule 108 (for_init_statement -> decl_statement .)
    LOGICAL_NOT     reduce using rule 108 (for_init_statement -> decl_statement .)
    PLUS            reduce using rule 108 (for_init_statement -> decl_statement .)
    MINUS           reduce using rule 108 (for_init_statement -> decl_statement .)
    INT             reduce using rule 108 (for_init_statement -> decl_statement .)
    HEXADECIMAL     reduce using rule 108 (for_init_statement -> decl_statement .)
    FLOAT           reduce using rule 108 (for_init_statement -> decl_statement .)
    DOUBLE          reduce using rule 108 (for_init_statement -> decl_statement .)
    STRING          reduce using rule 108 (for_init_statement -> decl_statement .)
    ID              reduce using rule 108 (for_init_statement -> decl_statement .)
    LPAREN          reduce using rule 108 (for_init_statement -> decl_statement .)
    FUNC            reduce using rule 108 (for_init_statement -> decl_statement .)
    IN              reduce using rule 108 (for_init_statement -> decl_statement .)
    OUT             reduce using rule 108 (for_init_statement -> decl_statement .)
    VOID            reduce using rule 108 (for_init_statement -> decl_statement .)
    BOOL            reduce using rule 108 (for_init_statement -> decl_statement .)
    I8              reduce using rule 108 (for_init_statement -> decl_statement .)
    U8              reduce using rule 108 (for_init_statement -> decl_statement .)
    I16             reduce using rule 108 (for_init_statement -> decl_statement .)
    U16             reduce using rule 108 (for_init_statement -> decl_statement .)
    I32             reduce using rule 108 (for_init_statement -> decl_statement .)
    U32             reduce using rule 108 (for_init_statement -> decl_statement .)
    I64             reduce using rule 108 (for_init_statement -> decl_statement .)
    U64             reduce using rule 108 (for_init_statement -> decl_statement .)
    F16             reduce using rule 108 (for_init_statement -> decl_statement .)
    F32             reduce using rule 108 (for_init_statement -> decl_statement .)
    F64             reduce using rule 108 (for_init_statement -> decl_statement .)
    INTERFACEID     reduce using rule 108 (for_init_statement -> decl_statement .)
    STRUCTID        reduce using rule 108 (for_init_statement -> decl_statement .)
    GENERICID       reduce using rule 108 (for_init_statement -> decl_statement .)
    TYPEALIASID     reduce using rule 108 (for_init_statement -> decl_statement .)
    LESS            reduce using rule 108 (for_init_statement -> decl_statement .)
    SEMICOLON       reduce using rule 108 (for_init_statement -> decl_statement .)


state 207

    (161) call_expr -> primary_expr LPAREN parameter_list_opt . RPAREN

    RPAREN          shift and go to state 241


state 208

    (159) parameter_list_opt -> parameter_list .

    RPAREN          reduce using rule 159 (parameter_list_opt -> parameter_list .)


state 209

    (160) parameter_list_opt -> empty .
    (58) generics_type_list_opt -> empty .

    RPAREN          reduce using rule 160 (parameter_list_opt -> empty .)
    LPAREN          reduce using rule 58 (generics_type_list_opt -> empty .)


state 210

    (167) parameter_list -> expression . expression_comma_nest
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression
    (168) expression_comma_nest -> . COMMA expression expression_comma_nest
    (169) expression_comma_nest -> . empty
    (174) empty -> .

    ASSIGN          shift and go to state 132
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_OR      shift and go to state 143
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150
    COMMA           shift and go to state 243
    RPAREN          reduce using rule 174 (empty -> .)

    expression_comma_nest          shift and go to state 242
    empty                          shift and go to state 244

state 211

    (162) call_expr -> primary_expr GENERICMARK LESS . type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    type_spec                      shift and go to state 245
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    function_sign                  shift and go to state 82
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 212

    (156) index_expr -> primary_expr LBRACKET expression . RBRACKET
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    RBRACKET        shift and go to state 246
    ASSIGN          shift and go to state 132
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_OR      shift and go to state 143
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150


state 213

    (155) member_expr -> primary_expr DOT ID .

    LPAREN          reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    GENERICMARK     reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    LBRACKET        reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    DOT             reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    ASSIGN          reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    PLUS            reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    MINUS           reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    MUL             reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    DIV             reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    AND             reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    OR              reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    XOR             reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    MOD             reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    LSHIFT          reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    RSHIFT          reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    LOGICAL_OR      reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    LOGICAL_AND     reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    NOT_EQUAL       reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    EQUAL           reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    LESS_EQUAL      reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    LESS            reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    GREATER_EQUAL   reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    GREATER         reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    SEMICOLON       reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    RPAREN          reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    COMMA           reduce using rule 155 (member_expr -> primary_expr DOT ID .)
    RBRACKET        reduce using rule 155 (member_expr -> primary_expr DOT ID .)


state 214

    (79) generics_type_list -> LESS generics_type generics_type_comma_nest . GREATER

    GREATER         shift and go to state 247


state 215

    (80) generics_type_comma_nest -> COMMA . generics_type generics_type_comma_nest
    (82) generics_type -> . ID generics_type_range_colon_opt

    ID              shift and go to state 162

    generics_type                  shift and go to state 248

state 216

    (81) generics_type_comma_nest -> empty .

    GREATER         reduce using rule 81 (generics_type_comma_nest -> empty .)


state 217

    (82) generics_type -> ID generics_type_range_colon_opt .

    COMMA           reduce using rule 82 (generics_type -> ID generics_type_range_colon_opt .)
    GREATER         reduce using rule 82 (generics_type -> ID generics_type_range_colon_opt .)


state 218

    (83) generics_type_range_colon_opt -> COLON . generics_type_range
    (85) generics_type_range -> . complex_type
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt

    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107

    generics_type_range            shift and go to state 249
    complex_type                   shift and go to state 250

state 219

    (84) generics_type_range_colon_opt -> empty .

    COMMA           reduce using rule 84 (generics_type_range_colon_opt -> empty .)
    GREATER         reduce using rule 84 (generics_type_range_colon_opt -> empty .)


state 220

    (158) new_expr -> type_spec LPAREN parameter_list_opt . RPAREN

    RPAREN          shift and go to state 251


state 221

    (46) array_type -> type_spec LBRACKET int_literal_opt . RBRACKET

    RBRACKET        shift and go to state 252


state 222

    (47) int_literal_opt -> INT .

    RBRACKET        reduce using rule 47 (int_literal_opt -> INT .)


state 223

    (48) int_literal_opt -> empty .

    RBRACKET        reduce using rule 48 (int_literal_opt -> empty .)


state 224

    (170) lambda_expr -> FUNC function_sign block_statement .

    LPAREN          reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    GENERICMARK     reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    LBRACKET        reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    DOT             reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    ASSIGN          reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    PLUS            reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    MINUS           reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    MUL             reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    DIV             reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    AND             reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    OR              reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    XOR             reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    MOD             reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    LSHIFT          reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    RSHIFT          reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    LOGICAL_OR      reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    LOGICAL_AND     reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    NOT_EQUAL       reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    EQUAL           reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    LESS_EQUAL      reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    LESS            reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    GREATER_EQUAL   reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    GREATER         reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    SEMICOLON       reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    RPAREN          reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    COMMA           reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)
    RBRACKET        reduce using rule 170 (lambda_expr -> FUNC function_sign block_statement .)


state 225

    (171) io_expr -> in_out LESS type_spec . GREATER LPAREN STRING RPAREN
    (46) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> type_spec . REF

    GREATER         shift and go to state 253
    LBRACKET        shift and go to state 165
    REF             shift and go to state 166


state 226

    (163) generics_specialization_list_opt -> LESS type_spec . type_spec_comma_nest GREATER
    (46) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> type_spec . REF
    (165) type_spec_comma_nest -> . COMMA type_spec type_spec_comma_nest
    (166) type_spec_comma_nest -> . empty
    (174) empty -> .

    LBRACKET        shift and go to state 165
    REF             shift and go to state 166
    COMMA           shift and go to state 255
    GREATER         reduce using rule 174 (empty -> .)

    type_spec_comma_nest           shift and go to state 254
    empty                          shift and go to state 256

state 227

    (71) function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt . RPAREN type_spec_assigntype_opt

    RPAREN          shift and go to state 257


state 228

    (72) parameter_decl_list_opt -> parameter_decl . parameter_decl_comma_nest
    (76) parameter_decl_comma_nest -> . COMMA parameter_decl parameter_decl_comma_nest
    (77) parameter_decl_comma_nest -> . empty
    (174) empty -> .

    COMMA           shift and go to state 259
    RPAREN          reduce using rule 174 (empty -> .)

    parameter_decl_comma_nest      shift and go to state 258
    empty                          shift and go to state 260

state 229

    (73) parameter_decl_list_opt -> empty .

    RPAREN          reduce using rule 73 (parameter_decl_list_opt -> empty .)


state 230

    (78) parameter_decl -> ID . type_spec_colon_opt
    (18) type_spec_colon_opt -> . COLON type_spec
    (19) type_spec_colon_opt -> . empty
    (174) empty -> .

    COLON           shift and go to state 116
    COMMA           reduce using rule 174 (empty -> .)
    RPAREN          reduce using rule 174 (empty -> .)

    type_spec_colon_opt            shift and go to state 261
    empty                          shift and go to state 117

state 231

    (14) declarator_nest -> COMMA declarator declarator_nest .

    SEMICOLON       reduce using rule 14 (declarator_nest -> COMMA declarator declarator_nest .)


state 232

    (17) declarator -> ID type_spec_colon_opt ASSIGN expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    COMMA           reduce using rule 17 (declarator -> ID type_spec_colon_opt ASSIGN expression .)
    SEMICOLON       reduce using rule 17 (declarator -> ID type_spec_colon_opt ASSIGN expression .)
    ASSIGN          shift and go to state 132
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_OR      shift and go to state 143
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150


state 233

    (51) struct_decl -> STRUCT ID new_struct generics_type_list_opt complex_type_colon_opt . LBRACE member_decl_nest RBRACE

    LBRACE          shift and go to state 262


state 234

    (53) complex_type_colon_opt -> COLON . complex_type
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt

    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107

    complex_type                   shift and go to state 263

state 235

    (54) complex_type_colon_opt -> empty .

    LBRACE          reduce using rule 54 (complex_type_colon_opt -> empty .)


state 236

    (55) interface_decl -> INTERFACE ID new_interface generics_type_list_opt LBRACE . interface_member_decl_nest RBRACE
    (61) interface_member_decl_nest -> . interface_member_decl interface_member_decl_nest
    (62) interface_member_decl_nest -> . empty
    (67) interface_member_decl -> . function_decl SEMICOLON
    (68) interface_member_decl -> . type_function_decl SEMICOLON
    (174) empty -> .
    (20) function_decl -> . FUNC ID function_sign
    (69) type_function_decl -> . FUNC type_spec function_sign

    RBRACE          reduce using rule 174 (empty -> .)
    FUNC            shift and go to state 269

    interface_member_decl_nest     shift and go to state 264
    interface_member_decl          shift and go to state 265
    empty                          shift and go to state 266
    function_decl                  shift and go to state 267
    type_function_decl             shift and go to state 268

state 237

    (100) if_statement -> IF LPAREN expression RPAREN . statement statement_else_opt
    (86) statement -> . decl_statement
    (87) statement -> . block_statement
    (88) statement -> . expression_statement
    (89) statement -> . if_statement
    (90) statement -> . iteration_statement
    (91) statement -> . jump_statement
    (92) decl_statement -> . variable_decl SEMICOLON
    (93) decl_statement -> . constant_decl SEMICOLON
    (94) block_statement -> . LBRACE statement_nest RBRACE
    (97) expression_statement -> . expression_opt SEMICOLON
    (100) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (103) iteration_statement -> . while_clause
    (104) iteration_statement -> . for_clause
    (109) jump_statement -> . BREAK SEMICOLON
    (110) jump_statement -> . CONTINUE SEMICOLON
    (111) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (98) expression_opt -> . expression
    (99) expression_opt -> . empty
    (105) while_clause -> . WHILE LPAREN expression RPAREN statement
    (106) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (174) empty -> .
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 51
    CONTINUE        shift and go to state 52
    RETURN          shift and go to state 53
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    SEMICOLON       reduce using rule 174 (empty -> .)
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 48
    statement                      shift and go to state 270
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    expression_opt                 shift and go to state 45
    while_clause                   shift and go to state 49
    for_clause                     shift and go to state 50
    empty                          shift and go to state 154
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 238

    (157) cast_expr -> LPAREN type_spec RPAREN expression .
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
    LPAREN          reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .)
    GENERICMARK     reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .)
    LBRACKET        reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .)
    DOT             reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .)
    SEMICOLON       reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .)
    RPAREN          reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .)
    COMMA           reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .)
    RBRACKET        reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .)
    ASSIGN          shift and go to state 132
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_OR      shift and go to state 143
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150

  ! ASSIGN          [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! PLUS            [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! MINUS           [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! MUL             [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! DIV             [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! AND             [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! OR              [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! XOR             [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! MOD             [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! LSHIFT          [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! RSHIFT          [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! LOGICAL_OR      [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! LOGICAL_AND     [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! NOT_EQUAL       [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! EQUAL           [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! LESS_EQUAL      [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! LESS            [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! GREATER         [ reduce using rule 157 (cast_expr -> LPAREN type_spec RPAREN expression .) ]


state 239

    (105) while_clause -> WHILE LPAREN expression RPAREN . statement
    (86) statement -> . decl_statement
    (87) statement -> . block_statement
    (88) statement -> . expression_statement
    (89) statement -> . if_statement
    (90) statement -> . iteration_statement
    (91) statement -> . jump_statement
    (92) decl_statement -> . variable_decl SEMICOLON
    (93) decl_statement -> . constant_decl SEMICOLON
    (94) block_statement -> . LBRACE statement_nest RBRACE
    (97) expression_statement -> . expression_opt SEMICOLON
    (100) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (103) iteration_statement -> . while_clause
    (104) iteration_statement -> . for_clause
    (109) jump_statement -> . BREAK SEMICOLON
    (110) jump_statement -> . CONTINUE SEMICOLON
    (111) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (98) expression_opt -> . expression
    (99) expression_opt -> . empty
    (105) while_clause -> . WHILE LPAREN expression RPAREN statement
    (106) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (174) empty -> .
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 51
    CONTINUE        shift and go to state 52
    RETURN          shift and go to state 53
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    SEMICOLON       reduce using rule 174 (empty -> .)
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 48
    statement                      shift and go to state 271
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    expression_opt                 shift and go to state 45
    while_clause                   shift and go to state 49
    for_clause                     shift and go to state 50
    empty                          shift and go to state 154
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 240

    (106) for_clause -> FOR LPAREN for_init_statement expression_opt . SEMICOLON expression RPAREN statement

    SEMICOLON       shift and go to state 272


state 241

    (161) call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .

    LPAREN          reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    GENERICMARK     reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    LBRACKET        reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    DOT             reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    ASSIGN          reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    PLUS            reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    MINUS           reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    MUL             reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    DIV             reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    AND             reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    OR              reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    XOR             reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    MOD             reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    LSHIFT          reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    RSHIFT          reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    LOGICAL_OR      reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    LOGICAL_AND     reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    NOT_EQUAL       reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    EQUAL           reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    LESS_EQUAL      reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    LESS            reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    GREATER_EQUAL   reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    GREATER         reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    SEMICOLON       reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    RPAREN          reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    COMMA           reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)
    RBRACKET        reduce using rule 161 (call_expr -> primary_expr LPAREN parameter_list_opt RPAREN .)


state 242

    (167) parameter_list -> expression expression_comma_nest .

    RPAREN          reduce using rule 167 (parameter_list -> expression expression_comma_nest .)


state 243

    (168) expression_comma_nest -> COMMA . expression expression_comma_nest
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 273
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 244

    (169) expression_comma_nest -> empty .

    RPAREN          reduce using rule 169 (expression_comma_nest -> empty .)


state 245

    (162) call_expr -> primary_expr GENERICMARK LESS type_spec . type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (46) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> type_spec . REF
    (165) type_spec_comma_nest -> . COMMA type_spec type_spec_comma_nest
    (166) type_spec_comma_nest -> . empty
    (174) empty -> .

    LBRACKET        shift and go to state 165
    REF             shift and go to state 166
    COMMA           shift and go to state 255
    GREATER         reduce using rule 174 (empty -> .)

    type_spec_comma_nest           shift and go to state 274
    empty                          shift and go to state 256

state 246

    (156) index_expr -> primary_expr LBRACKET expression RBRACKET .

    LPAREN          reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    GENERICMARK     reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    DOT             reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    ASSIGN          reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    MUL             reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    DIV             reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    AND             reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    OR              reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    XOR             reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    MOD             reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LSHIFT          reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    RSHIFT          reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LOGICAL_OR      reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LOGICAL_AND     reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    NOT_EQUAL       reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    EQUAL           reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LESS_EQUAL      reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LESS            reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    GREATER_EQUAL   reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    GREATER         reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 156 (index_expr -> primary_expr LBRACKET expression RBRACKET .)


state 247

    (79) generics_type_list -> LESS generics_type generics_type_comma_nest GREATER .

    LPAREN          reduce using rule 79 (generics_type_list -> LESS generics_type generics_type_comma_nest GREATER .)
    COLON           reduce using rule 79 (generics_type_list -> LESS generics_type generics_type_comma_nest GREATER .)
    LBRACE          reduce using rule 79 (generics_type_list -> LESS generics_type generics_type_comma_nest GREATER .)


state 248

    (80) generics_type_comma_nest -> COMMA generics_type . generics_type_comma_nest
    (80) generics_type_comma_nest -> . COMMA generics_type generics_type_comma_nest
    (81) generics_type_comma_nest -> . empty
    (174) empty -> .

    COMMA           shift and go to state 215
    GREATER         reduce using rule 174 (empty -> .)

    generics_type_comma_nest       shift and go to state 275
    empty                          shift and go to state 216

state 249

    (83) generics_type_range_colon_opt -> COLON generics_type_range .

    COMMA           reduce using rule 83 (generics_type_range_colon_opt -> COLON generics_type_range .)
    GREATER         reduce using rule 83 (generics_type_range_colon_opt -> COLON generics_type_range .)


state 250

    (85) generics_type_range -> complex_type .

    COMMA           reduce using rule 85 (generics_type_range -> complex_type .)
    GREATER         reduce using rule 85 (generics_type_range -> complex_type .)


state 251

    (158) new_expr -> type_spec LPAREN parameter_list_opt RPAREN .

    LPAREN          reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    GENERICMARK     reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LBRACKET        reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    DOT             reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    ASSIGN          reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    PLUS            reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    MINUS           reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    MUL             reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    DIV             reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    AND             reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    OR              reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    XOR             reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    MOD             reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LSHIFT          reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    RSHIFT          reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LOGICAL_OR      reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LOGICAL_AND     reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    NOT_EQUAL       reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    EQUAL           reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LESS_EQUAL      reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LESS            reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    GREATER_EQUAL   reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    GREATER         reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    SEMICOLON       reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    RPAREN          reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    COMMA           reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    RBRACKET        reduce using rule 158 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)


state 252

    (46) array_type -> type_spec LBRACKET int_literal_opt RBRACKET .

    LPAREN          reduce using rule 46 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    LBRACKET        reduce using rule 46 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    REF             reduce using rule 46 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    RPAREN          reduce using rule 46 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    ASSIGN          reduce using rule 46 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    COMMA           reduce using rule 46 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    SEMICOLON       reduce using rule 46 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    GREATER         reduce using rule 46 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    LESS            reduce using rule 46 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    LBRACE          reduce using rule 46 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)


state 253

    (171) io_expr -> in_out LESS type_spec GREATER . LPAREN STRING RPAREN

    LPAREN          shift and go to state 276


state 254

    (163) generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest . GREATER

    GREATER         shift and go to state 277


state 255

    (165) type_spec_comma_nest -> COMMA . type_spec type_spec_comma_nest
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    type_spec                      shift and go to state 278
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    function_sign                  shift and go to state 82
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 256

    (166) type_spec_comma_nest -> empty .

    GREATER         reduce using rule 166 (type_spec_comma_nest -> empty .)


state 257

    (71) function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN . type_spec_assigntype_opt
    (74) type_spec_assigntype_opt -> . ASSIGNTYPE type_spec
    (75) type_spec_assigntype_opt -> . empty
    (174) empty -> .

    ASSIGNTYPE      shift and go to state 280
    LBRACKET        reduce using rule 174 (empty -> .)
    REF             reduce using rule 174 (empty -> .)
    LPAREN          reduce using rule 174 (empty -> .)
    SEMICOLON       reduce using rule 174 (empty -> .)
    LBRACE          reduce using rule 174 (empty -> .)
    RPAREN          reduce using rule 174 (empty -> .)
    ASSIGN          reduce using rule 174 (empty -> .)
    COMMA           reduce using rule 174 (empty -> .)
    GREATER         reduce using rule 174 (empty -> .)
    LESS            reduce using rule 174 (empty -> .)

    type_spec_assigntype_opt       shift and go to state 279
    empty                          shift and go to state 281

state 258

    (72) parameter_decl_list_opt -> parameter_decl parameter_decl_comma_nest .

    RPAREN          reduce using rule 72 (parameter_decl_list_opt -> parameter_decl parameter_decl_comma_nest .)


state 259

    (76) parameter_decl_comma_nest -> COMMA . parameter_decl parameter_decl_comma_nest
    (78) parameter_decl -> . ID type_spec_colon_opt

    ID              shift and go to state 230

    parameter_decl                 shift and go to state 282

state 260

    (77) parameter_decl_comma_nest -> empty .

    RPAREN          reduce using rule 77 (parameter_decl_comma_nest -> empty .)


state 261

    (78) parameter_decl -> ID type_spec_colon_opt .

    COMMA           reduce using rule 78 (parameter_decl -> ID type_spec_colon_opt .)
    RPAREN          reduce using rule 78 (parameter_decl -> ID type_spec_colon_opt .)


state 262

    (51) struct_decl -> STRUCT ID new_struct generics_type_list_opt complex_type_colon_opt LBRACE . member_decl_nest RBRACE
    (59) member_decl_nest -> . member_decl member_decl_nest
    (60) member_decl_nest -> . empty
    (63) member_decl -> . member_declarator
    (64) member_decl -> . function_def
    (65) member_decl -> . type_function_def
    (174) empty -> .
    (70) member_declarator -> . ID COLON type_spec SEMICOLON
    (21) function_def -> . function_decl block_statement
    (66) type_function_def -> . type_function_decl block_statement
    (20) function_decl -> . FUNC ID function_sign
    (69) type_function_decl -> . FUNC type_spec function_sign

    RBRACE          reduce using rule 174 (empty -> .)
    ID              shift and go to state 283
    FUNC            shift and go to state 269

    member_decl_nest               shift and go to state 284
    member_decl                    shift and go to state 285
    empty                          shift and go to state 286
    member_declarator              shift and go to state 287
    function_def                   shift and go to state 288
    type_function_def              shift and go to state 289
    function_decl                  shift and go to state 290
    type_function_decl             shift and go to state 291

state 263

    (53) complex_type_colon_opt -> COLON complex_type .

    LBRACE          reduce using rule 53 (complex_type_colon_opt -> COLON complex_type .)


state 264

    (55) interface_decl -> INTERFACE ID new_interface generics_type_list_opt LBRACE interface_member_decl_nest . RBRACE

    RBRACE          shift and go to state 292


state 265

    (61) interface_member_decl_nest -> interface_member_decl . interface_member_decl_nest
    (61) interface_member_decl_nest -> . interface_member_decl interface_member_decl_nest
    (62) interface_member_decl_nest -> . empty
    (67) interface_member_decl -> . function_decl SEMICOLON
    (68) interface_member_decl -> . type_function_decl SEMICOLON
    (174) empty -> .
    (20) function_decl -> . FUNC ID function_sign
    (69) type_function_decl -> . FUNC type_spec function_sign

    RBRACE          reduce using rule 174 (empty -> .)
    FUNC            shift and go to state 269

    interface_member_decl          shift and go to state 265
    interface_member_decl_nest     shift and go to state 293
    empty                          shift and go to state 266
    function_decl                  shift and go to state 267
    type_function_decl             shift and go to state 268

state 266

    (62) interface_member_decl_nest -> empty .

    RBRACE          reduce using rule 62 (interface_member_decl_nest -> empty .)


state 267

    (67) interface_member_decl -> function_decl . SEMICOLON

    SEMICOLON       shift and go to state 294


state 268

    (68) interface_member_decl -> type_function_decl . SEMICOLON

    SEMICOLON       shift and go to state 295


state 269

    (20) function_decl -> FUNC . ID function_sign
    (69) type_function_decl -> FUNC . type_spec function_sign
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    ID              shift and go to state 30
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    function_sign                  shift and go to state 82
    type_spec                      shift and go to state 296
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 270

    (100) if_statement -> IF LPAREN expression RPAREN statement . statement_else_opt
    (101) statement_else_opt -> . ELSE statement
    (102) statement_else_opt -> . empty
    (174) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 298
    LBRACE          reduce using rule 174 (empty -> .)
    IF              reduce using rule 174 (empty -> .)
    BREAK           reduce using rule 174 (empty -> .)
    CONTINUE        reduce using rule 174 (empty -> .)
    RETURN          reduce using rule 174 (empty -> .)
    LET             reduce using rule 174 (empty -> .)
    CONST           reduce using rule 174 (empty -> .)
    WHILE           reduce using rule 174 (empty -> .)
    FOR             reduce using rule 174 (empty -> .)
    NOT             reduce using rule 174 (empty -> .)
    LOGICAL_NOT     reduce using rule 174 (empty -> .)
    PLUS            reduce using rule 174 (empty -> .)
    MINUS           reduce using rule 174 (empty -> .)
    INT             reduce using rule 174 (empty -> .)
    HEXADECIMAL     reduce using rule 174 (empty -> .)
    FLOAT           reduce using rule 174 (empty -> .)
    DOUBLE          reduce using rule 174 (empty -> .)
    STRING          reduce using rule 174 (empty -> .)
    ID              reduce using rule 174 (empty -> .)
    LPAREN          reduce using rule 174 (empty -> .)
    FUNC            reduce using rule 174 (empty -> .)
    IN              reduce using rule 174 (empty -> .)
    OUT             reduce using rule 174 (empty -> .)
    VOID            reduce using rule 174 (empty -> .)
    BOOL            reduce using rule 174 (empty -> .)
    I8              reduce using rule 174 (empty -> .)
    U8              reduce using rule 174 (empty -> .)
    I16             reduce using rule 174 (empty -> .)
    U16             reduce using rule 174 (empty -> .)
    I32             reduce using rule 174 (empty -> .)
    U32             reduce using rule 174 (empty -> .)
    I64             reduce using rule 174 (empty -> .)
    U64             reduce using rule 174 (empty -> .)
    F16             reduce using rule 174 (empty -> .)
    F32             reduce using rule 174 (empty -> .)
    F64             reduce using rule 174 (empty -> .)
    INTERFACEID     reduce using rule 174 (empty -> .)
    STRUCTID        reduce using rule 174 (empty -> .)
    GENERICID       reduce using rule 174 (empty -> .)
    TYPEALIASID     reduce using rule 174 (empty -> .)
    LESS            reduce using rule 174 (empty -> .)
    SEMICOLON       reduce using rule 174 (empty -> .)
    RBRACE          reduce using rule 174 (empty -> .)

  ! ELSE            [ reduce using rule 174 (empty -> .) ]

    statement_else_opt             shift and go to state 297
    empty                          shift and go to state 299

state 271

    (105) while_clause -> WHILE LPAREN expression RPAREN statement .

    LBRACE          reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    IF              reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    CONTINUE        reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    LET             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    CONST           reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    FOR             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    NOT             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    LOGICAL_NOT     reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    PLUS            reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    INT             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    HEXADECIMAL     reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    DOUBLE          reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    STRING          reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    ID              reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    FUNC            reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    IN              reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    OUT             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    VOID            reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    BOOL            reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    I8              reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    U8              reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    I16             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    U16             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    I32             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    U32             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    I64             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    U64             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    F16             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    F32             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    F64             reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    INTERFACEID     reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    STRUCTID        reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    GENERICID       reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    TYPEALIASID     reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    LESS            reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    SEMICOLON       reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    RBRACE          reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    ELSE            reduce using rule 105 (while_clause -> WHILE LPAREN expression RPAREN statement .)


state 272

    (106) for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON . expression RPAREN statement
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression                     shift and go to state 300
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 273

    (168) expression_comma_nest -> COMMA expression . expression_comma_nest
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression
    (168) expression_comma_nest -> . COMMA expression expression_comma_nest
    (169) expression_comma_nest -> . empty
    (174) empty -> .

    ASSIGN          shift and go to state 132
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_OR      shift and go to state 143
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150
    COMMA           shift and go to state 243
    RPAREN          reduce using rule 174 (empty -> .)

    expression_comma_nest          shift and go to state 301
    empty                          shift and go to state 244

state 274

    (162) call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest . GREATER LPAREN parameter_list_opt RPAREN

    GREATER         shift and go to state 302


state 275

    (80) generics_type_comma_nest -> COMMA generics_type generics_type_comma_nest .

    GREATER         reduce using rule 80 (generics_type_comma_nest -> COMMA generics_type generics_type_comma_nest .)


state 276

    (171) io_expr -> in_out LESS type_spec GREATER LPAREN . STRING RPAREN

    STRING          shift and go to state 303


state 277

    (163) generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER .

    LPAREN          reduce using rule 163 (generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER .)
    LBRACKET        reduce using rule 163 (generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER .)
    REF             reduce using rule 163 (generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER .)
    RPAREN          reduce using rule 163 (generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER .)
    ASSIGN          reduce using rule 163 (generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER .)
    COMMA           reduce using rule 163 (generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER .)
    SEMICOLON       reduce using rule 163 (generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER .)
    GREATER         reduce using rule 163 (generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER .)
    LBRACE          reduce using rule 163 (generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER .)
    LESS            reduce using rule 163 (generics_specialization_list_opt -> LESS type_spec type_spec_comma_nest GREATER .)


state 278

    (165) type_spec_comma_nest -> COMMA type_spec . type_spec_comma_nest
    (46) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> type_spec . REF
    (165) type_spec_comma_nest -> . COMMA type_spec type_spec_comma_nest
    (166) type_spec_comma_nest -> . empty
    (174) empty -> .

    LBRACKET        shift and go to state 165
    REF             shift and go to state 166
    COMMA           shift and go to state 255
    GREATER         reduce using rule 174 (empty -> .)

    type_spec_comma_nest           shift and go to state 304
    empty                          shift and go to state 256

state 279

    (71) function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .

    LPAREN          reduce using rule 71 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    LBRACKET        reduce using rule 71 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    REF             reduce using rule 71 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    SEMICOLON       reduce using rule 71 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    LBRACE          reduce using rule 71 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    RPAREN          reduce using rule 71 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    ASSIGN          reduce using rule 71 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    COMMA           reduce using rule 71 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    GREATER         reduce using rule 71 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    LESS            reduce using rule 71 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)


state 280

    (74) type_spec_assigntype_opt -> ASSIGNTYPE . type_spec
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    type_spec                      shift and go to state 305
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    function_sign                  shift and go to state 82
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 281

    (75) type_spec_assigntype_opt -> empty .

    LBRACKET        reduce using rule 75 (type_spec_assigntype_opt -> empty .)
    REF             reduce using rule 75 (type_spec_assigntype_opt -> empty .)
    LPAREN          reduce using rule 75 (type_spec_assigntype_opt -> empty .)
    SEMICOLON       reduce using rule 75 (type_spec_assigntype_opt -> empty .)
    LBRACE          reduce using rule 75 (type_spec_assigntype_opt -> empty .)
    RPAREN          reduce using rule 75 (type_spec_assigntype_opt -> empty .)
    ASSIGN          reduce using rule 75 (type_spec_assigntype_opt -> empty .)
    COMMA           reduce using rule 75 (type_spec_assigntype_opt -> empty .)
    GREATER         reduce using rule 75 (type_spec_assigntype_opt -> empty .)
    LESS            reduce using rule 75 (type_spec_assigntype_opt -> empty .)


state 282

    (76) parameter_decl_comma_nest -> COMMA parameter_decl . parameter_decl_comma_nest
    (76) parameter_decl_comma_nest -> . COMMA parameter_decl parameter_decl_comma_nest
    (77) parameter_decl_comma_nest -> . empty
    (174) empty -> .

    COMMA           shift and go to state 259
    RPAREN          reduce using rule 174 (empty -> .)

    parameter_decl_comma_nest      shift and go to state 306
    empty                          shift and go to state 260

state 283

    (70) member_declarator -> ID . COLON type_spec SEMICOLON

    COLON           shift and go to state 307


state 284

    (51) struct_decl -> STRUCT ID new_struct generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest . RBRACE

    RBRACE          shift and go to state 308


state 285

    (59) member_decl_nest -> member_decl . member_decl_nest
    (59) member_decl_nest -> . member_decl member_decl_nest
    (60) member_decl_nest -> . empty
    (63) member_decl -> . member_declarator
    (64) member_decl -> . function_def
    (65) member_decl -> . type_function_def
    (174) empty -> .
    (70) member_declarator -> . ID COLON type_spec SEMICOLON
    (21) function_def -> . function_decl block_statement
    (66) type_function_def -> . type_function_decl block_statement
    (20) function_decl -> . FUNC ID function_sign
    (69) type_function_decl -> . FUNC type_spec function_sign

    RBRACE          reduce using rule 174 (empty -> .)
    ID              shift and go to state 283
    FUNC            shift and go to state 269

    member_decl                    shift and go to state 285
    member_decl_nest               shift and go to state 309
    empty                          shift and go to state 286
    member_declarator              shift and go to state 287
    function_def                   shift and go to state 288
    type_function_def              shift and go to state 289
    function_decl                  shift and go to state 290
    type_function_decl             shift and go to state 291

state 286

    (60) member_decl_nest -> empty .

    RBRACE          reduce using rule 60 (member_decl_nest -> empty .)


state 287

    (63) member_decl -> member_declarator .

    ID              reduce using rule 63 (member_decl -> member_declarator .)
    FUNC            reduce using rule 63 (member_decl -> member_declarator .)
    RBRACE          reduce using rule 63 (member_decl -> member_declarator .)


state 288

    (64) member_decl -> function_def .

    ID              reduce using rule 64 (member_decl -> function_def .)
    FUNC            reduce using rule 64 (member_decl -> function_def .)
    RBRACE          reduce using rule 64 (member_decl -> function_def .)


state 289

    (65) member_decl -> type_function_def .

    ID              reduce using rule 65 (member_decl -> type_function_def .)
    FUNC            reduce using rule 65 (member_decl -> type_function_def .)
    RBRACE          reduce using rule 65 (member_decl -> type_function_def .)


state 290

    (21) function_def -> function_decl . block_statement
    (94) block_statement -> . LBRACE statement_nest RBRACE

    LBRACE          shift and go to state 26

    block_statement                shift and go to state 25

state 291

    (66) type_function_def -> type_function_decl . block_statement
    (94) block_statement -> . LBRACE statement_nest RBRACE

    LBRACE          shift and go to state 26

    block_statement                shift and go to state 310

state 292

    (55) interface_decl -> INTERFACE ID new_interface generics_type_list_opt LBRACE interface_member_decl_nest RBRACE .

    SEMICOLON       reduce using rule 55 (interface_decl -> INTERFACE ID new_interface generics_type_list_opt LBRACE interface_member_decl_nest RBRACE .)


state 293

    (61) interface_member_decl_nest -> interface_member_decl interface_member_decl_nest .

    RBRACE          reduce using rule 61 (interface_member_decl_nest -> interface_member_decl interface_member_decl_nest .)


state 294

    (67) interface_member_decl -> function_decl SEMICOLON .

    FUNC            reduce using rule 67 (interface_member_decl -> function_decl SEMICOLON .)
    RBRACE          reduce using rule 67 (interface_member_decl -> function_decl SEMICOLON .)


state 295

    (68) interface_member_decl -> type_function_decl SEMICOLON .

    FUNC            reduce using rule 68 (interface_member_decl -> type_function_decl SEMICOLON .)
    RBRACE          reduce using rule 68 (interface_member_decl -> type_function_decl SEMICOLON .)


state 296

    (69) type_function_decl -> FUNC type_spec . function_sign
    (46) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> type_spec . REF
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    LBRACKET        shift and go to state 165
    REF             shift and go to state 166
    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    function_sign                  shift and go to state 311
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 297

    (100) if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .

    LBRACE          reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    IF              reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    BREAK           reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    CONTINUE        reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    RETURN          reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    LET             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    CONST           reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    WHILE           reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    FOR             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    NOT             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    LOGICAL_NOT     reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    PLUS            reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    MINUS           reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    INT             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    HEXADECIMAL     reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    FLOAT           reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    DOUBLE          reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    STRING          reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    ID              reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    LPAREN          reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    FUNC            reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    IN              reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    OUT             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    VOID            reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    BOOL            reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    I8              reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    U8              reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    I16             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    U16             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    I32             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    U32             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    I64             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    U64             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    F16             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    F32             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    F64             reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    INTERFACEID     reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    STRUCTID        reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    GENERICID       reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    TYPEALIASID     reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    LESS            reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    SEMICOLON       reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    RBRACE          reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    ELSE            reduce using rule 100 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)


state 298

    (101) statement_else_opt -> ELSE . statement
    (86) statement -> . decl_statement
    (87) statement -> . block_statement
    (88) statement -> . expression_statement
    (89) statement -> . if_statement
    (90) statement -> . iteration_statement
    (91) statement -> . jump_statement
    (92) decl_statement -> . variable_decl SEMICOLON
    (93) decl_statement -> . constant_decl SEMICOLON
    (94) block_statement -> . LBRACE statement_nest RBRACE
    (97) expression_statement -> . expression_opt SEMICOLON
    (100) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (103) iteration_statement -> . while_clause
    (104) iteration_statement -> . for_clause
    (109) jump_statement -> . BREAK SEMICOLON
    (110) jump_statement -> . CONTINUE SEMICOLON
    (111) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (98) expression_opt -> . expression
    (99) expression_opt -> . empty
    (105) while_clause -> . WHILE LPAREN expression RPAREN statement
    (106) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (174) empty -> .
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 51
    CONTINUE        shift and go to state 52
    RETURN          shift and go to state 53
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    SEMICOLON       reduce using rule 174 (empty -> .)
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    statement                      shift and go to state 312
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    expression_opt                 shift and go to state 45
    expression                     shift and go to state 48
    while_clause                   shift and go to state 49
    for_clause                     shift and go to state 50
    empty                          shift and go to state 154
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 299

    (102) statement_else_opt -> empty .

    ELSE            reduce using rule 102 (statement_else_opt -> empty .)
    LBRACE          reduce using rule 102 (statement_else_opt -> empty .)
    IF              reduce using rule 102 (statement_else_opt -> empty .)
    BREAK           reduce using rule 102 (statement_else_opt -> empty .)
    CONTINUE        reduce using rule 102 (statement_else_opt -> empty .)
    RETURN          reduce using rule 102 (statement_else_opt -> empty .)
    LET             reduce using rule 102 (statement_else_opt -> empty .)
    CONST           reduce using rule 102 (statement_else_opt -> empty .)
    WHILE           reduce using rule 102 (statement_else_opt -> empty .)
    FOR             reduce using rule 102 (statement_else_opt -> empty .)
    NOT             reduce using rule 102 (statement_else_opt -> empty .)
    LOGICAL_NOT     reduce using rule 102 (statement_else_opt -> empty .)
    PLUS            reduce using rule 102 (statement_else_opt -> empty .)
    MINUS           reduce using rule 102 (statement_else_opt -> empty .)
    INT             reduce using rule 102 (statement_else_opt -> empty .)
    HEXADECIMAL     reduce using rule 102 (statement_else_opt -> empty .)
    FLOAT           reduce using rule 102 (statement_else_opt -> empty .)
    DOUBLE          reduce using rule 102 (statement_else_opt -> empty .)
    STRING          reduce using rule 102 (statement_else_opt -> empty .)
    ID              reduce using rule 102 (statement_else_opt -> empty .)
    LPAREN          reduce using rule 102 (statement_else_opt -> empty .)
    FUNC            reduce using rule 102 (statement_else_opt -> empty .)
    IN              reduce using rule 102 (statement_else_opt -> empty .)
    OUT             reduce using rule 102 (statement_else_opt -> empty .)
    VOID            reduce using rule 102 (statement_else_opt -> empty .)
    BOOL            reduce using rule 102 (statement_else_opt -> empty .)
    I8              reduce using rule 102 (statement_else_opt -> empty .)
    U8              reduce using rule 102 (statement_else_opt -> empty .)
    I16             reduce using rule 102 (statement_else_opt -> empty .)
    U16             reduce using rule 102 (statement_else_opt -> empty .)
    I32             reduce using rule 102 (statement_else_opt -> empty .)
    U32             reduce using rule 102 (statement_else_opt -> empty .)
    I64             reduce using rule 102 (statement_else_opt -> empty .)
    U64             reduce using rule 102 (statement_else_opt -> empty .)
    F16             reduce using rule 102 (statement_else_opt -> empty .)
    F32             reduce using rule 102 (statement_else_opt -> empty .)
    F64             reduce using rule 102 (statement_else_opt -> empty .)
    INTERFACEID     reduce using rule 102 (statement_else_opt -> empty .)
    STRUCTID        reduce using rule 102 (statement_else_opt -> empty .)
    GENERICID       reduce using rule 102 (statement_else_opt -> empty .)
    TYPEALIASID     reduce using rule 102 (statement_else_opt -> empty .)
    LESS            reduce using rule 102 (statement_else_opt -> empty .)
    SEMICOLON       reduce using rule 102 (statement_else_opt -> empty .)
    RBRACE          reduce using rule 102 (statement_else_opt -> empty .)


state 300

    (106) for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression . RPAREN statement
    (116) assign_expr -> expression . ASSIGN expression
    (117) binary_expr -> expression . PLUS expression
    (118) binary_expr -> expression . MINUS expression
    (119) binary_expr -> expression . MUL expression
    (120) binary_expr -> expression . DIV expression
    (121) binary_expr -> expression . AND expression
    (122) binary_expr -> expression . OR expression
    (123) binary_expr -> expression . XOR expression
    (124) binary_expr -> expression . MOD expression
    (125) binary_expr -> expression . LSHIFT expression
    (126) binary_expr -> expression . RSHIFT expression
    (127) binary_expr -> expression . LOGICAL_OR expression
    (128) binary_expr -> expression . LOGICAL_AND expression
    (129) binary_expr -> expression . NOT_EQUAL expression
    (130) binary_expr -> expression . EQUAL expression
    (131) binary_expr -> expression . LESS_EQUAL expression
    (132) binary_expr -> expression . LESS expression
    (133) binary_expr -> expression . GREATER_EQUAL expression
    (134) binary_expr -> expression . GREATER expression

    RPAREN          shift and go to state 313
    ASSIGN          shift and go to state 132
    PLUS            shift and go to state 133
    MINUS           shift and go to state 134
    MUL             shift and go to state 135
    DIV             shift and go to state 136
    AND             shift and go to state 137
    OR              shift and go to state 138
    XOR             shift and go to state 139
    MOD             shift and go to state 140
    LSHIFT          shift and go to state 141
    RSHIFT          shift and go to state 142
    LOGICAL_OR      shift and go to state 143
    LOGICAL_AND     shift and go to state 144
    NOT_EQUAL       shift and go to state 145
    EQUAL           shift and go to state 146
    LESS_EQUAL      shift and go to state 147
    LESS            shift and go to state 148
    GREATER_EQUAL   shift and go to state 149
    GREATER         shift and go to state 150


state 301

    (168) expression_comma_nest -> COMMA expression expression_comma_nest .

    RPAREN          reduce using rule 168 (expression_comma_nest -> COMMA expression expression_comma_nest .)


state 302

    (162) call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER . LPAREN parameter_list_opt RPAREN

    LPAREN          shift and go to state 314


state 303

    (171) io_expr -> in_out LESS type_spec GREATER LPAREN STRING . RPAREN

    RPAREN          shift and go to state 315


state 304

    (165) type_spec_comma_nest -> COMMA type_spec type_spec_comma_nest .

    GREATER         reduce using rule 165 (type_spec_comma_nest -> COMMA type_spec type_spec_comma_nest .)


state 305

    (74) type_spec_assigntype_opt -> ASSIGNTYPE type_spec .
    (46) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> type_spec . REF

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for REF resolved as shift
    LPAREN          reduce using rule 74 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    SEMICOLON       reduce using rule 74 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    LBRACE          reduce using rule 74 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    RPAREN          reduce using rule 74 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    ASSIGN          reduce using rule 74 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    COMMA           reduce using rule 74 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    GREATER         reduce using rule 74 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    LESS            reduce using rule 74 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    LBRACKET        shift and go to state 165
    REF             shift and go to state 166

  ! LBRACKET        [ reduce using rule 74 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .) ]
  ! REF             [ reduce using rule 74 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .) ]


state 306

    (76) parameter_decl_comma_nest -> COMMA parameter_decl parameter_decl_comma_nest .

    RPAREN          reduce using rule 76 (parameter_decl_comma_nest -> COMMA parameter_decl parameter_decl_comma_nest .)


state 307

    (70) member_declarator -> ID COLON . type_spec SEMICOLON
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER
    (174) empty -> .

    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62
    LPAREN          reduce using rule 174 (empty -> .)

    type_spec                      shift and go to state 316
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    function_sign                  shift and go to state 82
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111
    empty                          shift and go to state 120

state 308

    (51) struct_decl -> STRUCT ID new_struct generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE .

    SEMICOLON       reduce using rule 51 (struct_decl -> STRUCT ID new_struct generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE .)


state 309

    (59) member_decl_nest -> member_decl member_decl_nest .

    RBRACE          reduce using rule 59 (member_decl_nest -> member_decl member_decl_nest .)


state 310

    (66) type_function_def -> type_function_decl block_statement .

    ID              reduce using rule 66 (type_function_def -> type_function_decl block_statement .)
    FUNC            reduce using rule 66 (type_function_def -> type_function_decl block_statement .)
    RBRACE          reduce using rule 66 (type_function_def -> type_function_decl block_statement .)


state 311

    (69) type_function_decl -> FUNC type_spec function_sign .

    SEMICOLON       reduce using rule 69 (type_function_decl -> FUNC type_spec function_sign .)
    LBRACE          reduce using rule 69 (type_function_decl -> FUNC type_spec function_sign .)


state 312

    (101) statement_else_opt -> ELSE statement .

    ELSE            reduce using rule 101 (statement_else_opt -> ELSE statement .)
    LBRACE          reduce using rule 101 (statement_else_opt -> ELSE statement .)
    IF              reduce using rule 101 (statement_else_opt -> ELSE statement .)
    BREAK           reduce using rule 101 (statement_else_opt -> ELSE statement .)
    CONTINUE        reduce using rule 101 (statement_else_opt -> ELSE statement .)
    RETURN          reduce using rule 101 (statement_else_opt -> ELSE statement .)
    LET             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    CONST           reduce using rule 101 (statement_else_opt -> ELSE statement .)
    WHILE           reduce using rule 101 (statement_else_opt -> ELSE statement .)
    FOR             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    NOT             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    LOGICAL_NOT     reduce using rule 101 (statement_else_opt -> ELSE statement .)
    PLUS            reduce using rule 101 (statement_else_opt -> ELSE statement .)
    MINUS           reduce using rule 101 (statement_else_opt -> ELSE statement .)
    INT             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    HEXADECIMAL     reduce using rule 101 (statement_else_opt -> ELSE statement .)
    FLOAT           reduce using rule 101 (statement_else_opt -> ELSE statement .)
    DOUBLE          reduce using rule 101 (statement_else_opt -> ELSE statement .)
    STRING          reduce using rule 101 (statement_else_opt -> ELSE statement .)
    ID              reduce using rule 101 (statement_else_opt -> ELSE statement .)
    LPAREN          reduce using rule 101 (statement_else_opt -> ELSE statement .)
    FUNC            reduce using rule 101 (statement_else_opt -> ELSE statement .)
    IN              reduce using rule 101 (statement_else_opt -> ELSE statement .)
    OUT             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    VOID            reduce using rule 101 (statement_else_opt -> ELSE statement .)
    BOOL            reduce using rule 101 (statement_else_opt -> ELSE statement .)
    I8              reduce using rule 101 (statement_else_opt -> ELSE statement .)
    U8              reduce using rule 101 (statement_else_opt -> ELSE statement .)
    I16             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    U16             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    I32             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    U32             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    I64             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    U64             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    F16             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    F32             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    F64             reduce using rule 101 (statement_else_opt -> ELSE statement .)
    INTERFACEID     reduce using rule 101 (statement_else_opt -> ELSE statement .)
    STRUCTID        reduce using rule 101 (statement_else_opt -> ELSE statement .)
    GENERICID       reduce using rule 101 (statement_else_opt -> ELSE statement .)
    TYPEALIASID     reduce using rule 101 (statement_else_opt -> ELSE statement .)
    LESS            reduce using rule 101 (statement_else_opt -> ELSE statement .)
    SEMICOLON       reduce using rule 101 (statement_else_opt -> ELSE statement .)
    RBRACE          reduce using rule 101 (statement_else_opt -> ELSE statement .)


state 313

    (106) for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN . statement
    (86) statement -> . decl_statement
    (87) statement -> . block_statement
    (88) statement -> . expression_statement
    (89) statement -> . if_statement
    (90) statement -> . iteration_statement
    (91) statement -> . jump_statement
    (92) decl_statement -> . variable_decl SEMICOLON
    (93) decl_statement -> . constant_decl SEMICOLON
    (94) block_statement -> . LBRACE statement_nest RBRACE
    (97) expression_statement -> . expression_opt SEMICOLON
    (100) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (103) iteration_statement -> . while_clause
    (104) iteration_statement -> . for_clause
    (109) jump_statement -> . BREAK SEMICOLON
    (110) jump_statement -> . CONTINUE SEMICOLON
    (111) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (98) expression_opt -> . expression
    (99) expression_opt -> . empty
    (105) while_clause -> . WHILE LPAREN expression RPAREN statement
    (106) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (174) empty -> .
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 51
    CONTINUE        shift and go to state 52
    RETURN          shift and go to state 53
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 54
    FOR             shift and go to state 55
    SEMICOLON       reduce using rule 174 (empty -> .)
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    expression_opt                 shift and go to state 45
    expression                     shift and go to state 48
    statement                      shift and go to state 317
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    while_clause                   shift and go to state 49
    for_clause                     shift and go to state 50
    empty                          shift and go to state 154
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    primary_expr                   shift and go to state 59
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    type_spec                      shift and go to state 80
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 314

    (162) call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN . parameter_list_opt RPAREN
    (159) parameter_list_opt -> . parameter_list
    (160) parameter_list_opt -> . empty
    (167) parameter_list -> . expression expression_comma_nest
    (174) empty -> .
    (112) expression -> . assign_expr
    (113) expression -> . binary_expr
    (114) expression -> . unary_expr
    (115) expression -> . primary_expr
    (116) assign_expr -> . expression ASSIGN expression
    (117) binary_expr -> . expression PLUS expression
    (118) binary_expr -> . expression MINUS expression
    (119) binary_expr -> . expression MUL expression
    (120) binary_expr -> . expression DIV expression
    (121) binary_expr -> . expression AND expression
    (122) binary_expr -> . expression OR expression
    (123) binary_expr -> . expression XOR expression
    (124) binary_expr -> . expression MOD expression
    (125) binary_expr -> . expression LSHIFT expression
    (126) binary_expr -> . expression RSHIFT expression
    (127) binary_expr -> . expression LOGICAL_OR expression
    (128) binary_expr -> . expression LOGICAL_AND expression
    (129) binary_expr -> . expression NOT_EQUAL expression
    (130) binary_expr -> . expression EQUAL expression
    (131) binary_expr -> . expression LESS_EQUAL expression
    (132) binary_expr -> . expression LESS expression
    (133) binary_expr -> . expression GREATER_EQUAL expression
    (134) binary_expr -> . expression GREATER expression
    (135) unary_expr -> . unary_operation primary_expr
    (140) primary_expr -> . operand
    (141) primary_expr -> . call_expr
    (142) primary_expr -> . index_expr
    (143) primary_expr -> . cast_expr
    (144) primary_expr -> . new_expr
    (145) primary_expr -> . member_expr
    (146) primary_expr -> . lambda_expr
    (147) primary_expr -> . io_expr
    (136) unary_operation -> . NOT
    (137) unary_operation -> . LOGICAL_NOT
    (138) unary_operation -> . PLUS
    (139) unary_operation -> . MINUS
    (148) operand -> . INT
    (149) operand -> . HEXADECIMAL
    (150) operand -> . FLOAT
    (151) operand -> . DOUBLE
    (152) operand -> . STRING
    (153) operand -> . ID
    (154) operand -> . LPAREN expression RPAREN
    (161) call_expr -> . primary_expr LPAREN parameter_list_opt RPAREN
    (162) call_expr -> . primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN
    (156) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (157) cast_expr -> . LPAREN type_spec RPAREN expression
    (158) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (155) member_expr -> . primary_expr DOT ID
    (170) lambda_expr -> . FUNC function_sign block_statement
    (171) io_expr -> . in_out LESS type_spec GREATER LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . alias_type
    (26) type_spec -> . array_type
    (27) type_spec -> . reference_type
    (28) type_spec -> . function_type
    (172) in_out -> . IN
    (173) in_out -> . OUT
    (29) simple_type -> . VOID
    (30) simple_type -> . BOOL
    (31) simple_type -> . I8
    (32) simple_type -> . U8
    (33) simple_type -> . I16
    (34) simple_type -> . U16
    (35) simple_type -> . I32
    (36) simple_type -> . U32
    (37) simple_type -> . I64
    (38) simple_type -> . U64
    (39) simple_type -> . F16
    (40) simple_type -> . F32
    (41) simple_type -> . F64
    (42) complex_type -> . INTERFACEID generics_specialization_list_opt
    (43) complex_type -> . STRUCTID generics_specialization_list_opt
    (44) generic_type -> . GENERICID
    (45) alias_type -> . TYPEALIASID
    (46) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> . type_spec REF
    (50) function_type -> . function_sign
    (71) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (57) generics_type_list_opt -> . generics_type_list
    (58) generics_type_list_opt -> . empty
    (79) generics_type_list -> . LESS generics_type generics_type_comma_nest GREATER

  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          reduce using rule 174 (empty -> .)
    NOT             shift and go to state 72
    LOGICAL_NOT     shift and go to state 73
    PLUS            shift and go to state 60
    MINUS           shift and go to state 61
    INT             shift and go to state 74
    HEXADECIMAL     shift and go to state 75
    FLOAT           shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    ID              shift and go to state 79
    LPAREN          shift and go to state 47
    FUNC            shift and go to state 81
    IN              shift and go to state 91
    OUT             shift and go to state 92
    VOID            shift and go to state 93
    BOOL            shift and go to state 94
    I8              shift and go to state 95
    U8              shift and go to state 96
    I16             shift and go to state 97
    U16             shift and go to state 98
    I32             shift and go to state 99
    U32             shift and go to state 100
    I64             shift and go to state 101
    U64             shift and go to state 102
    F16             shift and go to state 103
    F32             shift and go to state 104
    F64             shift and go to state 105
    INTERFACEID     shift and go to state 106
    STRUCTID        shift and go to state 107
    GENERICID       shift and go to state 108
    TYPEALIASID     shift and go to state 109
    LESS            shift and go to state 62

  ! LPAREN          [ reduce using rule 174 (empty -> .) ]

    primary_expr                   shift and go to state 59
    type_spec                      shift and go to state 80
    parameter_list_opt             shift and go to state 318
    parameter_list                 shift and go to state 208
    empty                          shift and go to state 209
    expression                     shift and go to state 210
    assign_expr                    shift and go to state 56
    binary_expr                    shift and go to state 57
    unary_expr                     shift and go to state 58
    unary_operation                shift and go to state 63
    operand                        shift and go to state 64
    call_expr                      shift and go to state 65
    index_expr                     shift and go to state 66
    cast_expr                      shift and go to state 67
    new_expr                       shift and go to state 68
    member_expr                    shift and go to state 69
    lambda_expr                    shift and go to state 70
    io_expr                        shift and go to state 71
    function_sign                  shift and go to state 82
    in_out                         shift and go to state 83
    simple_type                    shift and go to state 84
    complex_type                   shift and go to state 85
    generic_type                   shift and go to state 86
    alias_type                     shift and go to state 87
    array_type                     shift and go to state 88
    reference_type                 shift and go to state 89
    function_type                  shift and go to state 90
    generics_type_list_opt         shift and go to state 110
    generics_type_list             shift and go to state 111

state 315

    (171) io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .

    LPAREN          reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    GENERICMARK     reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    LBRACKET        reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    DOT             reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    ASSIGN          reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    PLUS            reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    MINUS           reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    MUL             reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    DIV             reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    AND             reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    OR              reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    XOR             reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    MOD             reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    LSHIFT          reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    RSHIFT          reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    LOGICAL_OR      reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    LOGICAL_AND     reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    NOT_EQUAL       reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    EQUAL           reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    LESS_EQUAL      reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    LESS            reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    GREATER_EQUAL   reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    GREATER         reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    SEMICOLON       reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    RPAREN          reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    COMMA           reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)
    RBRACKET        reduce using rule 171 (io_expr -> in_out LESS type_spec GREATER LPAREN STRING RPAREN .)


state 316

    (70) member_declarator -> ID COLON type_spec . SEMICOLON
    (46) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (49) reference_type -> type_spec . REF

    SEMICOLON       shift and go to state 319
    LBRACKET        shift and go to state 165
    REF             shift and go to state 166


state 317

    (106) for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .

    LBRACE          reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    IF              reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    BREAK           reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    CONTINUE        reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    RETURN          reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    LET             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    CONST           reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    WHILE           reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    FOR             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    NOT             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    LOGICAL_NOT     reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    PLUS            reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    MINUS           reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    INT             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    HEXADECIMAL     reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    FLOAT           reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    DOUBLE          reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    STRING          reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    ID              reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    LPAREN          reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    FUNC            reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    IN              reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    OUT             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    VOID            reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    BOOL            reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    I8              reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    U8              reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    I16             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    U16             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    I32             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    U32             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    I64             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    U64             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    F16             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    F32             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    F64             reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    INTERFACEID     reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    STRUCTID        reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    GENERICID       reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    TYPEALIASID     reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    LESS            reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    SEMICOLON       reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    RBRACE          reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    ELSE            reduce using rule 106 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)


state 318

    (162) call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt . RPAREN

    RPAREN          shift and go to state 320


state 319

    (70) member_declarator -> ID COLON type_spec SEMICOLON .

    ID              reduce using rule 70 (member_declarator -> ID COLON type_spec SEMICOLON .)
    FUNC            reduce using rule 70 (member_declarator -> ID COLON type_spec SEMICOLON .)
    RBRACE          reduce using rule 70 (member_declarator -> ID COLON type_spec SEMICOLON .)


state 320

    (162) call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .

    LPAREN          reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    GENERICMARK     reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    LBRACKET        reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    DOT             reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    ASSIGN          reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    PLUS            reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    MINUS           reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    MUL             reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    DIV             reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    AND             reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    OR              reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    XOR             reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    MOD             reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    LSHIFT          reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    RSHIFT          reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    LOGICAL_OR      reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    LOGICAL_AND     reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    NOT_EQUAL       reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    EQUAL           reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    LESS_EQUAL      reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    LESS            reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    GREATER_EQUAL   reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    GREATER         reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    SEMICOLON       reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    RPAREN          reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    COMMA           reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)
    RBRACKET        reduce using rule 162 (call_expr -> primary_expr GENERICMARK LESS type_spec type_spec_comma_nest GREATER LPAREN parameter_list_opt RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 26 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 35 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 47 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 53 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 59 resolved as shift
WARNING: shift/reduce conflict for GENERICMARK in state 59 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 59 resolved as shift
WARNING: shift/reduce conflict for DOT in state 59 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 63 resolved as shift
WARNING: shift/reduce conflict for LESS in state 106 resolved as shift
WARNING: shift/reduce conflict for LESS in state 107 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 129 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 132 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 133 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 134 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 135 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 136 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 137 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 138 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 139 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 140 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 141 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 142 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 143 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 144 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 145 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 146 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 147 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 148 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 149 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 150 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 155 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 156 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 157 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 159 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 163 resolved as shift
WARNING: shift/reduce conflict for GENERICMARK in state 163 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 163 resolved as shift
WARNING: shift/reduce conflict for DOT in state 163 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 164 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 175 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 182 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 183 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 183 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 183 resolved as shift
WARNING: shift/reduce conflict for MUL in state 183 resolved as shift
WARNING: shift/reduce conflict for DIV in state 183 resolved as shift
WARNING: shift/reduce conflict for AND in state 183 resolved as shift
WARNING: shift/reduce conflict for OR in state 183 resolved as shift
WARNING: shift/reduce conflict for XOR in state 183 resolved as shift
WARNING: shift/reduce conflict for MOD in state 183 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 183 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 183 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 183 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 183 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for LESS in state 183 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 183 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 183 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 204 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 237 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 238 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 238 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 238 resolved as shift
WARNING: shift/reduce conflict for MUL in state 238 resolved as shift
WARNING: shift/reduce conflict for DIV in state 238 resolved as shift
WARNING: shift/reduce conflict for AND in state 238 resolved as shift
WARNING: shift/reduce conflict for OR in state 238 resolved as shift
WARNING: shift/reduce conflict for XOR in state 238 resolved as shift
WARNING: shift/reduce conflict for MOD in state 238 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 238 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 238 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 238 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 238 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 238 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 238 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 238 resolved as shift
WARNING: shift/reduce conflict for LESS in state 238 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 238 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 238 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 239 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 243 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 270 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 272 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 298 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 305 resolved as shift
WARNING: shift/reduce conflict for REF in state 305 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 313 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 314 resolved as shift
