Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    GENERICS
    SAMPLER

Grammar

Rule 0     S' -> start
Rule 1     start -> translation_unit
Rule 2     translation_unit -> block_decl translation_unit
Rule 3     translation_unit -> function_def translation_unit
Rule 4     translation_unit -> empty
Rule 5     block_decl -> type_decl SEMICOLON
Rule 6     block_decl -> variable_decl SEMICOLON
Rule 7     block_decl -> constant_decl SEMICOLON
Rule 8     block_decl -> function_decl SEMICOLON
Rule 9     type_decl -> type_alias_decl
Rule 10    type_decl -> struct_decl
Rule 11    type_decl -> interface_decl
Rule 12    type_alias_decl -> TYPE ID ASSIGN type_spec
Rule 13    variable_decl -> LET declarator declarator_nest
Rule 14    declarator_nest -> COMMA declarator declarator_nest
Rule 15    declarator_nest -> empty
Rule 16    constant_decl -> CONST declarator declarator_nest
Rule 17    declarator -> ID type_spec_colon_opt ASSIGN expression
Rule 18    type_spec_colon_opt -> COLON type_spec
Rule 19    type_spec_colon_opt -> empty
Rule 20    function_decl -> FUNC ID function_sign
Rule 21    function_def -> function_decl block_statement
Rule 22    type_spec -> simple_type
Rule 23    type_spec -> complex_type
Rule 24    type_spec -> generic_type
Rule 25    type_spec -> array_type
Rule 26    type_spec -> reference_type
Rule 27    type_spec -> function_type
Rule 28    simple_type -> VOID
Rule 29    simple_type -> BOOL
Rule 30    simple_type -> I8
Rule 31    simple_type -> U8
Rule 32    simple_type -> I16
Rule 33    simple_type -> U16
Rule 34    simple_type -> I32
Rule 35    simple_type -> U32
Rule 36    simple_type -> I64
Rule 37    simple_type -> U64
Rule 38    simple_type -> F16
Rule 39    simple_type -> F32
Rule 40    simple_type -> F64
Rule 41    complex_type -> ID generics_specialization_list_opt
Rule 42    generic_type -> ID
Rule 43    array_type -> type_spec LBRACKET int_literal_opt RBRACKET
Rule 44    int_literal_opt -> INT
Rule 45    int_literal_opt -> empty
Rule 46    reference_type -> type_spec REF
Rule 47    function_type -> function_sign
Rule 48    struct_decl -> STRUCT ID generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE
Rule 49    complex_type_colon_opt -> COLON complex_type
Rule 50    complex_type_colon_opt -> empty
Rule 51    interface_decl -> INTERFACE ID generics_type_list_opt LBRACE interface_member_decl_nest RBRACE
Rule 52    generics_type_list_opt -> generics_type_list
Rule 53    generics_type_list_opt -> empty
Rule 54    member_decl_nest -> member_decl member_decl_nest
Rule 55    member_decl_nest -> empty
Rule 56    interface_member_decl_nest -> interface_member_decl SEMICOLON interface_member_decl_nest
Rule 57    interface_member_decl_nest -> empty
Rule 58    member_decl -> member_declarator SEMICOLON
Rule 59    member_decl -> function_def
Rule 60    member_decl -> type_function_def
Rule 61    type_function_def -> type_function_decl block_statement
Rule 62    interface_member_decl -> member_declarator
Rule 63    interface_member_decl -> function_decl
Rule 64    interface_member_decl -> type_function_decl
Rule 65    type_function_decl -> FUNC type_spec function_sign
Rule 66    member_declarator -> ID type_spec_colon_opt
Rule 67    function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
Rule 68    parameter_decl_list_opt -> parameter_decl parameter_decl_comma_nest
Rule 69    parameter_decl_list_opt -> empty
Rule 70    type_spec_assigntype_opt -> ASSIGNTYPE type_spec
Rule 71    type_spec_assigntype_opt -> empty
Rule 72    parameter_decl_comma_nest -> COMMA parameter_decl parameter_decl_comma_nest
Rule 73    parameter_decl_comma_nest -> empty
Rule 74    parameter_decl -> ID type_spec_colon_opt
Rule 75    generics_type_list -> LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
Rule 76    generics_type_comma_nest -> COMMA generics_type generics_type_comma_nest
Rule 77    generics_type_comma_nest -> empty
Rule 78    generics_type -> ID generics_type_range_colon_opt
Rule 79    generics_type_range_colon_opt -> COLON generics_type_range
Rule 80    generics_type_range_colon_opt -> empty
Rule 81    generics_type_range -> complex_type
Rule 82    statement -> decl_statement
Rule 83    statement -> block_statement
Rule 84    statement -> expression_statement
Rule 85    statement -> if_statement
Rule 86    statement -> iteration_statement
Rule 87    statement -> jump_statement
Rule 88    decl_statement -> variable_decl SEMICOLON
Rule 89    decl_statement -> constant_decl SEMICOLON
Rule 90    block_statement -> LBRACE statement_nest RBRACE
Rule 91    statement_nest -> statement statement_nest
Rule 92    statement_nest -> empty
Rule 93    expression_statement -> expression_opt SEMICOLON
Rule 94    expression_opt -> expression
Rule 95    expression_opt -> empty
Rule 96    if_statement -> IF LPAREN expression RPAREN statement statement_else_opt
Rule 97    statement_else_opt -> ELSE statement
Rule 98    statement_else_opt -> empty
Rule 99    iteration_statement -> while_clause
Rule 100   iteration_statement -> for_clause
Rule 101   while_clause -> WHILE LPAREN expression RPAREN statement
Rule 102   for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
Rule 103   for_init_statement -> expression_statement
Rule 104   for_init_statement -> decl_statement
Rule 105   jump_statement -> BREAK SEMICOLON
Rule 106   jump_statement -> CONTINUE SEMICOLON
Rule 107   jump_statement -> RETURN expression_opt SEMICOLON
Rule 108   expression -> assign_expr
Rule 109   expression -> binary_expr
Rule 110   expression -> unary_expr
Rule 111   assign_expr -> expression ASSIGN expression
Rule 112   binary_expr -> expression PLUS expression
Rule 113   binary_expr -> expression MINUS expression
Rule 114   binary_expr -> expression MUL expression
Rule 115   binary_expr -> expression DIV expression
Rule 116   binary_expr -> expression AND expression
Rule 117   binary_expr -> expression OR expression
Rule 118   binary_expr -> expression XOR expression
Rule 119   binary_expr -> expression MOD expression
Rule 120   binary_expr -> expression LSHIFT expression
Rule 121   binary_expr -> expression RSHIFT expression
Rule 122   binary_expr -> expression LOGICAL_OR expression
Rule 123   binary_expr -> expression LOGICAL_AND expression
Rule 124   binary_expr -> expression NOT_EQUAL expression
Rule 125   binary_expr -> expression EQUAL expression
Rule 126   binary_expr -> expression LESS_EQUAL expression
Rule 127   binary_expr -> expression LESS expression
Rule 128   binary_expr -> expression GREATER_EQUAL expression
Rule 129   binary_expr -> expression GREATER expression
Rule 130   unary_expr -> unary_operation_opt primary_expr
Rule 131   unary_operation_opt -> NOT
Rule 132   unary_operation_opt -> LOGICAL_NOT
Rule 133   unary_operation_opt -> PLUS
Rule 134   unary_operation_opt -> MINUS
Rule 135   unary_operation_opt -> empty
Rule 136   primary_expr -> operand
Rule 137   primary_expr -> call_expr
Rule 138   primary_expr -> index_expr
Rule 139   primary_expr -> cast_expr
Rule 140   primary_expr -> new_expr
Rule 141   primary_expr -> member_expr
Rule 142   primary_expr -> io_expr
Rule 143   operand -> INT
Rule 144   operand -> HEXADECIMAL
Rule 145   operand -> FLOAT
Rule 146   operand -> DOUBLE
Rule 147   operand -> STRING
Rule 148   operand -> ID
Rule 149   operand -> LPAREN expression RPAREN
Rule 150   member_expr -> ID DOT ID
Rule 151   index_expr -> primary_expr LBRACKET expression RBRACKET
Rule 152   cast_expr -> LPAREN type_spec RPAREN expression
Rule 153   new_expr -> type_spec LPAREN parameter_list_opt RPAREN
Rule 154   parameter_list_opt -> parameter_list
Rule 155   parameter_list_opt -> empty
Rule 156   call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN
Rule 157   generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET
Rule 158   generics_specialization_list_opt -> empty
Rule 159   type_spec_comma_nest -> COMMA type_spec type_spec_comma_nest
Rule 160   type_spec_comma_nest -> empty
Rule 161   parameter_list -> expression expression_comma_nest
Rule 162   expression_comma_nest -> COMMA expression expression_comma_nest
Rule 163   expression_comma_nest -> empty
Rule 164   io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN
Rule 165   in_out -> IN
Rule 166   in_out -> OUT
Rule 167   empty -> <empty>

Terminals, with rules where they appear

AND                  : 116
ASSIGN               : 12 17 111
ASSIGNTYPE           : 70
BOOL                 : 29
BREAK                : 105
COLON                : 18 49 79
COMMA                : 14 72 76 159 162
CONST                : 16
CONTINUE             : 106
DIV                  : 115
DOT                  : 150
DOUBLE               : 146
ELSE                 : 97
EQUAL                : 125
F16                  : 38
F32                  : 39
F64                  : 40
FLOAT                : 145
FOR                  : 102
FUNC                 : 20 65
GENERICS             : 
GREATER              : 129
GREATER_EQUAL        : 128
HEXADECIMAL          : 144
I16                  : 32
I32                  : 34
I64                  : 36
I8                   : 30
ID                   : 12 17 20 41 42 48 51 66 74 78 148 150 150
IF                   : 96
IN                   : 165
INT                  : 44 143
INTERFACE            : 51
LANGRBRACKET         : 75 157 164
LBRACE               : 48 51 90
LBRACKET             : 43 151
LESS                 : 127
LESS_EQUAL           : 126
LET                  : 13
LOGICAL_AND          : 123
LOGICAL_NOT          : 132
LOGICAL_OR           : 122
LPAREN               : 67 96 101 102 149 152 153 156 164
LSHIFT               : 120
MINUS                : 113 134
MOD                  : 119
MUL                  : 114
NOT                  : 131
NOT_EQUAL            : 124
OR                   : 117
OUT                  : 166
PLUS                 : 112 133
RANGRBRACKET         : 75 157 164
RBRACE               : 48 51 90
RBRACKET             : 43 151
REF                  : 46
RETURN               : 107
RPAREN               : 67 96 101 102 149 152 153 156 164
RSHIFT               : 121
SAMPLER              : 
SEMICOLON            : 5 6 7 8 56 58 88 89 93 102 105 106 107
STRING               : 147 164
STRUCT               : 48
TYPE                 : 12
U16                  : 33
U32                  : 35
U64                  : 37
U8                   : 31
VOID                 : 28
WHILE                : 101
XOR                  : 118
error                : 

Nonterminals, with rules where they appear

array_type           : 25
assign_expr          : 108
binary_expr          : 109
block_decl           : 2
block_statement      : 21 61 83
call_expr            : 137
cast_expr            : 139
complex_type         : 23 49 81
complex_type_colon_opt : 48
constant_decl        : 7 89
decl_statement       : 82 104
declarator           : 13 14 16
declarator_nest      : 13 14 16
empty                : 4 15 19 45 50 53 55 57 69 71 73 77 80 92 95 98 135 155 158 160 163
expression           : 17 94 96 101 102 111 111 112 112 113 113 114 114 115 115 116 116 117 117 118 118 119 119 120 120 121 121 122 122 123 123 124 124 125 125 126 126 127 127 128 128 129 129 149 151 152 161 162
expression_comma_nest : 161 162
expression_opt       : 93 102 107
expression_statement : 84 103
for_clause           : 100
for_init_statement   : 102
function_decl        : 8 21 63
function_def         : 3 59
function_sign        : 20 47 65
function_type        : 27
generic_type         : 24
generics_specialization_list_opt : 41 156
generics_type        : 75 76
generics_type_comma_nest : 75 76
generics_type_list   : 52
generics_type_list_opt : 48 51 67
generics_type_range  : 79
generics_type_range_colon_opt : 78
if_statement         : 85
in_out               : 164
index_expr           : 138
int_literal_opt      : 43
interface_decl       : 11
interface_member_decl : 56
interface_member_decl_nest : 51 56
io_expr              : 142
iteration_statement  : 86
jump_statement       : 87
member_decl          : 54
member_decl_nest     : 48 54
member_declarator    : 58 62
member_expr          : 141
new_expr             : 140
operand              : 136
parameter_decl       : 68 72
parameter_decl_comma_nest : 68 72
parameter_decl_list_opt : 67
parameter_list       : 154
parameter_list_opt   : 153 156
primary_expr         : 130 151 156
reference_type       : 26
simple_type          : 22
start                : 0
statement            : 91 96 97 101 102
statement_else_opt   : 96
statement_nest       : 90 91
struct_decl          : 10
translation_unit     : 1 2 3
type_alias_decl      : 9
type_decl            : 5
type_function_decl   : 61 64
type_function_def    : 60
type_spec            : 12 18 43 46 65 70 152 153 157 159 164
type_spec_assigntype_opt : 67
type_spec_colon_opt  : 17 66 74
type_spec_comma_nest : 157 159
unary_expr           : 110
unary_operation_opt  : 130
variable_decl        : 6 88
while_clause         : 99

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . translation_unit
    (2) translation_unit -> . block_decl translation_unit
    (3) translation_unit -> . function_def translation_unit
    (4) translation_unit -> . empty
    (5) block_decl -> . type_decl SEMICOLON
    (6) block_decl -> . variable_decl SEMICOLON
    (7) block_decl -> . constant_decl SEMICOLON
    (8) block_decl -> . function_decl SEMICOLON
    (21) function_def -> . function_decl block_statement
    (167) empty -> .
    (9) type_decl -> . type_alias_decl
    (10) type_decl -> . struct_decl
    (11) type_decl -> . interface_decl
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (20) function_decl -> . FUNC ID function_sign
    (12) type_alias_decl -> . TYPE ID ASSIGN type_spec
    (48) struct_decl -> . STRUCT ID generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE
    (51) interface_decl -> . INTERFACE ID generics_type_list_opt LBRACE interface_member_decl_nest RBRACE

    $end            reduce using rule 167 (empty -> .)
    LET             shift and go to state 13
    CONST           shift and go to state 14
    FUNC            shift and go to state 15
    TYPE            shift and go to state 16
    STRUCT          shift and go to state 17
    INTERFACE       shift and go to state 18

    start                          shift and go to state 1
    translation_unit               shift and go to state 2
    block_decl                     shift and go to state 3
    function_def                   shift and go to state 4
    empty                          shift and go to state 5
    type_decl                      shift and go to state 6
    variable_decl                  shift and go to state 7
    constant_decl                  shift and go to state 8
    function_decl                  shift and go to state 9
    type_alias_decl                shift and go to state 10
    struct_decl                    shift and go to state 11
    interface_decl                 shift and go to state 12

state 1

    (0) S' -> start .



state 2

    (1) start -> translation_unit .

    $end            reduce using rule 1 (start -> translation_unit .)


state 3

    (2) translation_unit -> block_decl . translation_unit
    (2) translation_unit -> . block_decl translation_unit
    (3) translation_unit -> . function_def translation_unit
    (4) translation_unit -> . empty
    (5) block_decl -> . type_decl SEMICOLON
    (6) block_decl -> . variable_decl SEMICOLON
    (7) block_decl -> . constant_decl SEMICOLON
    (8) block_decl -> . function_decl SEMICOLON
    (21) function_def -> . function_decl block_statement
    (167) empty -> .
    (9) type_decl -> . type_alias_decl
    (10) type_decl -> . struct_decl
    (11) type_decl -> . interface_decl
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (20) function_decl -> . FUNC ID function_sign
    (12) type_alias_decl -> . TYPE ID ASSIGN type_spec
    (48) struct_decl -> . STRUCT ID generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE
    (51) interface_decl -> . INTERFACE ID generics_type_list_opt LBRACE interface_member_decl_nest RBRACE

    $end            reduce using rule 167 (empty -> .)
    LET             shift and go to state 13
    CONST           shift and go to state 14
    FUNC            shift and go to state 15
    TYPE            shift and go to state 16
    STRUCT          shift and go to state 17
    INTERFACE       shift and go to state 18

    block_decl                     shift and go to state 3
    translation_unit               shift and go to state 19
    function_def                   shift and go to state 4
    empty                          shift and go to state 5
    type_decl                      shift and go to state 6
    variable_decl                  shift and go to state 7
    constant_decl                  shift and go to state 8
    function_decl                  shift and go to state 9
    type_alias_decl                shift and go to state 10
    struct_decl                    shift and go to state 11
    interface_decl                 shift and go to state 12

state 4

    (3) translation_unit -> function_def . translation_unit
    (2) translation_unit -> . block_decl translation_unit
    (3) translation_unit -> . function_def translation_unit
    (4) translation_unit -> . empty
    (5) block_decl -> . type_decl SEMICOLON
    (6) block_decl -> . variable_decl SEMICOLON
    (7) block_decl -> . constant_decl SEMICOLON
    (8) block_decl -> . function_decl SEMICOLON
    (21) function_def -> . function_decl block_statement
    (167) empty -> .
    (9) type_decl -> . type_alias_decl
    (10) type_decl -> . struct_decl
    (11) type_decl -> . interface_decl
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (20) function_decl -> . FUNC ID function_sign
    (12) type_alias_decl -> . TYPE ID ASSIGN type_spec
    (48) struct_decl -> . STRUCT ID generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE
    (51) interface_decl -> . INTERFACE ID generics_type_list_opt LBRACE interface_member_decl_nest RBRACE

    $end            reduce using rule 167 (empty -> .)
    LET             shift and go to state 13
    CONST           shift and go to state 14
    FUNC            shift and go to state 15
    TYPE            shift and go to state 16
    STRUCT          shift and go to state 17
    INTERFACE       shift and go to state 18

    function_def                   shift and go to state 4
    translation_unit               shift and go to state 20
    block_decl                     shift and go to state 3
    empty                          shift and go to state 5
    type_decl                      shift and go to state 6
    variable_decl                  shift and go to state 7
    constant_decl                  shift and go to state 8
    function_decl                  shift and go to state 9
    type_alias_decl                shift and go to state 10
    struct_decl                    shift and go to state 11
    interface_decl                 shift and go to state 12

state 5

    (4) translation_unit -> empty .

    $end            reduce using rule 4 (translation_unit -> empty .)


state 6

    (5) block_decl -> type_decl . SEMICOLON

    SEMICOLON       shift and go to state 21


state 7

    (6) block_decl -> variable_decl . SEMICOLON

    SEMICOLON       shift and go to state 22


state 8

    (7) block_decl -> constant_decl . SEMICOLON

    SEMICOLON       shift and go to state 23


state 9

    (8) block_decl -> function_decl . SEMICOLON
    (21) function_def -> function_decl . block_statement
    (90) block_statement -> . LBRACE statement_nest RBRACE

    SEMICOLON       shift and go to state 24
    LBRACE          shift and go to state 26

    block_statement                shift and go to state 25

state 10

    (9) type_decl -> type_alias_decl .

    SEMICOLON       reduce using rule 9 (type_decl -> type_alias_decl .)


state 11

    (10) type_decl -> struct_decl .

    SEMICOLON       reduce using rule 10 (type_decl -> struct_decl .)


state 12

    (11) type_decl -> interface_decl .

    SEMICOLON       reduce using rule 11 (type_decl -> interface_decl .)


state 13

    (13) variable_decl -> LET . declarator declarator_nest
    (17) declarator -> . ID type_spec_colon_opt ASSIGN expression

    ID              shift and go to state 28

    declarator                     shift and go to state 27

state 14

    (16) constant_decl -> CONST . declarator declarator_nest
    (17) declarator -> . ID type_spec_colon_opt ASSIGN expression

    ID              shift and go to state 28

    declarator                     shift and go to state 29

state 15

    (20) function_decl -> FUNC . ID function_sign

    ID              shift and go to state 30


state 16

    (12) type_alias_decl -> TYPE . ID ASSIGN type_spec

    ID              shift and go to state 31


state 17

    (48) struct_decl -> STRUCT . ID generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE

    ID              shift and go to state 32


state 18

    (51) interface_decl -> INTERFACE . ID generics_type_list_opt LBRACE interface_member_decl_nest RBRACE

    ID              shift and go to state 33


state 19

    (2) translation_unit -> block_decl translation_unit .

    $end            reduce using rule 2 (translation_unit -> block_decl translation_unit .)


state 20

    (3) translation_unit -> function_def translation_unit .

    $end            reduce using rule 3 (translation_unit -> function_def translation_unit .)


state 21

    (5) block_decl -> type_decl SEMICOLON .

    LET             reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    CONST           reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    FUNC            reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    TYPE            reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    STRUCT          reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    INTERFACE       reduce using rule 5 (block_decl -> type_decl SEMICOLON .)
    $end            reduce using rule 5 (block_decl -> type_decl SEMICOLON .)


state 22

    (6) block_decl -> variable_decl SEMICOLON .

    LET             reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    CONST           reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    FUNC            reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    TYPE            reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    STRUCT          reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    INTERFACE       reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)
    $end            reduce using rule 6 (block_decl -> variable_decl SEMICOLON .)


state 23

    (7) block_decl -> constant_decl SEMICOLON .

    LET             reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    CONST           reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    FUNC            reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    TYPE            reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    STRUCT          reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    INTERFACE       reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)
    $end            reduce using rule 7 (block_decl -> constant_decl SEMICOLON .)


state 24

    (8) block_decl -> function_decl SEMICOLON .

    LET             reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    CONST           reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    FUNC            reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    TYPE            reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    STRUCT          reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    INTERFACE       reduce using rule 8 (block_decl -> function_decl SEMICOLON .)
    $end            reduce using rule 8 (block_decl -> function_decl SEMICOLON .)


state 25

    (21) function_def -> function_decl block_statement .

    LET             reduce using rule 21 (function_def -> function_decl block_statement .)
    CONST           reduce using rule 21 (function_def -> function_decl block_statement .)
    FUNC            reduce using rule 21 (function_def -> function_decl block_statement .)
    TYPE            reduce using rule 21 (function_def -> function_decl block_statement .)
    STRUCT          reduce using rule 21 (function_def -> function_decl block_statement .)
    INTERFACE       reduce using rule 21 (function_def -> function_decl block_statement .)
    $end            reduce using rule 21 (function_def -> function_decl block_statement .)
    ID              reduce using rule 21 (function_def -> function_decl block_statement .)
    RBRACE          reduce using rule 21 (function_def -> function_decl block_statement .)


state 26

    (90) block_statement -> LBRACE . statement_nest RBRACE
    (91) statement_nest -> . statement statement_nest
    (92) statement_nest -> . empty
    (82) statement -> . decl_statement
    (83) statement -> . block_statement
    (84) statement -> . expression_statement
    (85) statement -> . if_statement
    (86) statement -> . iteration_statement
    (87) statement -> . jump_statement
    (167) empty -> .
    (88) decl_statement -> . variable_decl SEMICOLON
    (89) decl_statement -> . constant_decl SEMICOLON
    (90) block_statement -> . LBRACE statement_nest RBRACE
    (93) expression_statement -> . expression_opt SEMICOLON
    (96) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (99) iteration_statement -> . while_clause
    (100) iteration_statement -> . for_clause
    (105) jump_statement -> . BREAK SEMICOLON
    (106) jump_statement -> . CONTINUE SEMICOLON
    (107) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (94) expression_opt -> . expression
    (95) expression_opt -> . empty
    (101) while_clause -> . WHILE LPAREN expression RPAREN statement
    (102) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty

    RBRACE          reduce using rule 167 (empty -> .)
    SEMICOLON       reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 50
    CONTINUE        shift and go to state 51
    RETURN          shift and go to state 52
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    statement_nest                 shift and go to state 34
    statement                      shift and go to state 35
    empty                          shift and go to state 36
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    expression_opt                 shift and go to state 45
    expression                     shift and go to state 47
    while_clause                   shift and go to state 48
    for_clause                     shift and go to state 49
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60

state 27

    (13) variable_decl -> LET declarator . declarator_nest
    (14) declarator_nest -> . COMMA declarator declarator_nest
    (15) declarator_nest -> . empty
    (167) empty -> .

    COMMA           shift and go to state 64
    SEMICOLON       reduce using rule 167 (empty -> .)

    declarator_nest                shift and go to state 63
    empty                          shift and go to state 65

state 28

    (17) declarator -> ID . type_spec_colon_opt ASSIGN expression
    (18) type_spec_colon_opt -> . COLON type_spec
    (19) type_spec_colon_opt -> . empty
    (167) empty -> .

    COLON           shift and go to state 67
    ASSIGN          reduce using rule 167 (empty -> .)

    type_spec_colon_opt            shift and go to state 66
    empty                          shift and go to state 68

state 29

    (16) constant_decl -> CONST declarator . declarator_nest
    (14) declarator_nest -> . COMMA declarator declarator_nest
    (15) declarator_nest -> . empty
    (167) empty -> .

    COMMA           shift and go to state 64
    SEMICOLON       reduce using rule 167 (empty -> .)

    declarator_nest                shift and go to state 69
    empty                          shift and go to state 65

state 30

    (20) function_decl -> FUNC ID . function_sign
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    LANGRBRACKET    shift and go to state 74
    LPAREN          reduce using rule 167 (empty -> .)

    function_sign                  shift and go to state 70
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 31

    (12) type_alias_decl -> TYPE ID . ASSIGN type_spec

    ASSIGN          shift and go to state 75


state 32

    (48) struct_decl -> STRUCT ID . generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    LANGRBRACKET    shift and go to state 74
    COLON           reduce using rule 167 (empty -> .)
    LBRACE          reduce using rule 167 (empty -> .)

    generics_type_list_opt         shift and go to state 76
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 33

    (51) interface_decl -> INTERFACE ID . generics_type_list_opt LBRACE interface_member_decl_nest RBRACE
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    LANGRBRACKET    shift and go to state 74
    LBRACE          reduce using rule 167 (empty -> .)

    generics_type_list_opt         shift and go to state 77
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 34

    (90) block_statement -> LBRACE statement_nest . RBRACE

    RBRACE          shift and go to state 78


state 35

    (91) statement_nest -> statement . statement_nest
    (91) statement_nest -> . statement statement_nest
    (92) statement_nest -> . empty
    (82) statement -> . decl_statement
    (83) statement -> . block_statement
    (84) statement -> . expression_statement
    (85) statement -> . if_statement
    (86) statement -> . iteration_statement
    (87) statement -> . jump_statement
    (167) empty -> .
    (88) decl_statement -> . variable_decl SEMICOLON
    (89) decl_statement -> . constant_decl SEMICOLON
    (90) block_statement -> . LBRACE statement_nest RBRACE
    (93) expression_statement -> . expression_opt SEMICOLON
    (96) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (99) iteration_statement -> . while_clause
    (100) iteration_statement -> . for_clause
    (105) jump_statement -> . BREAK SEMICOLON
    (106) jump_statement -> . CONTINUE SEMICOLON
    (107) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (94) expression_opt -> . expression
    (95) expression_opt -> . empty
    (101) while_clause -> . WHILE LPAREN expression RPAREN statement
    (102) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty

    RBRACE          reduce using rule 167 (empty -> .)
    SEMICOLON       reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 50
    CONTINUE        shift and go to state 51
    RETURN          shift and go to state 52
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    statement                      shift and go to state 35
    statement_nest                 shift and go to state 79
    empty                          shift and go to state 36
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    expression_opt                 shift and go to state 45
    expression                     shift and go to state 47
    while_clause                   shift and go to state 48
    for_clause                     shift and go to state 49
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60

state 36

    (92) statement_nest -> empty .
    (95) expression_opt -> empty .
    (135) unary_operation_opt -> empty .

    RBRACE          reduce using rule 92 (statement_nest -> empty .)
    SEMICOLON       reduce using rule 95 (expression_opt -> empty .)
    INT             reduce using rule 135 (unary_operation_opt -> empty .)
    HEXADECIMAL     reduce using rule 135 (unary_operation_opt -> empty .)
    FLOAT           reduce using rule 135 (unary_operation_opt -> empty .)
    DOUBLE          reduce using rule 135 (unary_operation_opt -> empty .)
    STRING          reduce using rule 135 (unary_operation_opt -> empty .)
    ID              reduce using rule 135 (unary_operation_opt -> empty .)
    LPAREN          reduce using rule 135 (unary_operation_opt -> empty .)
    IN              reduce using rule 135 (unary_operation_opt -> empty .)
    OUT             reduce using rule 135 (unary_operation_opt -> empty .)
    VOID            reduce using rule 135 (unary_operation_opt -> empty .)
    BOOL            reduce using rule 135 (unary_operation_opt -> empty .)
    I8              reduce using rule 135 (unary_operation_opt -> empty .)
    U8              reduce using rule 135 (unary_operation_opt -> empty .)
    I16             reduce using rule 135 (unary_operation_opt -> empty .)
    U16             reduce using rule 135 (unary_operation_opt -> empty .)
    I32             reduce using rule 135 (unary_operation_opt -> empty .)
    U32             reduce using rule 135 (unary_operation_opt -> empty .)
    I64             reduce using rule 135 (unary_operation_opt -> empty .)
    U64             reduce using rule 135 (unary_operation_opt -> empty .)
    F16             reduce using rule 135 (unary_operation_opt -> empty .)
    F32             reduce using rule 135 (unary_operation_opt -> empty .)
    F64             reduce using rule 135 (unary_operation_opt -> empty .)
    LANGRBRACKET    reduce using rule 135 (unary_operation_opt -> empty .)


state 37

    (82) statement -> decl_statement .

    LBRACE          reduce using rule 82 (statement -> decl_statement .)
    IF              reduce using rule 82 (statement -> decl_statement .)
    BREAK           reduce using rule 82 (statement -> decl_statement .)
    CONTINUE        reduce using rule 82 (statement -> decl_statement .)
    RETURN          reduce using rule 82 (statement -> decl_statement .)
    LET             reduce using rule 82 (statement -> decl_statement .)
    CONST           reduce using rule 82 (statement -> decl_statement .)
    WHILE           reduce using rule 82 (statement -> decl_statement .)
    FOR             reduce using rule 82 (statement -> decl_statement .)
    NOT             reduce using rule 82 (statement -> decl_statement .)
    LOGICAL_NOT     reduce using rule 82 (statement -> decl_statement .)
    PLUS            reduce using rule 82 (statement -> decl_statement .)
    MINUS           reduce using rule 82 (statement -> decl_statement .)
    SEMICOLON       reduce using rule 82 (statement -> decl_statement .)
    INT             reduce using rule 82 (statement -> decl_statement .)
    HEXADECIMAL     reduce using rule 82 (statement -> decl_statement .)
    FLOAT           reduce using rule 82 (statement -> decl_statement .)
    DOUBLE          reduce using rule 82 (statement -> decl_statement .)
    STRING          reduce using rule 82 (statement -> decl_statement .)
    ID              reduce using rule 82 (statement -> decl_statement .)
    LPAREN          reduce using rule 82 (statement -> decl_statement .)
    IN              reduce using rule 82 (statement -> decl_statement .)
    OUT             reduce using rule 82 (statement -> decl_statement .)
    VOID            reduce using rule 82 (statement -> decl_statement .)
    BOOL            reduce using rule 82 (statement -> decl_statement .)
    I8              reduce using rule 82 (statement -> decl_statement .)
    U8              reduce using rule 82 (statement -> decl_statement .)
    I16             reduce using rule 82 (statement -> decl_statement .)
    U16             reduce using rule 82 (statement -> decl_statement .)
    I32             reduce using rule 82 (statement -> decl_statement .)
    U32             reduce using rule 82 (statement -> decl_statement .)
    I64             reduce using rule 82 (statement -> decl_statement .)
    U64             reduce using rule 82 (statement -> decl_statement .)
    F16             reduce using rule 82 (statement -> decl_statement .)
    F32             reduce using rule 82 (statement -> decl_statement .)
    F64             reduce using rule 82 (statement -> decl_statement .)
    LANGRBRACKET    reduce using rule 82 (statement -> decl_statement .)
    RBRACE          reduce using rule 82 (statement -> decl_statement .)
    ELSE            reduce using rule 82 (statement -> decl_statement .)


state 38

    (83) statement -> block_statement .

    LBRACE          reduce using rule 83 (statement -> block_statement .)
    IF              reduce using rule 83 (statement -> block_statement .)
    BREAK           reduce using rule 83 (statement -> block_statement .)
    CONTINUE        reduce using rule 83 (statement -> block_statement .)
    RETURN          reduce using rule 83 (statement -> block_statement .)
    LET             reduce using rule 83 (statement -> block_statement .)
    CONST           reduce using rule 83 (statement -> block_statement .)
    WHILE           reduce using rule 83 (statement -> block_statement .)
    FOR             reduce using rule 83 (statement -> block_statement .)
    NOT             reduce using rule 83 (statement -> block_statement .)
    LOGICAL_NOT     reduce using rule 83 (statement -> block_statement .)
    PLUS            reduce using rule 83 (statement -> block_statement .)
    MINUS           reduce using rule 83 (statement -> block_statement .)
    SEMICOLON       reduce using rule 83 (statement -> block_statement .)
    INT             reduce using rule 83 (statement -> block_statement .)
    HEXADECIMAL     reduce using rule 83 (statement -> block_statement .)
    FLOAT           reduce using rule 83 (statement -> block_statement .)
    DOUBLE          reduce using rule 83 (statement -> block_statement .)
    STRING          reduce using rule 83 (statement -> block_statement .)
    ID              reduce using rule 83 (statement -> block_statement .)
    LPAREN          reduce using rule 83 (statement -> block_statement .)
    IN              reduce using rule 83 (statement -> block_statement .)
    OUT             reduce using rule 83 (statement -> block_statement .)
    VOID            reduce using rule 83 (statement -> block_statement .)
    BOOL            reduce using rule 83 (statement -> block_statement .)
    I8              reduce using rule 83 (statement -> block_statement .)
    U8              reduce using rule 83 (statement -> block_statement .)
    I16             reduce using rule 83 (statement -> block_statement .)
    U16             reduce using rule 83 (statement -> block_statement .)
    I32             reduce using rule 83 (statement -> block_statement .)
    U32             reduce using rule 83 (statement -> block_statement .)
    I64             reduce using rule 83 (statement -> block_statement .)
    U64             reduce using rule 83 (statement -> block_statement .)
    F16             reduce using rule 83 (statement -> block_statement .)
    F32             reduce using rule 83 (statement -> block_statement .)
    F64             reduce using rule 83 (statement -> block_statement .)
    LANGRBRACKET    reduce using rule 83 (statement -> block_statement .)
    RBRACE          reduce using rule 83 (statement -> block_statement .)
    ELSE            reduce using rule 83 (statement -> block_statement .)


state 39

    (84) statement -> expression_statement .

    LBRACE          reduce using rule 84 (statement -> expression_statement .)
    IF              reduce using rule 84 (statement -> expression_statement .)
    BREAK           reduce using rule 84 (statement -> expression_statement .)
    CONTINUE        reduce using rule 84 (statement -> expression_statement .)
    RETURN          reduce using rule 84 (statement -> expression_statement .)
    LET             reduce using rule 84 (statement -> expression_statement .)
    CONST           reduce using rule 84 (statement -> expression_statement .)
    WHILE           reduce using rule 84 (statement -> expression_statement .)
    FOR             reduce using rule 84 (statement -> expression_statement .)
    NOT             reduce using rule 84 (statement -> expression_statement .)
    LOGICAL_NOT     reduce using rule 84 (statement -> expression_statement .)
    PLUS            reduce using rule 84 (statement -> expression_statement .)
    MINUS           reduce using rule 84 (statement -> expression_statement .)
    SEMICOLON       reduce using rule 84 (statement -> expression_statement .)
    INT             reduce using rule 84 (statement -> expression_statement .)
    HEXADECIMAL     reduce using rule 84 (statement -> expression_statement .)
    FLOAT           reduce using rule 84 (statement -> expression_statement .)
    DOUBLE          reduce using rule 84 (statement -> expression_statement .)
    STRING          reduce using rule 84 (statement -> expression_statement .)
    ID              reduce using rule 84 (statement -> expression_statement .)
    LPAREN          reduce using rule 84 (statement -> expression_statement .)
    IN              reduce using rule 84 (statement -> expression_statement .)
    OUT             reduce using rule 84 (statement -> expression_statement .)
    VOID            reduce using rule 84 (statement -> expression_statement .)
    BOOL            reduce using rule 84 (statement -> expression_statement .)
    I8              reduce using rule 84 (statement -> expression_statement .)
    U8              reduce using rule 84 (statement -> expression_statement .)
    I16             reduce using rule 84 (statement -> expression_statement .)
    U16             reduce using rule 84 (statement -> expression_statement .)
    I32             reduce using rule 84 (statement -> expression_statement .)
    U32             reduce using rule 84 (statement -> expression_statement .)
    I64             reduce using rule 84 (statement -> expression_statement .)
    U64             reduce using rule 84 (statement -> expression_statement .)
    F16             reduce using rule 84 (statement -> expression_statement .)
    F32             reduce using rule 84 (statement -> expression_statement .)
    F64             reduce using rule 84 (statement -> expression_statement .)
    LANGRBRACKET    reduce using rule 84 (statement -> expression_statement .)
    RBRACE          reduce using rule 84 (statement -> expression_statement .)
    ELSE            reduce using rule 84 (statement -> expression_statement .)


state 40

    (85) statement -> if_statement .

    LBRACE          reduce using rule 85 (statement -> if_statement .)
    IF              reduce using rule 85 (statement -> if_statement .)
    BREAK           reduce using rule 85 (statement -> if_statement .)
    CONTINUE        reduce using rule 85 (statement -> if_statement .)
    RETURN          reduce using rule 85 (statement -> if_statement .)
    LET             reduce using rule 85 (statement -> if_statement .)
    CONST           reduce using rule 85 (statement -> if_statement .)
    WHILE           reduce using rule 85 (statement -> if_statement .)
    FOR             reduce using rule 85 (statement -> if_statement .)
    NOT             reduce using rule 85 (statement -> if_statement .)
    LOGICAL_NOT     reduce using rule 85 (statement -> if_statement .)
    PLUS            reduce using rule 85 (statement -> if_statement .)
    MINUS           reduce using rule 85 (statement -> if_statement .)
    SEMICOLON       reduce using rule 85 (statement -> if_statement .)
    INT             reduce using rule 85 (statement -> if_statement .)
    HEXADECIMAL     reduce using rule 85 (statement -> if_statement .)
    FLOAT           reduce using rule 85 (statement -> if_statement .)
    DOUBLE          reduce using rule 85 (statement -> if_statement .)
    STRING          reduce using rule 85 (statement -> if_statement .)
    ID              reduce using rule 85 (statement -> if_statement .)
    LPAREN          reduce using rule 85 (statement -> if_statement .)
    IN              reduce using rule 85 (statement -> if_statement .)
    OUT             reduce using rule 85 (statement -> if_statement .)
    VOID            reduce using rule 85 (statement -> if_statement .)
    BOOL            reduce using rule 85 (statement -> if_statement .)
    I8              reduce using rule 85 (statement -> if_statement .)
    U8              reduce using rule 85 (statement -> if_statement .)
    I16             reduce using rule 85 (statement -> if_statement .)
    U16             reduce using rule 85 (statement -> if_statement .)
    I32             reduce using rule 85 (statement -> if_statement .)
    U32             reduce using rule 85 (statement -> if_statement .)
    I64             reduce using rule 85 (statement -> if_statement .)
    U64             reduce using rule 85 (statement -> if_statement .)
    F16             reduce using rule 85 (statement -> if_statement .)
    F32             reduce using rule 85 (statement -> if_statement .)
    F64             reduce using rule 85 (statement -> if_statement .)
    LANGRBRACKET    reduce using rule 85 (statement -> if_statement .)
    RBRACE          reduce using rule 85 (statement -> if_statement .)
    ELSE            reduce using rule 85 (statement -> if_statement .)


state 41

    (86) statement -> iteration_statement .

    LBRACE          reduce using rule 86 (statement -> iteration_statement .)
    IF              reduce using rule 86 (statement -> iteration_statement .)
    BREAK           reduce using rule 86 (statement -> iteration_statement .)
    CONTINUE        reduce using rule 86 (statement -> iteration_statement .)
    RETURN          reduce using rule 86 (statement -> iteration_statement .)
    LET             reduce using rule 86 (statement -> iteration_statement .)
    CONST           reduce using rule 86 (statement -> iteration_statement .)
    WHILE           reduce using rule 86 (statement -> iteration_statement .)
    FOR             reduce using rule 86 (statement -> iteration_statement .)
    NOT             reduce using rule 86 (statement -> iteration_statement .)
    LOGICAL_NOT     reduce using rule 86 (statement -> iteration_statement .)
    PLUS            reduce using rule 86 (statement -> iteration_statement .)
    MINUS           reduce using rule 86 (statement -> iteration_statement .)
    SEMICOLON       reduce using rule 86 (statement -> iteration_statement .)
    INT             reduce using rule 86 (statement -> iteration_statement .)
    HEXADECIMAL     reduce using rule 86 (statement -> iteration_statement .)
    FLOAT           reduce using rule 86 (statement -> iteration_statement .)
    DOUBLE          reduce using rule 86 (statement -> iteration_statement .)
    STRING          reduce using rule 86 (statement -> iteration_statement .)
    ID              reduce using rule 86 (statement -> iteration_statement .)
    LPAREN          reduce using rule 86 (statement -> iteration_statement .)
    IN              reduce using rule 86 (statement -> iteration_statement .)
    OUT             reduce using rule 86 (statement -> iteration_statement .)
    VOID            reduce using rule 86 (statement -> iteration_statement .)
    BOOL            reduce using rule 86 (statement -> iteration_statement .)
    I8              reduce using rule 86 (statement -> iteration_statement .)
    U8              reduce using rule 86 (statement -> iteration_statement .)
    I16             reduce using rule 86 (statement -> iteration_statement .)
    U16             reduce using rule 86 (statement -> iteration_statement .)
    I32             reduce using rule 86 (statement -> iteration_statement .)
    U32             reduce using rule 86 (statement -> iteration_statement .)
    I64             reduce using rule 86 (statement -> iteration_statement .)
    U64             reduce using rule 86 (statement -> iteration_statement .)
    F16             reduce using rule 86 (statement -> iteration_statement .)
    F32             reduce using rule 86 (statement -> iteration_statement .)
    F64             reduce using rule 86 (statement -> iteration_statement .)
    LANGRBRACKET    reduce using rule 86 (statement -> iteration_statement .)
    RBRACE          reduce using rule 86 (statement -> iteration_statement .)
    ELSE            reduce using rule 86 (statement -> iteration_statement .)


state 42

    (87) statement -> jump_statement .

    LBRACE          reduce using rule 87 (statement -> jump_statement .)
    IF              reduce using rule 87 (statement -> jump_statement .)
    BREAK           reduce using rule 87 (statement -> jump_statement .)
    CONTINUE        reduce using rule 87 (statement -> jump_statement .)
    RETURN          reduce using rule 87 (statement -> jump_statement .)
    LET             reduce using rule 87 (statement -> jump_statement .)
    CONST           reduce using rule 87 (statement -> jump_statement .)
    WHILE           reduce using rule 87 (statement -> jump_statement .)
    FOR             reduce using rule 87 (statement -> jump_statement .)
    NOT             reduce using rule 87 (statement -> jump_statement .)
    LOGICAL_NOT     reduce using rule 87 (statement -> jump_statement .)
    PLUS            reduce using rule 87 (statement -> jump_statement .)
    MINUS           reduce using rule 87 (statement -> jump_statement .)
    SEMICOLON       reduce using rule 87 (statement -> jump_statement .)
    INT             reduce using rule 87 (statement -> jump_statement .)
    HEXADECIMAL     reduce using rule 87 (statement -> jump_statement .)
    FLOAT           reduce using rule 87 (statement -> jump_statement .)
    DOUBLE          reduce using rule 87 (statement -> jump_statement .)
    STRING          reduce using rule 87 (statement -> jump_statement .)
    ID              reduce using rule 87 (statement -> jump_statement .)
    LPAREN          reduce using rule 87 (statement -> jump_statement .)
    IN              reduce using rule 87 (statement -> jump_statement .)
    OUT             reduce using rule 87 (statement -> jump_statement .)
    VOID            reduce using rule 87 (statement -> jump_statement .)
    BOOL            reduce using rule 87 (statement -> jump_statement .)
    I8              reduce using rule 87 (statement -> jump_statement .)
    U8              reduce using rule 87 (statement -> jump_statement .)
    I16             reduce using rule 87 (statement -> jump_statement .)
    U16             reduce using rule 87 (statement -> jump_statement .)
    I32             reduce using rule 87 (statement -> jump_statement .)
    U32             reduce using rule 87 (statement -> jump_statement .)
    I64             reduce using rule 87 (statement -> jump_statement .)
    U64             reduce using rule 87 (statement -> jump_statement .)
    F16             reduce using rule 87 (statement -> jump_statement .)
    F32             reduce using rule 87 (statement -> jump_statement .)
    F64             reduce using rule 87 (statement -> jump_statement .)
    LANGRBRACKET    reduce using rule 87 (statement -> jump_statement .)
    RBRACE          reduce using rule 87 (statement -> jump_statement .)
    ELSE            reduce using rule 87 (statement -> jump_statement .)


state 43

    (88) decl_statement -> variable_decl . SEMICOLON

    SEMICOLON       shift and go to state 80


state 44

    (89) decl_statement -> constant_decl . SEMICOLON

    SEMICOLON       shift and go to state 81


state 45

    (93) expression_statement -> expression_opt . SEMICOLON

    SEMICOLON       shift and go to state 82


state 46

    (96) if_statement -> IF . LPAREN expression RPAREN statement statement_else_opt

    LPAREN          shift and go to state 83


state 47

    (94) expression_opt -> expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    SEMICOLON       reduce using rule 94 (expression_opt -> expression .)
    ASSIGN          shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_OR      shift and go to state 95
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102


state 48

    (99) iteration_statement -> while_clause .

    LBRACE          reduce using rule 99 (iteration_statement -> while_clause .)
    IF              reduce using rule 99 (iteration_statement -> while_clause .)
    BREAK           reduce using rule 99 (iteration_statement -> while_clause .)
    CONTINUE        reduce using rule 99 (iteration_statement -> while_clause .)
    RETURN          reduce using rule 99 (iteration_statement -> while_clause .)
    LET             reduce using rule 99 (iteration_statement -> while_clause .)
    CONST           reduce using rule 99 (iteration_statement -> while_clause .)
    WHILE           reduce using rule 99 (iteration_statement -> while_clause .)
    FOR             reduce using rule 99 (iteration_statement -> while_clause .)
    NOT             reduce using rule 99 (iteration_statement -> while_clause .)
    LOGICAL_NOT     reduce using rule 99 (iteration_statement -> while_clause .)
    PLUS            reduce using rule 99 (iteration_statement -> while_clause .)
    MINUS           reduce using rule 99 (iteration_statement -> while_clause .)
    SEMICOLON       reduce using rule 99 (iteration_statement -> while_clause .)
    INT             reduce using rule 99 (iteration_statement -> while_clause .)
    HEXADECIMAL     reduce using rule 99 (iteration_statement -> while_clause .)
    FLOAT           reduce using rule 99 (iteration_statement -> while_clause .)
    DOUBLE          reduce using rule 99 (iteration_statement -> while_clause .)
    STRING          reduce using rule 99 (iteration_statement -> while_clause .)
    ID              reduce using rule 99 (iteration_statement -> while_clause .)
    LPAREN          reduce using rule 99 (iteration_statement -> while_clause .)
    IN              reduce using rule 99 (iteration_statement -> while_clause .)
    OUT             reduce using rule 99 (iteration_statement -> while_clause .)
    VOID            reduce using rule 99 (iteration_statement -> while_clause .)
    BOOL            reduce using rule 99 (iteration_statement -> while_clause .)
    I8              reduce using rule 99 (iteration_statement -> while_clause .)
    U8              reduce using rule 99 (iteration_statement -> while_clause .)
    I16             reduce using rule 99 (iteration_statement -> while_clause .)
    U16             reduce using rule 99 (iteration_statement -> while_clause .)
    I32             reduce using rule 99 (iteration_statement -> while_clause .)
    U32             reduce using rule 99 (iteration_statement -> while_clause .)
    I64             reduce using rule 99 (iteration_statement -> while_clause .)
    U64             reduce using rule 99 (iteration_statement -> while_clause .)
    F16             reduce using rule 99 (iteration_statement -> while_clause .)
    F32             reduce using rule 99 (iteration_statement -> while_clause .)
    F64             reduce using rule 99 (iteration_statement -> while_clause .)
    LANGRBRACKET    reduce using rule 99 (iteration_statement -> while_clause .)
    RBRACE          reduce using rule 99 (iteration_statement -> while_clause .)
    ELSE            reduce using rule 99 (iteration_statement -> while_clause .)


state 49

    (100) iteration_statement -> for_clause .

    LBRACE          reduce using rule 100 (iteration_statement -> for_clause .)
    IF              reduce using rule 100 (iteration_statement -> for_clause .)
    BREAK           reduce using rule 100 (iteration_statement -> for_clause .)
    CONTINUE        reduce using rule 100 (iteration_statement -> for_clause .)
    RETURN          reduce using rule 100 (iteration_statement -> for_clause .)
    LET             reduce using rule 100 (iteration_statement -> for_clause .)
    CONST           reduce using rule 100 (iteration_statement -> for_clause .)
    WHILE           reduce using rule 100 (iteration_statement -> for_clause .)
    FOR             reduce using rule 100 (iteration_statement -> for_clause .)
    NOT             reduce using rule 100 (iteration_statement -> for_clause .)
    LOGICAL_NOT     reduce using rule 100 (iteration_statement -> for_clause .)
    PLUS            reduce using rule 100 (iteration_statement -> for_clause .)
    MINUS           reduce using rule 100 (iteration_statement -> for_clause .)
    SEMICOLON       reduce using rule 100 (iteration_statement -> for_clause .)
    INT             reduce using rule 100 (iteration_statement -> for_clause .)
    HEXADECIMAL     reduce using rule 100 (iteration_statement -> for_clause .)
    FLOAT           reduce using rule 100 (iteration_statement -> for_clause .)
    DOUBLE          reduce using rule 100 (iteration_statement -> for_clause .)
    STRING          reduce using rule 100 (iteration_statement -> for_clause .)
    ID              reduce using rule 100 (iteration_statement -> for_clause .)
    LPAREN          reduce using rule 100 (iteration_statement -> for_clause .)
    IN              reduce using rule 100 (iteration_statement -> for_clause .)
    OUT             reduce using rule 100 (iteration_statement -> for_clause .)
    VOID            reduce using rule 100 (iteration_statement -> for_clause .)
    BOOL            reduce using rule 100 (iteration_statement -> for_clause .)
    I8              reduce using rule 100 (iteration_statement -> for_clause .)
    U8              reduce using rule 100 (iteration_statement -> for_clause .)
    I16             reduce using rule 100 (iteration_statement -> for_clause .)
    U16             reduce using rule 100 (iteration_statement -> for_clause .)
    I32             reduce using rule 100 (iteration_statement -> for_clause .)
    U32             reduce using rule 100 (iteration_statement -> for_clause .)
    I64             reduce using rule 100 (iteration_statement -> for_clause .)
    U64             reduce using rule 100 (iteration_statement -> for_clause .)
    F16             reduce using rule 100 (iteration_statement -> for_clause .)
    F32             reduce using rule 100 (iteration_statement -> for_clause .)
    F64             reduce using rule 100 (iteration_statement -> for_clause .)
    LANGRBRACKET    reduce using rule 100 (iteration_statement -> for_clause .)
    RBRACE          reduce using rule 100 (iteration_statement -> for_clause .)
    ELSE            reduce using rule 100 (iteration_statement -> for_clause .)


state 50

    (105) jump_statement -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 103


state 51

    (106) jump_statement -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 104


state 52

    (107) jump_statement -> RETURN . expression_opt SEMICOLON
    (94) expression_opt -> . expression
    (95) expression_opt -> . empty
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (167) empty -> .
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty

    SEMICOLON       reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    expression_opt                 shift and go to state 105
    expression                     shift and go to state 47
    empty                          shift and go to state 106
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60

state 53

    (101) while_clause -> WHILE . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 107


state 54

    (102) for_clause -> FOR . LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement

    LPAREN          shift and go to state 108


state 55

    (108) expression -> assign_expr .

    ASSIGN          reduce using rule 108 (expression -> assign_expr .)
    PLUS            reduce using rule 108 (expression -> assign_expr .)
    MINUS           reduce using rule 108 (expression -> assign_expr .)
    MUL             reduce using rule 108 (expression -> assign_expr .)
    DIV             reduce using rule 108 (expression -> assign_expr .)
    AND             reduce using rule 108 (expression -> assign_expr .)
    OR              reduce using rule 108 (expression -> assign_expr .)
    XOR             reduce using rule 108 (expression -> assign_expr .)
    MOD             reduce using rule 108 (expression -> assign_expr .)
    LSHIFT          reduce using rule 108 (expression -> assign_expr .)
    RSHIFT          reduce using rule 108 (expression -> assign_expr .)
    LOGICAL_OR      reduce using rule 108 (expression -> assign_expr .)
    LOGICAL_AND     reduce using rule 108 (expression -> assign_expr .)
    NOT_EQUAL       reduce using rule 108 (expression -> assign_expr .)
    EQUAL           reduce using rule 108 (expression -> assign_expr .)
    LESS_EQUAL      reduce using rule 108 (expression -> assign_expr .)
    LESS            reduce using rule 108 (expression -> assign_expr .)
    GREATER_EQUAL   reduce using rule 108 (expression -> assign_expr .)
    GREATER         reduce using rule 108 (expression -> assign_expr .)
    SEMICOLON       reduce using rule 108 (expression -> assign_expr .)
    RPAREN          reduce using rule 108 (expression -> assign_expr .)
    LBRACKET        reduce using rule 108 (expression -> assign_expr .)
    LANGRBRACKET    reduce using rule 108 (expression -> assign_expr .)
    LPAREN          reduce using rule 108 (expression -> assign_expr .)
    COMMA           reduce using rule 108 (expression -> assign_expr .)
    RBRACKET        reduce using rule 108 (expression -> assign_expr .)


state 56

    (109) expression -> binary_expr .

    ASSIGN          reduce using rule 109 (expression -> binary_expr .)
    PLUS            reduce using rule 109 (expression -> binary_expr .)
    MINUS           reduce using rule 109 (expression -> binary_expr .)
    MUL             reduce using rule 109 (expression -> binary_expr .)
    DIV             reduce using rule 109 (expression -> binary_expr .)
    AND             reduce using rule 109 (expression -> binary_expr .)
    OR              reduce using rule 109 (expression -> binary_expr .)
    XOR             reduce using rule 109 (expression -> binary_expr .)
    MOD             reduce using rule 109 (expression -> binary_expr .)
    LSHIFT          reduce using rule 109 (expression -> binary_expr .)
    RSHIFT          reduce using rule 109 (expression -> binary_expr .)
    LOGICAL_OR      reduce using rule 109 (expression -> binary_expr .)
    LOGICAL_AND     reduce using rule 109 (expression -> binary_expr .)
    NOT_EQUAL       reduce using rule 109 (expression -> binary_expr .)
    EQUAL           reduce using rule 109 (expression -> binary_expr .)
    LESS_EQUAL      reduce using rule 109 (expression -> binary_expr .)
    LESS            reduce using rule 109 (expression -> binary_expr .)
    GREATER_EQUAL   reduce using rule 109 (expression -> binary_expr .)
    GREATER         reduce using rule 109 (expression -> binary_expr .)
    SEMICOLON       reduce using rule 109 (expression -> binary_expr .)
    RPAREN          reduce using rule 109 (expression -> binary_expr .)
    LBRACKET        reduce using rule 109 (expression -> binary_expr .)
    LANGRBRACKET    reduce using rule 109 (expression -> binary_expr .)
    LPAREN          reduce using rule 109 (expression -> binary_expr .)
    COMMA           reduce using rule 109 (expression -> binary_expr .)
    RBRACKET        reduce using rule 109 (expression -> binary_expr .)


state 57

    (110) expression -> unary_expr .

    ASSIGN          reduce using rule 110 (expression -> unary_expr .)
    PLUS            reduce using rule 110 (expression -> unary_expr .)
    MINUS           reduce using rule 110 (expression -> unary_expr .)
    MUL             reduce using rule 110 (expression -> unary_expr .)
    DIV             reduce using rule 110 (expression -> unary_expr .)
    AND             reduce using rule 110 (expression -> unary_expr .)
    OR              reduce using rule 110 (expression -> unary_expr .)
    XOR             reduce using rule 110 (expression -> unary_expr .)
    MOD             reduce using rule 110 (expression -> unary_expr .)
    LSHIFT          reduce using rule 110 (expression -> unary_expr .)
    RSHIFT          reduce using rule 110 (expression -> unary_expr .)
    LOGICAL_OR      reduce using rule 110 (expression -> unary_expr .)
    LOGICAL_AND     reduce using rule 110 (expression -> unary_expr .)
    NOT_EQUAL       reduce using rule 110 (expression -> unary_expr .)
    EQUAL           reduce using rule 110 (expression -> unary_expr .)
    LESS_EQUAL      reduce using rule 110 (expression -> unary_expr .)
    LESS            reduce using rule 110 (expression -> unary_expr .)
    GREATER_EQUAL   reduce using rule 110 (expression -> unary_expr .)
    GREATER         reduce using rule 110 (expression -> unary_expr .)
    SEMICOLON       reduce using rule 110 (expression -> unary_expr .)
    RPAREN          reduce using rule 110 (expression -> unary_expr .)
    LBRACKET        reduce using rule 110 (expression -> unary_expr .)
    LANGRBRACKET    reduce using rule 110 (expression -> unary_expr .)
    LPAREN          reduce using rule 110 (expression -> unary_expr .)
    COMMA           reduce using rule 110 (expression -> unary_expr .)
    RBRACKET        reduce using rule 110 (expression -> unary_expr .)


state 58

    (133) unary_operation_opt -> PLUS .

    INT             reduce using rule 133 (unary_operation_opt -> PLUS .)
    HEXADECIMAL     reduce using rule 133 (unary_operation_opt -> PLUS .)
    FLOAT           reduce using rule 133 (unary_operation_opt -> PLUS .)
    DOUBLE          reduce using rule 133 (unary_operation_opt -> PLUS .)
    STRING          reduce using rule 133 (unary_operation_opt -> PLUS .)
    ID              reduce using rule 133 (unary_operation_opt -> PLUS .)
    LPAREN          reduce using rule 133 (unary_operation_opt -> PLUS .)
    IN              reduce using rule 133 (unary_operation_opt -> PLUS .)
    OUT             reduce using rule 133 (unary_operation_opt -> PLUS .)
    VOID            reduce using rule 133 (unary_operation_opt -> PLUS .)
    BOOL            reduce using rule 133 (unary_operation_opt -> PLUS .)
    I8              reduce using rule 133 (unary_operation_opt -> PLUS .)
    U8              reduce using rule 133 (unary_operation_opt -> PLUS .)
    I16             reduce using rule 133 (unary_operation_opt -> PLUS .)
    U16             reduce using rule 133 (unary_operation_opt -> PLUS .)
    I32             reduce using rule 133 (unary_operation_opt -> PLUS .)
    U32             reduce using rule 133 (unary_operation_opt -> PLUS .)
    I64             reduce using rule 133 (unary_operation_opt -> PLUS .)
    U64             reduce using rule 133 (unary_operation_opt -> PLUS .)
    F16             reduce using rule 133 (unary_operation_opt -> PLUS .)
    F32             reduce using rule 133 (unary_operation_opt -> PLUS .)
    F64             reduce using rule 133 (unary_operation_opt -> PLUS .)
    LANGRBRACKET    reduce using rule 133 (unary_operation_opt -> PLUS .)


state 59

    (134) unary_operation_opt -> MINUS .

    INT             reduce using rule 134 (unary_operation_opt -> MINUS .)
    HEXADECIMAL     reduce using rule 134 (unary_operation_opt -> MINUS .)
    FLOAT           reduce using rule 134 (unary_operation_opt -> MINUS .)
    DOUBLE          reduce using rule 134 (unary_operation_opt -> MINUS .)
    STRING          reduce using rule 134 (unary_operation_opt -> MINUS .)
    ID              reduce using rule 134 (unary_operation_opt -> MINUS .)
    LPAREN          reduce using rule 134 (unary_operation_opt -> MINUS .)
    IN              reduce using rule 134 (unary_operation_opt -> MINUS .)
    OUT             reduce using rule 134 (unary_operation_opt -> MINUS .)
    VOID            reduce using rule 134 (unary_operation_opt -> MINUS .)
    BOOL            reduce using rule 134 (unary_operation_opt -> MINUS .)
    I8              reduce using rule 134 (unary_operation_opt -> MINUS .)
    U8              reduce using rule 134 (unary_operation_opt -> MINUS .)
    I16             reduce using rule 134 (unary_operation_opt -> MINUS .)
    U16             reduce using rule 134 (unary_operation_opt -> MINUS .)
    I32             reduce using rule 134 (unary_operation_opt -> MINUS .)
    U32             reduce using rule 134 (unary_operation_opt -> MINUS .)
    I64             reduce using rule 134 (unary_operation_opt -> MINUS .)
    U64             reduce using rule 134 (unary_operation_opt -> MINUS .)
    F16             reduce using rule 134 (unary_operation_opt -> MINUS .)
    F32             reduce using rule 134 (unary_operation_opt -> MINUS .)
    F64             reduce using rule 134 (unary_operation_opt -> MINUS .)
    LANGRBRACKET    reduce using rule 134 (unary_operation_opt -> MINUS .)


state 60

    (130) unary_expr -> unary_operation_opt . primary_expr
    (136) primary_expr -> . operand
    (137) primary_expr -> . call_expr
    (138) primary_expr -> . index_expr
    (139) primary_expr -> . cast_expr
    (140) primary_expr -> . new_expr
    (141) primary_expr -> . member_expr
    (142) primary_expr -> . io_expr
    (143) operand -> . INT
    (144) operand -> . HEXADECIMAL
    (145) operand -> . FLOAT
    (146) operand -> . DOUBLE
    (147) operand -> . STRING
    (148) operand -> . ID
    (149) operand -> . LPAREN expression RPAREN
    (156) call_expr -> . primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN
    (151) index_expr -> . primary_expr LBRACKET expression RBRACKET
    (152) cast_expr -> . LPAREN type_spec RPAREN expression
    (153) new_expr -> . type_spec LPAREN parameter_list_opt RPAREN
    (150) member_expr -> . ID DOT ID
    (164) io_expr -> . in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . array_type
    (26) type_spec -> . reference_type
    (27) type_spec -> . function_type
    (165) in_out -> . IN
    (166) in_out -> . OUT
    (28) simple_type -> . VOID
    (29) simple_type -> . BOOL
    (30) simple_type -> . I8
    (31) simple_type -> . U8
    (32) simple_type -> . I16
    (33) simple_type -> . U16
    (34) simple_type -> . I32
    (35) simple_type -> . U32
    (36) simple_type -> . I64
    (37) simple_type -> . U64
    (38) simple_type -> . F16
    (39) simple_type -> . F32
    (40) simple_type -> . F64
    (41) complex_type -> . ID generics_specialization_list_opt
    (42) generic_type -> . ID
    (43) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> . type_spec REF
    (47) function_type -> . function_sign
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

  ! shift/reduce conflict for LPAREN resolved as shift
    INT             shift and go to state 117
    HEXADECIMAL     shift and go to state 118
    FLOAT           shift and go to state 119
    DOUBLE          shift and go to state 120
    STRING          shift and go to state 121
    ID              shift and go to state 122
    LPAREN          shift and go to state 123
    IN              shift and go to state 132
    OUT             shift and go to state 133
    VOID            shift and go to state 134
    BOOL            shift and go to state 135
    I8              shift and go to state 136
    U8              shift and go to state 137
    I16             shift and go to state 138
    U16             shift and go to state 139
    I32             shift and go to state 140
    U32             shift and go to state 141
    I64             shift and go to state 142
    U64             shift and go to state 143
    F16             shift and go to state 144
    F32             shift and go to state 145
    F64             shift and go to state 146
    LANGRBRACKET    shift and go to state 74

  ! LPAREN          [ reduce using rule 167 (empty -> .) ]

    primary_expr                   shift and go to state 109
    operand                        shift and go to state 110
    call_expr                      shift and go to state 111
    index_expr                     shift and go to state 112
    cast_expr                      shift and go to state 113
    new_expr                       shift and go to state 114
    member_expr                    shift and go to state 115
    io_expr                        shift and go to state 116
    type_spec                      shift and go to state 124
    in_out                         shift and go to state 125
    simple_type                    shift and go to state 126
    complex_type                   shift and go to state 127
    generic_type                   shift and go to state 128
    array_type                     shift and go to state 129
    reference_type                 shift and go to state 130
    function_type                  shift and go to state 131
    function_sign                  shift and go to state 147
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 61

    (131) unary_operation_opt -> NOT .

    INT             reduce using rule 131 (unary_operation_opt -> NOT .)
    HEXADECIMAL     reduce using rule 131 (unary_operation_opt -> NOT .)
    FLOAT           reduce using rule 131 (unary_operation_opt -> NOT .)
    DOUBLE          reduce using rule 131 (unary_operation_opt -> NOT .)
    STRING          reduce using rule 131 (unary_operation_opt -> NOT .)
    ID              reduce using rule 131 (unary_operation_opt -> NOT .)
    LPAREN          reduce using rule 131 (unary_operation_opt -> NOT .)
    IN              reduce using rule 131 (unary_operation_opt -> NOT .)
    OUT             reduce using rule 131 (unary_operation_opt -> NOT .)
    VOID            reduce using rule 131 (unary_operation_opt -> NOT .)
    BOOL            reduce using rule 131 (unary_operation_opt -> NOT .)
    I8              reduce using rule 131 (unary_operation_opt -> NOT .)
    U8              reduce using rule 131 (unary_operation_opt -> NOT .)
    I16             reduce using rule 131 (unary_operation_opt -> NOT .)
    U16             reduce using rule 131 (unary_operation_opt -> NOT .)
    I32             reduce using rule 131 (unary_operation_opt -> NOT .)
    U32             reduce using rule 131 (unary_operation_opt -> NOT .)
    I64             reduce using rule 131 (unary_operation_opt -> NOT .)
    U64             reduce using rule 131 (unary_operation_opt -> NOT .)
    F16             reduce using rule 131 (unary_operation_opt -> NOT .)
    F32             reduce using rule 131 (unary_operation_opt -> NOT .)
    F64             reduce using rule 131 (unary_operation_opt -> NOT .)
    LANGRBRACKET    reduce using rule 131 (unary_operation_opt -> NOT .)


state 62

    (132) unary_operation_opt -> LOGICAL_NOT .

    INT             reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    HEXADECIMAL     reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    FLOAT           reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    DOUBLE          reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    STRING          reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    ID              reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    LPAREN          reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    IN              reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    OUT             reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    VOID            reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    BOOL            reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    I8              reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    U8              reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    I16             reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    U16             reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    I32             reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    U32             reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    I64             reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    U64             reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    F16             reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    F32             reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    F64             reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)
    LANGRBRACKET    reduce using rule 132 (unary_operation_opt -> LOGICAL_NOT .)


state 63

    (13) variable_decl -> LET declarator declarator_nest .

    SEMICOLON       reduce using rule 13 (variable_decl -> LET declarator declarator_nest .)


state 64

    (14) declarator_nest -> COMMA . declarator declarator_nest
    (17) declarator -> . ID type_spec_colon_opt ASSIGN expression

    ID              shift and go to state 28

    declarator                     shift and go to state 148

state 65

    (15) declarator_nest -> empty .

    SEMICOLON       reduce using rule 15 (declarator_nest -> empty .)


state 66

    (17) declarator -> ID type_spec_colon_opt . ASSIGN expression

    ASSIGN          shift and go to state 149


state 67

    (18) type_spec_colon_opt -> COLON . type_spec
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . array_type
    (26) type_spec -> . reference_type
    (27) type_spec -> . function_type
    (28) simple_type -> . VOID
    (29) simple_type -> . BOOL
    (30) simple_type -> . I8
    (31) simple_type -> . U8
    (32) simple_type -> . I16
    (33) simple_type -> . U16
    (34) simple_type -> . I32
    (35) simple_type -> . U32
    (36) simple_type -> . I64
    (37) simple_type -> . U64
    (38) simple_type -> . F16
    (39) simple_type -> . F32
    (40) simple_type -> . F64
    (41) complex_type -> . ID generics_specialization_list_opt
    (42) generic_type -> . ID
    (43) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> . type_spec REF
    (47) function_type -> . function_sign
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    VOID            shift and go to state 134
    BOOL            shift and go to state 135
    I8              shift and go to state 136
    U8              shift and go to state 137
    I16             shift and go to state 138
    U16             shift and go to state 139
    I32             shift and go to state 140
    U32             shift and go to state 141
    I64             shift and go to state 142
    U64             shift and go to state 143
    F16             shift and go to state 144
    F32             shift and go to state 145
    F64             shift and go to state 146
    ID              shift and go to state 151
    LANGRBRACKET    shift and go to state 74
    LPAREN          reduce using rule 167 (empty -> .)

    type_spec                      shift and go to state 150
    simple_type                    shift and go to state 126
    complex_type                   shift and go to state 127
    generic_type                   shift and go to state 128
    array_type                     shift and go to state 129
    reference_type                 shift and go to state 130
    function_type                  shift and go to state 131
    function_sign                  shift and go to state 147
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 68

    (19) type_spec_colon_opt -> empty .

    ASSIGN          reduce using rule 19 (type_spec_colon_opt -> empty .)
    COMMA           reduce using rule 19 (type_spec_colon_opt -> empty .)
    RPAREN          reduce using rule 19 (type_spec_colon_opt -> empty .)
    SEMICOLON       reduce using rule 19 (type_spec_colon_opt -> empty .)


state 69

    (16) constant_decl -> CONST declarator declarator_nest .

    SEMICOLON       reduce using rule 16 (constant_decl -> CONST declarator declarator_nest .)


state 70

    (20) function_decl -> FUNC ID function_sign .

    SEMICOLON       reduce using rule 20 (function_decl -> FUNC ID function_sign .)
    LBRACE          reduce using rule 20 (function_decl -> FUNC ID function_sign .)


state 71

    (67) function_sign -> generics_type_list_opt . LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt

    LPAREN          shift and go to state 152


state 72

    (52) generics_type_list_opt -> generics_type_list .

    LPAREN          reduce using rule 52 (generics_type_list_opt -> generics_type_list .)
    COLON           reduce using rule 52 (generics_type_list_opt -> generics_type_list .)
    LBRACE          reduce using rule 52 (generics_type_list_opt -> generics_type_list .)


state 73

    (53) generics_type_list_opt -> empty .

    LPAREN          reduce using rule 53 (generics_type_list_opt -> empty .)
    COLON           reduce using rule 53 (generics_type_list_opt -> empty .)
    LBRACE          reduce using rule 53 (generics_type_list_opt -> empty .)


state 74

    (75) generics_type_list -> LANGRBRACKET . generics_type generics_type_comma_nest RANGRBRACKET
    (78) generics_type -> . ID generics_type_range_colon_opt

    ID              shift and go to state 154

    generics_type                  shift and go to state 153

state 75

    (12) type_alias_decl -> TYPE ID ASSIGN . type_spec
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . array_type
    (26) type_spec -> . reference_type
    (27) type_spec -> . function_type
    (28) simple_type -> . VOID
    (29) simple_type -> . BOOL
    (30) simple_type -> . I8
    (31) simple_type -> . U8
    (32) simple_type -> . I16
    (33) simple_type -> . U16
    (34) simple_type -> . I32
    (35) simple_type -> . U32
    (36) simple_type -> . I64
    (37) simple_type -> . U64
    (38) simple_type -> . F16
    (39) simple_type -> . F32
    (40) simple_type -> . F64
    (41) complex_type -> . ID generics_specialization_list_opt
    (42) generic_type -> . ID
    (43) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> . type_spec REF
    (47) function_type -> . function_sign
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    VOID            shift and go to state 134
    BOOL            shift and go to state 135
    I8              shift and go to state 136
    U8              shift and go to state 137
    I16             shift and go to state 138
    U16             shift and go to state 139
    I32             shift and go to state 140
    U32             shift and go to state 141
    I64             shift and go to state 142
    U64             shift and go to state 143
    F16             shift and go to state 144
    F32             shift and go to state 145
    F64             shift and go to state 146
    ID              shift and go to state 151
    LANGRBRACKET    shift and go to state 74
    LPAREN          reduce using rule 167 (empty -> .)

    type_spec                      shift and go to state 155
    simple_type                    shift and go to state 126
    complex_type                   shift and go to state 127
    generic_type                   shift and go to state 128
    array_type                     shift and go to state 129
    reference_type                 shift and go to state 130
    function_type                  shift and go to state 131
    function_sign                  shift and go to state 147
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 76

    (48) struct_decl -> STRUCT ID generics_type_list_opt . complex_type_colon_opt LBRACE member_decl_nest RBRACE
    (49) complex_type_colon_opt -> . COLON complex_type
    (50) complex_type_colon_opt -> . empty
    (167) empty -> .

    COLON           shift and go to state 157
    LBRACE          reduce using rule 167 (empty -> .)

    complex_type_colon_opt         shift and go to state 156
    empty                          shift and go to state 158

state 77

    (51) interface_decl -> INTERFACE ID generics_type_list_opt . LBRACE interface_member_decl_nest RBRACE

    LBRACE          shift and go to state 159


state 78

    (90) block_statement -> LBRACE statement_nest RBRACE .

    LET             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    CONST           reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    FUNC            reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    TYPE            reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    STRUCT          reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    INTERFACE       reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    $end            reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    LBRACE          reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    IF              reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    BREAK           reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    CONTINUE        reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    RETURN          reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    WHILE           reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    FOR             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    NOT             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    LOGICAL_NOT     reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    PLUS            reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    MINUS           reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    SEMICOLON       reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    INT             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    HEXADECIMAL     reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    FLOAT           reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    DOUBLE          reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    STRING          reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    ID              reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    LPAREN          reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    IN              reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    OUT             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    VOID            reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    BOOL            reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    I8              reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    U8              reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    I16             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    U16             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    I32             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    U32             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    I64             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    U64             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    F16             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    F32             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    F64             reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    LANGRBRACKET    reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    RBRACE          reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)
    ELSE            reduce using rule 90 (block_statement -> LBRACE statement_nest RBRACE .)


state 79

    (91) statement_nest -> statement statement_nest .

    RBRACE          reduce using rule 91 (statement_nest -> statement statement_nest .)


state 80

    (88) decl_statement -> variable_decl SEMICOLON .

    LBRACE          reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    IF              reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    BREAK           reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    CONTINUE        reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    RETURN          reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    LET             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    CONST           reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    WHILE           reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    FOR             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    NOT             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    LOGICAL_NOT     reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    PLUS            reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    MINUS           reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    SEMICOLON       reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    INT             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    HEXADECIMAL     reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    FLOAT           reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    DOUBLE          reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    STRING          reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    ID              reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    LPAREN          reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    IN              reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    OUT             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    VOID            reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    BOOL            reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    I8              reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    U8              reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    I16             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    U16             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    I32             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    U32             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    I64             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    U64             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    F16             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    F32             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    F64             reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    LANGRBRACKET    reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    RBRACE          reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)
    ELSE            reduce using rule 88 (decl_statement -> variable_decl SEMICOLON .)


state 81

    (89) decl_statement -> constant_decl SEMICOLON .

    LBRACE          reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    IF              reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    BREAK           reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    CONTINUE        reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    RETURN          reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    LET             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    CONST           reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    WHILE           reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    FOR             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    NOT             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    LOGICAL_NOT     reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    PLUS            reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    MINUS           reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    SEMICOLON       reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    INT             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    HEXADECIMAL     reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    FLOAT           reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    DOUBLE          reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    STRING          reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    ID              reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    LPAREN          reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    IN              reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    OUT             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    VOID            reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    BOOL            reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    I8              reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    U8              reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    I16             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    U16             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    I32             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    U32             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    I64             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    U64             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    F16             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    F32             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    F64             reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    LANGRBRACKET    reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    RBRACE          reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)
    ELSE            reduce using rule 89 (decl_statement -> constant_decl SEMICOLON .)


state 82

    (93) expression_statement -> expression_opt SEMICOLON .

    LBRACE          reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    IF              reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    BREAK           reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    CONTINUE        reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    RETURN          reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    LET             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    CONST           reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    WHILE           reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    FOR             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    NOT             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    LOGICAL_NOT     reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    PLUS            reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    MINUS           reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    SEMICOLON       reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    INT             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    HEXADECIMAL     reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    FLOAT           reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    DOUBLE          reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    STRING          reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    ID              reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    LPAREN          reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    IN              reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    OUT             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    VOID            reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    BOOL            reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    I8              reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    U8              reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    I16             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    U16             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    I32             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    U32             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    I64             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    U64             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    F16             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    F32             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    F64             reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    LANGRBRACKET    reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    RBRACE          reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)
    ELSE            reduce using rule 93 (expression_statement -> expression_opt SEMICOLON .)


state 83

    (96) if_statement -> IF LPAREN . expression RPAREN statement statement_else_opt
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 160
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 84

    (111) assign_expr -> expression ASSIGN . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 162
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 85

    (112) binary_expr -> expression PLUS . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 163
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 86

    (113) binary_expr -> expression MINUS . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 164
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 87

    (114) binary_expr -> expression MUL . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 165
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 88

    (115) binary_expr -> expression DIV . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 166
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 89

    (116) binary_expr -> expression AND . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 167
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 90

    (117) binary_expr -> expression OR . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 168
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 91

    (118) binary_expr -> expression XOR . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 169
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 92

    (119) binary_expr -> expression MOD . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 170
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 93

    (120) binary_expr -> expression LSHIFT . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 171
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 94

    (121) binary_expr -> expression RSHIFT . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 172
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 95

    (122) binary_expr -> expression LOGICAL_OR . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 173
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 96

    (123) binary_expr -> expression LOGICAL_AND . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 174
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 97

    (124) binary_expr -> expression NOT_EQUAL . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 175
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 98

    (125) binary_expr -> expression EQUAL . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 176
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 99

    (126) binary_expr -> expression LESS_EQUAL . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 177
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 100

    (127) binary_expr -> expression LESS . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 178
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 101

    (128) binary_expr -> expression GREATER_EQUAL . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 179
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 102

    (129) binary_expr -> expression GREATER . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 180
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 103

    (105) jump_statement -> BREAK SEMICOLON .

    LBRACE          reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    IF              reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    RETURN          reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    LET             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    CONST           reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    NOT             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    LOGICAL_NOT     reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    PLUS            reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    MINUS           reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    INT             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    HEXADECIMAL     reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    DOUBLE          reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    STRING          reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    ID              reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    IN              reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    OUT             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    VOID            reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    BOOL            reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    I8              reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    U8              reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    I16             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    U16             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    I32             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    U32             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    I64             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    U64             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    F16             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    F32             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    F64             reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    LANGRBRACKET    reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 105 (jump_statement -> BREAK SEMICOLON .)


state 104

    (106) jump_statement -> CONTINUE SEMICOLON .

    LBRACE          reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    IF              reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    LET             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    CONST           reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    NOT             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    LOGICAL_NOT     reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    PLUS            reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    MINUS           reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    INT             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    HEXADECIMAL     reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    DOUBLE          reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    ID              reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    IN              reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    OUT             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    BOOL            reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    I8              reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    U8              reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    I16             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    U16             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    I32             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    U32             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    I64             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    U64             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    F16             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    F32             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    F64             reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    LANGRBRACKET    reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    RBRACE          reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 106 (jump_statement -> CONTINUE SEMICOLON .)


state 105

    (107) jump_statement -> RETURN expression_opt . SEMICOLON

    SEMICOLON       shift and go to state 181


state 106

    (95) expression_opt -> empty .
    (135) unary_operation_opt -> empty .

    SEMICOLON       reduce using rule 95 (expression_opt -> empty .)
    INT             reduce using rule 135 (unary_operation_opt -> empty .)
    HEXADECIMAL     reduce using rule 135 (unary_operation_opt -> empty .)
    FLOAT           reduce using rule 135 (unary_operation_opt -> empty .)
    DOUBLE          reduce using rule 135 (unary_operation_opt -> empty .)
    STRING          reduce using rule 135 (unary_operation_opt -> empty .)
    ID              reduce using rule 135 (unary_operation_opt -> empty .)
    LPAREN          reduce using rule 135 (unary_operation_opt -> empty .)
    IN              reduce using rule 135 (unary_operation_opt -> empty .)
    OUT             reduce using rule 135 (unary_operation_opt -> empty .)
    VOID            reduce using rule 135 (unary_operation_opt -> empty .)
    BOOL            reduce using rule 135 (unary_operation_opt -> empty .)
    I8              reduce using rule 135 (unary_operation_opt -> empty .)
    U8              reduce using rule 135 (unary_operation_opt -> empty .)
    I16             reduce using rule 135 (unary_operation_opt -> empty .)
    U16             reduce using rule 135 (unary_operation_opt -> empty .)
    I32             reduce using rule 135 (unary_operation_opt -> empty .)
    U32             reduce using rule 135 (unary_operation_opt -> empty .)
    I64             reduce using rule 135 (unary_operation_opt -> empty .)
    U64             reduce using rule 135 (unary_operation_opt -> empty .)
    F16             reduce using rule 135 (unary_operation_opt -> empty .)
    F32             reduce using rule 135 (unary_operation_opt -> empty .)
    F64             reduce using rule 135 (unary_operation_opt -> empty .)
    LANGRBRACKET    reduce using rule 135 (unary_operation_opt -> empty .)


state 107

    (101) while_clause -> WHILE LPAREN . expression RPAREN statement
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 182
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 108

    (102) for_clause -> FOR LPAREN . for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (103) for_init_statement -> . expression_statement
    (104) for_init_statement -> . decl_statement
    (93) expression_statement -> . expression_opt SEMICOLON
    (88) decl_statement -> . variable_decl SEMICOLON
    (89) decl_statement -> . constant_decl SEMICOLON
    (94) expression_opt -> . expression
    (95) expression_opt -> . empty
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (167) empty -> .
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty

    LET             shift and go to state 13
    CONST           shift and go to state 14
    SEMICOLON       reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    for_init_statement             shift and go to state 183
    expression_opt                 shift and go to state 45
    expression                     shift and go to state 47
    expression_statement           shift and go to state 184
    decl_statement                 shift and go to state 185
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    empty                          shift and go to state 106
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60

state 109

    (130) unary_expr -> unary_operation_opt primary_expr .
    (156) call_expr -> primary_expr . generics_specialization_list_opt LPAREN parameter_list_opt RPAREN
    (151) index_expr -> primary_expr . LBRACKET expression RBRACKET
    (157) generics_specialization_list_opt -> . LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET
    (158) generics_specialization_list_opt -> . empty
    (167) empty -> .

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LANGRBRACKET resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    ASSIGN          reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    PLUS            reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    MINUS           reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    MUL             reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    DIV             reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    AND             reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    OR              reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    XOR             reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    MOD             reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    LSHIFT          reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    RSHIFT          reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    LOGICAL_OR      reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    LOGICAL_AND     reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    NOT_EQUAL       reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    EQUAL           reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    LESS_EQUAL      reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    LESS            reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    GREATER_EQUAL   reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    GREATER         reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    SEMICOLON       reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    RPAREN          reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    LPAREN          reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    COMMA           reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    RBRACKET        reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .)
    LBRACKET        shift and go to state 187
    LANGRBRACKET    shift and go to state 188

  ! LBRACKET        [ reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .) ]
  ! LANGRBRACKET    [ reduce using rule 130 (unary_expr -> unary_operation_opt primary_expr .) ]
  ! LPAREN          [ reduce using rule 167 (empty -> .) ]

    generics_specialization_list_opt shift and go to state 186
    empty                          shift and go to state 189

state 110

    (136) primary_expr -> operand .

    LBRACKET        reduce using rule 136 (primary_expr -> operand .)
    LANGRBRACKET    reduce using rule 136 (primary_expr -> operand .)
    LPAREN          reduce using rule 136 (primary_expr -> operand .)
    ASSIGN          reduce using rule 136 (primary_expr -> operand .)
    PLUS            reduce using rule 136 (primary_expr -> operand .)
    MINUS           reduce using rule 136 (primary_expr -> operand .)
    MUL             reduce using rule 136 (primary_expr -> operand .)
    DIV             reduce using rule 136 (primary_expr -> operand .)
    AND             reduce using rule 136 (primary_expr -> operand .)
    OR              reduce using rule 136 (primary_expr -> operand .)
    XOR             reduce using rule 136 (primary_expr -> operand .)
    MOD             reduce using rule 136 (primary_expr -> operand .)
    LSHIFT          reduce using rule 136 (primary_expr -> operand .)
    RSHIFT          reduce using rule 136 (primary_expr -> operand .)
    LOGICAL_OR      reduce using rule 136 (primary_expr -> operand .)
    LOGICAL_AND     reduce using rule 136 (primary_expr -> operand .)
    NOT_EQUAL       reduce using rule 136 (primary_expr -> operand .)
    EQUAL           reduce using rule 136 (primary_expr -> operand .)
    LESS_EQUAL      reduce using rule 136 (primary_expr -> operand .)
    LESS            reduce using rule 136 (primary_expr -> operand .)
    GREATER_EQUAL   reduce using rule 136 (primary_expr -> operand .)
    GREATER         reduce using rule 136 (primary_expr -> operand .)
    SEMICOLON       reduce using rule 136 (primary_expr -> operand .)
    RPAREN          reduce using rule 136 (primary_expr -> operand .)
    COMMA           reduce using rule 136 (primary_expr -> operand .)
    RBRACKET        reduce using rule 136 (primary_expr -> operand .)


state 111

    (137) primary_expr -> call_expr .

    LBRACKET        reduce using rule 137 (primary_expr -> call_expr .)
    LANGRBRACKET    reduce using rule 137 (primary_expr -> call_expr .)
    LPAREN          reduce using rule 137 (primary_expr -> call_expr .)
    ASSIGN          reduce using rule 137 (primary_expr -> call_expr .)
    PLUS            reduce using rule 137 (primary_expr -> call_expr .)
    MINUS           reduce using rule 137 (primary_expr -> call_expr .)
    MUL             reduce using rule 137 (primary_expr -> call_expr .)
    DIV             reduce using rule 137 (primary_expr -> call_expr .)
    AND             reduce using rule 137 (primary_expr -> call_expr .)
    OR              reduce using rule 137 (primary_expr -> call_expr .)
    XOR             reduce using rule 137 (primary_expr -> call_expr .)
    MOD             reduce using rule 137 (primary_expr -> call_expr .)
    LSHIFT          reduce using rule 137 (primary_expr -> call_expr .)
    RSHIFT          reduce using rule 137 (primary_expr -> call_expr .)
    LOGICAL_OR      reduce using rule 137 (primary_expr -> call_expr .)
    LOGICAL_AND     reduce using rule 137 (primary_expr -> call_expr .)
    NOT_EQUAL       reduce using rule 137 (primary_expr -> call_expr .)
    EQUAL           reduce using rule 137 (primary_expr -> call_expr .)
    LESS_EQUAL      reduce using rule 137 (primary_expr -> call_expr .)
    LESS            reduce using rule 137 (primary_expr -> call_expr .)
    GREATER_EQUAL   reduce using rule 137 (primary_expr -> call_expr .)
    GREATER         reduce using rule 137 (primary_expr -> call_expr .)
    SEMICOLON       reduce using rule 137 (primary_expr -> call_expr .)
    RPAREN          reduce using rule 137 (primary_expr -> call_expr .)
    COMMA           reduce using rule 137 (primary_expr -> call_expr .)
    RBRACKET        reduce using rule 137 (primary_expr -> call_expr .)


state 112

    (138) primary_expr -> index_expr .

    LBRACKET        reduce using rule 138 (primary_expr -> index_expr .)
    LANGRBRACKET    reduce using rule 138 (primary_expr -> index_expr .)
    LPAREN          reduce using rule 138 (primary_expr -> index_expr .)
    ASSIGN          reduce using rule 138 (primary_expr -> index_expr .)
    PLUS            reduce using rule 138 (primary_expr -> index_expr .)
    MINUS           reduce using rule 138 (primary_expr -> index_expr .)
    MUL             reduce using rule 138 (primary_expr -> index_expr .)
    DIV             reduce using rule 138 (primary_expr -> index_expr .)
    AND             reduce using rule 138 (primary_expr -> index_expr .)
    OR              reduce using rule 138 (primary_expr -> index_expr .)
    XOR             reduce using rule 138 (primary_expr -> index_expr .)
    MOD             reduce using rule 138 (primary_expr -> index_expr .)
    LSHIFT          reduce using rule 138 (primary_expr -> index_expr .)
    RSHIFT          reduce using rule 138 (primary_expr -> index_expr .)
    LOGICAL_OR      reduce using rule 138 (primary_expr -> index_expr .)
    LOGICAL_AND     reduce using rule 138 (primary_expr -> index_expr .)
    NOT_EQUAL       reduce using rule 138 (primary_expr -> index_expr .)
    EQUAL           reduce using rule 138 (primary_expr -> index_expr .)
    LESS_EQUAL      reduce using rule 138 (primary_expr -> index_expr .)
    LESS            reduce using rule 138 (primary_expr -> index_expr .)
    GREATER_EQUAL   reduce using rule 138 (primary_expr -> index_expr .)
    GREATER         reduce using rule 138 (primary_expr -> index_expr .)
    SEMICOLON       reduce using rule 138 (primary_expr -> index_expr .)
    RPAREN          reduce using rule 138 (primary_expr -> index_expr .)
    COMMA           reduce using rule 138 (primary_expr -> index_expr .)
    RBRACKET        reduce using rule 138 (primary_expr -> index_expr .)


state 113

    (139) primary_expr -> cast_expr .

    LBRACKET        reduce using rule 139 (primary_expr -> cast_expr .)
    LANGRBRACKET    reduce using rule 139 (primary_expr -> cast_expr .)
    LPAREN          reduce using rule 139 (primary_expr -> cast_expr .)
    ASSIGN          reduce using rule 139 (primary_expr -> cast_expr .)
    PLUS            reduce using rule 139 (primary_expr -> cast_expr .)
    MINUS           reduce using rule 139 (primary_expr -> cast_expr .)
    MUL             reduce using rule 139 (primary_expr -> cast_expr .)
    DIV             reduce using rule 139 (primary_expr -> cast_expr .)
    AND             reduce using rule 139 (primary_expr -> cast_expr .)
    OR              reduce using rule 139 (primary_expr -> cast_expr .)
    XOR             reduce using rule 139 (primary_expr -> cast_expr .)
    MOD             reduce using rule 139 (primary_expr -> cast_expr .)
    LSHIFT          reduce using rule 139 (primary_expr -> cast_expr .)
    RSHIFT          reduce using rule 139 (primary_expr -> cast_expr .)
    LOGICAL_OR      reduce using rule 139 (primary_expr -> cast_expr .)
    LOGICAL_AND     reduce using rule 139 (primary_expr -> cast_expr .)
    NOT_EQUAL       reduce using rule 139 (primary_expr -> cast_expr .)
    EQUAL           reduce using rule 139 (primary_expr -> cast_expr .)
    LESS_EQUAL      reduce using rule 139 (primary_expr -> cast_expr .)
    LESS            reduce using rule 139 (primary_expr -> cast_expr .)
    GREATER_EQUAL   reduce using rule 139 (primary_expr -> cast_expr .)
    GREATER         reduce using rule 139 (primary_expr -> cast_expr .)
    SEMICOLON       reduce using rule 139 (primary_expr -> cast_expr .)
    RPAREN          reduce using rule 139 (primary_expr -> cast_expr .)
    COMMA           reduce using rule 139 (primary_expr -> cast_expr .)
    RBRACKET        reduce using rule 139 (primary_expr -> cast_expr .)


state 114

    (140) primary_expr -> new_expr .

    LBRACKET        reduce using rule 140 (primary_expr -> new_expr .)
    LANGRBRACKET    reduce using rule 140 (primary_expr -> new_expr .)
    LPAREN          reduce using rule 140 (primary_expr -> new_expr .)
    ASSIGN          reduce using rule 140 (primary_expr -> new_expr .)
    PLUS            reduce using rule 140 (primary_expr -> new_expr .)
    MINUS           reduce using rule 140 (primary_expr -> new_expr .)
    MUL             reduce using rule 140 (primary_expr -> new_expr .)
    DIV             reduce using rule 140 (primary_expr -> new_expr .)
    AND             reduce using rule 140 (primary_expr -> new_expr .)
    OR              reduce using rule 140 (primary_expr -> new_expr .)
    XOR             reduce using rule 140 (primary_expr -> new_expr .)
    MOD             reduce using rule 140 (primary_expr -> new_expr .)
    LSHIFT          reduce using rule 140 (primary_expr -> new_expr .)
    RSHIFT          reduce using rule 140 (primary_expr -> new_expr .)
    LOGICAL_OR      reduce using rule 140 (primary_expr -> new_expr .)
    LOGICAL_AND     reduce using rule 140 (primary_expr -> new_expr .)
    NOT_EQUAL       reduce using rule 140 (primary_expr -> new_expr .)
    EQUAL           reduce using rule 140 (primary_expr -> new_expr .)
    LESS_EQUAL      reduce using rule 140 (primary_expr -> new_expr .)
    LESS            reduce using rule 140 (primary_expr -> new_expr .)
    GREATER_EQUAL   reduce using rule 140 (primary_expr -> new_expr .)
    GREATER         reduce using rule 140 (primary_expr -> new_expr .)
    SEMICOLON       reduce using rule 140 (primary_expr -> new_expr .)
    RPAREN          reduce using rule 140 (primary_expr -> new_expr .)
    COMMA           reduce using rule 140 (primary_expr -> new_expr .)
    RBRACKET        reduce using rule 140 (primary_expr -> new_expr .)


state 115

    (141) primary_expr -> member_expr .

    LBRACKET        reduce using rule 141 (primary_expr -> member_expr .)
    LANGRBRACKET    reduce using rule 141 (primary_expr -> member_expr .)
    LPAREN          reduce using rule 141 (primary_expr -> member_expr .)
    ASSIGN          reduce using rule 141 (primary_expr -> member_expr .)
    PLUS            reduce using rule 141 (primary_expr -> member_expr .)
    MINUS           reduce using rule 141 (primary_expr -> member_expr .)
    MUL             reduce using rule 141 (primary_expr -> member_expr .)
    DIV             reduce using rule 141 (primary_expr -> member_expr .)
    AND             reduce using rule 141 (primary_expr -> member_expr .)
    OR              reduce using rule 141 (primary_expr -> member_expr .)
    XOR             reduce using rule 141 (primary_expr -> member_expr .)
    MOD             reduce using rule 141 (primary_expr -> member_expr .)
    LSHIFT          reduce using rule 141 (primary_expr -> member_expr .)
    RSHIFT          reduce using rule 141 (primary_expr -> member_expr .)
    LOGICAL_OR      reduce using rule 141 (primary_expr -> member_expr .)
    LOGICAL_AND     reduce using rule 141 (primary_expr -> member_expr .)
    NOT_EQUAL       reduce using rule 141 (primary_expr -> member_expr .)
    EQUAL           reduce using rule 141 (primary_expr -> member_expr .)
    LESS_EQUAL      reduce using rule 141 (primary_expr -> member_expr .)
    LESS            reduce using rule 141 (primary_expr -> member_expr .)
    GREATER_EQUAL   reduce using rule 141 (primary_expr -> member_expr .)
    GREATER         reduce using rule 141 (primary_expr -> member_expr .)
    SEMICOLON       reduce using rule 141 (primary_expr -> member_expr .)
    RPAREN          reduce using rule 141 (primary_expr -> member_expr .)
    COMMA           reduce using rule 141 (primary_expr -> member_expr .)
    RBRACKET        reduce using rule 141 (primary_expr -> member_expr .)


state 116

    (142) primary_expr -> io_expr .

    LBRACKET        reduce using rule 142 (primary_expr -> io_expr .)
    LANGRBRACKET    reduce using rule 142 (primary_expr -> io_expr .)
    LPAREN          reduce using rule 142 (primary_expr -> io_expr .)
    ASSIGN          reduce using rule 142 (primary_expr -> io_expr .)
    PLUS            reduce using rule 142 (primary_expr -> io_expr .)
    MINUS           reduce using rule 142 (primary_expr -> io_expr .)
    MUL             reduce using rule 142 (primary_expr -> io_expr .)
    DIV             reduce using rule 142 (primary_expr -> io_expr .)
    AND             reduce using rule 142 (primary_expr -> io_expr .)
    OR              reduce using rule 142 (primary_expr -> io_expr .)
    XOR             reduce using rule 142 (primary_expr -> io_expr .)
    MOD             reduce using rule 142 (primary_expr -> io_expr .)
    LSHIFT          reduce using rule 142 (primary_expr -> io_expr .)
    RSHIFT          reduce using rule 142 (primary_expr -> io_expr .)
    LOGICAL_OR      reduce using rule 142 (primary_expr -> io_expr .)
    LOGICAL_AND     reduce using rule 142 (primary_expr -> io_expr .)
    NOT_EQUAL       reduce using rule 142 (primary_expr -> io_expr .)
    EQUAL           reduce using rule 142 (primary_expr -> io_expr .)
    LESS_EQUAL      reduce using rule 142 (primary_expr -> io_expr .)
    LESS            reduce using rule 142 (primary_expr -> io_expr .)
    GREATER_EQUAL   reduce using rule 142 (primary_expr -> io_expr .)
    GREATER         reduce using rule 142 (primary_expr -> io_expr .)
    SEMICOLON       reduce using rule 142 (primary_expr -> io_expr .)
    RPAREN          reduce using rule 142 (primary_expr -> io_expr .)
    COMMA           reduce using rule 142 (primary_expr -> io_expr .)
    RBRACKET        reduce using rule 142 (primary_expr -> io_expr .)


state 117

    (143) operand -> INT .

    LBRACKET        reduce using rule 143 (operand -> INT .)
    LANGRBRACKET    reduce using rule 143 (operand -> INT .)
    LPAREN          reduce using rule 143 (operand -> INT .)
    ASSIGN          reduce using rule 143 (operand -> INT .)
    PLUS            reduce using rule 143 (operand -> INT .)
    MINUS           reduce using rule 143 (operand -> INT .)
    MUL             reduce using rule 143 (operand -> INT .)
    DIV             reduce using rule 143 (operand -> INT .)
    AND             reduce using rule 143 (operand -> INT .)
    OR              reduce using rule 143 (operand -> INT .)
    XOR             reduce using rule 143 (operand -> INT .)
    MOD             reduce using rule 143 (operand -> INT .)
    LSHIFT          reduce using rule 143 (operand -> INT .)
    RSHIFT          reduce using rule 143 (operand -> INT .)
    LOGICAL_OR      reduce using rule 143 (operand -> INT .)
    LOGICAL_AND     reduce using rule 143 (operand -> INT .)
    NOT_EQUAL       reduce using rule 143 (operand -> INT .)
    EQUAL           reduce using rule 143 (operand -> INT .)
    LESS_EQUAL      reduce using rule 143 (operand -> INT .)
    LESS            reduce using rule 143 (operand -> INT .)
    GREATER_EQUAL   reduce using rule 143 (operand -> INT .)
    GREATER         reduce using rule 143 (operand -> INT .)
    SEMICOLON       reduce using rule 143 (operand -> INT .)
    RPAREN          reduce using rule 143 (operand -> INT .)
    COMMA           reduce using rule 143 (operand -> INT .)
    RBRACKET        reduce using rule 143 (operand -> INT .)


state 118

    (144) operand -> HEXADECIMAL .

    LBRACKET        reduce using rule 144 (operand -> HEXADECIMAL .)
    LANGRBRACKET    reduce using rule 144 (operand -> HEXADECIMAL .)
    LPAREN          reduce using rule 144 (operand -> HEXADECIMAL .)
    ASSIGN          reduce using rule 144 (operand -> HEXADECIMAL .)
    PLUS            reduce using rule 144 (operand -> HEXADECIMAL .)
    MINUS           reduce using rule 144 (operand -> HEXADECIMAL .)
    MUL             reduce using rule 144 (operand -> HEXADECIMAL .)
    DIV             reduce using rule 144 (operand -> HEXADECIMAL .)
    AND             reduce using rule 144 (operand -> HEXADECIMAL .)
    OR              reduce using rule 144 (operand -> HEXADECIMAL .)
    XOR             reduce using rule 144 (operand -> HEXADECIMAL .)
    MOD             reduce using rule 144 (operand -> HEXADECIMAL .)
    LSHIFT          reduce using rule 144 (operand -> HEXADECIMAL .)
    RSHIFT          reduce using rule 144 (operand -> HEXADECIMAL .)
    LOGICAL_OR      reduce using rule 144 (operand -> HEXADECIMAL .)
    LOGICAL_AND     reduce using rule 144 (operand -> HEXADECIMAL .)
    NOT_EQUAL       reduce using rule 144 (operand -> HEXADECIMAL .)
    EQUAL           reduce using rule 144 (operand -> HEXADECIMAL .)
    LESS_EQUAL      reduce using rule 144 (operand -> HEXADECIMAL .)
    LESS            reduce using rule 144 (operand -> HEXADECIMAL .)
    GREATER_EQUAL   reduce using rule 144 (operand -> HEXADECIMAL .)
    GREATER         reduce using rule 144 (operand -> HEXADECIMAL .)
    SEMICOLON       reduce using rule 144 (operand -> HEXADECIMAL .)
    RPAREN          reduce using rule 144 (operand -> HEXADECIMAL .)
    COMMA           reduce using rule 144 (operand -> HEXADECIMAL .)
    RBRACKET        reduce using rule 144 (operand -> HEXADECIMAL .)


state 119

    (145) operand -> FLOAT .

    LBRACKET        reduce using rule 145 (operand -> FLOAT .)
    LANGRBRACKET    reduce using rule 145 (operand -> FLOAT .)
    LPAREN          reduce using rule 145 (operand -> FLOAT .)
    ASSIGN          reduce using rule 145 (operand -> FLOAT .)
    PLUS            reduce using rule 145 (operand -> FLOAT .)
    MINUS           reduce using rule 145 (operand -> FLOAT .)
    MUL             reduce using rule 145 (operand -> FLOAT .)
    DIV             reduce using rule 145 (operand -> FLOAT .)
    AND             reduce using rule 145 (operand -> FLOAT .)
    OR              reduce using rule 145 (operand -> FLOAT .)
    XOR             reduce using rule 145 (operand -> FLOAT .)
    MOD             reduce using rule 145 (operand -> FLOAT .)
    LSHIFT          reduce using rule 145 (operand -> FLOAT .)
    RSHIFT          reduce using rule 145 (operand -> FLOAT .)
    LOGICAL_OR      reduce using rule 145 (operand -> FLOAT .)
    LOGICAL_AND     reduce using rule 145 (operand -> FLOAT .)
    NOT_EQUAL       reduce using rule 145 (operand -> FLOAT .)
    EQUAL           reduce using rule 145 (operand -> FLOAT .)
    LESS_EQUAL      reduce using rule 145 (operand -> FLOAT .)
    LESS            reduce using rule 145 (operand -> FLOAT .)
    GREATER_EQUAL   reduce using rule 145 (operand -> FLOAT .)
    GREATER         reduce using rule 145 (operand -> FLOAT .)
    SEMICOLON       reduce using rule 145 (operand -> FLOAT .)
    RPAREN          reduce using rule 145 (operand -> FLOAT .)
    COMMA           reduce using rule 145 (operand -> FLOAT .)
    RBRACKET        reduce using rule 145 (operand -> FLOAT .)


state 120

    (146) operand -> DOUBLE .

    LBRACKET        reduce using rule 146 (operand -> DOUBLE .)
    LANGRBRACKET    reduce using rule 146 (operand -> DOUBLE .)
    LPAREN          reduce using rule 146 (operand -> DOUBLE .)
    ASSIGN          reduce using rule 146 (operand -> DOUBLE .)
    PLUS            reduce using rule 146 (operand -> DOUBLE .)
    MINUS           reduce using rule 146 (operand -> DOUBLE .)
    MUL             reduce using rule 146 (operand -> DOUBLE .)
    DIV             reduce using rule 146 (operand -> DOUBLE .)
    AND             reduce using rule 146 (operand -> DOUBLE .)
    OR              reduce using rule 146 (operand -> DOUBLE .)
    XOR             reduce using rule 146 (operand -> DOUBLE .)
    MOD             reduce using rule 146 (operand -> DOUBLE .)
    LSHIFT          reduce using rule 146 (operand -> DOUBLE .)
    RSHIFT          reduce using rule 146 (operand -> DOUBLE .)
    LOGICAL_OR      reduce using rule 146 (operand -> DOUBLE .)
    LOGICAL_AND     reduce using rule 146 (operand -> DOUBLE .)
    NOT_EQUAL       reduce using rule 146 (operand -> DOUBLE .)
    EQUAL           reduce using rule 146 (operand -> DOUBLE .)
    LESS_EQUAL      reduce using rule 146 (operand -> DOUBLE .)
    LESS            reduce using rule 146 (operand -> DOUBLE .)
    GREATER_EQUAL   reduce using rule 146 (operand -> DOUBLE .)
    GREATER         reduce using rule 146 (operand -> DOUBLE .)
    SEMICOLON       reduce using rule 146 (operand -> DOUBLE .)
    RPAREN          reduce using rule 146 (operand -> DOUBLE .)
    COMMA           reduce using rule 146 (operand -> DOUBLE .)
    RBRACKET        reduce using rule 146 (operand -> DOUBLE .)


state 121

    (147) operand -> STRING .

    LBRACKET        reduce using rule 147 (operand -> STRING .)
    LANGRBRACKET    reduce using rule 147 (operand -> STRING .)
    LPAREN          reduce using rule 147 (operand -> STRING .)
    ASSIGN          reduce using rule 147 (operand -> STRING .)
    PLUS            reduce using rule 147 (operand -> STRING .)
    MINUS           reduce using rule 147 (operand -> STRING .)
    MUL             reduce using rule 147 (operand -> STRING .)
    DIV             reduce using rule 147 (operand -> STRING .)
    AND             reduce using rule 147 (operand -> STRING .)
    OR              reduce using rule 147 (operand -> STRING .)
    XOR             reduce using rule 147 (operand -> STRING .)
    MOD             reduce using rule 147 (operand -> STRING .)
    LSHIFT          reduce using rule 147 (operand -> STRING .)
    RSHIFT          reduce using rule 147 (operand -> STRING .)
    LOGICAL_OR      reduce using rule 147 (operand -> STRING .)
    LOGICAL_AND     reduce using rule 147 (operand -> STRING .)
    NOT_EQUAL       reduce using rule 147 (operand -> STRING .)
    EQUAL           reduce using rule 147 (operand -> STRING .)
    LESS_EQUAL      reduce using rule 147 (operand -> STRING .)
    LESS            reduce using rule 147 (operand -> STRING .)
    GREATER_EQUAL   reduce using rule 147 (operand -> STRING .)
    GREATER         reduce using rule 147 (operand -> STRING .)
    SEMICOLON       reduce using rule 147 (operand -> STRING .)
    RPAREN          reduce using rule 147 (operand -> STRING .)
    COMMA           reduce using rule 147 (operand -> STRING .)
    RBRACKET        reduce using rule 147 (operand -> STRING .)


state 122

    (148) operand -> ID .
    (150) member_expr -> ID . DOT ID
    (41) complex_type -> ID . generics_specialization_list_opt
    (42) generic_type -> ID .
    (157) generics_specialization_list_opt -> . LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET
    (158) generics_specialization_list_opt -> . empty
    (167) empty -> .

  ! reduce/reduce conflict for LPAREN resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 42 (generic_type -> ID .)
  ! shift/reduce conflict for LANGRBRACKET resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for REF resolved using rule 42 (generic_type -> ID .)
    ASSIGN          reduce using rule 148 (operand -> ID .)
    PLUS            reduce using rule 148 (operand -> ID .)
    MINUS           reduce using rule 148 (operand -> ID .)
    MUL             reduce using rule 148 (operand -> ID .)
    DIV             reduce using rule 148 (operand -> ID .)
    AND             reduce using rule 148 (operand -> ID .)
    OR              reduce using rule 148 (operand -> ID .)
    XOR             reduce using rule 148 (operand -> ID .)
    MOD             reduce using rule 148 (operand -> ID .)
    LSHIFT          reduce using rule 148 (operand -> ID .)
    RSHIFT          reduce using rule 148 (operand -> ID .)
    LOGICAL_OR      reduce using rule 148 (operand -> ID .)
    LOGICAL_AND     reduce using rule 148 (operand -> ID .)
    NOT_EQUAL       reduce using rule 148 (operand -> ID .)
    EQUAL           reduce using rule 148 (operand -> ID .)
    LESS_EQUAL      reduce using rule 148 (operand -> ID .)
    LESS            reduce using rule 148 (operand -> ID .)
    GREATER_EQUAL   reduce using rule 148 (operand -> ID .)
    GREATER         reduce using rule 148 (operand -> ID .)
    SEMICOLON       reduce using rule 148 (operand -> ID .)
    RPAREN          reduce using rule 148 (operand -> ID .)
    COMMA           reduce using rule 148 (operand -> ID .)
    RBRACKET        reduce using rule 148 (operand -> ID .)
    DOT             shift and go to state 190
    LPAREN          reduce using rule 42 (generic_type -> ID .)
    LBRACKET        reduce using rule 42 (generic_type -> ID .)
    REF             reduce using rule 42 (generic_type -> ID .)
    LANGRBRACKET    shift and go to state 188

  ! LBRACKET        [ reduce using rule 148 (operand -> ID .) ]
  ! LANGRBRACKET    [ reduce using rule 148 (operand -> ID .) ]
  ! LPAREN          [ reduce using rule 148 (operand -> ID .) ]
  ! LPAREN          [ reduce using rule 167 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 167 (empty -> .) ]
  ! REF             [ reduce using rule 167 (empty -> .) ]

    generics_specialization_list_opt shift and go to state 191
    empty                          shift and go to state 189

state 123

    (149) operand -> LPAREN . expression RPAREN
    (152) cast_expr -> LPAREN . type_spec RPAREN expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . array_type
    (26) type_spec -> . reference_type
    (27) type_spec -> . function_type
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (28) simple_type -> . VOID
    (29) simple_type -> . BOOL
    (30) simple_type -> . I8
    (31) simple_type -> . U8
    (32) simple_type -> . I16
    (33) simple_type -> . U16
    (34) simple_type -> . I32
    (35) simple_type -> . U32
    (36) simple_type -> . I64
    (37) simple_type -> . U64
    (38) simple_type -> . F16
    (39) simple_type -> . F32
    (40) simple_type -> . F64
    (41) complex_type -> . ID generics_specialization_list_opt
    (42) generic_type -> . ID
    (43) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> . type_spec REF
    (47) function_type -> . function_sign
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (167) empty -> .
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for I8 resolved as shift
  ! shift/reduce conflict for U8 resolved as shift
  ! shift/reduce conflict for I16 resolved as shift
  ! shift/reduce conflict for U16 resolved as shift
  ! shift/reduce conflict for I32 resolved as shift
  ! shift/reduce conflict for U32 resolved as shift
  ! shift/reduce conflict for I64 resolved as shift
  ! shift/reduce conflict for U64 resolved as shift
  ! shift/reduce conflict for F16 resolved as shift
  ! shift/reduce conflict for F32 resolved as shift
  ! shift/reduce conflict for F64 resolved as shift
  ! shift/reduce conflict for LANGRBRACKET resolved as shift
    VOID            shift and go to state 134
    BOOL            shift and go to state 135
    I8              shift and go to state 136
    U8              shift and go to state 137
    I16             shift and go to state 138
    U16             shift and go to state 139
    I32             shift and go to state 140
    U32             shift and go to state 141
    I64             shift and go to state 142
    U64             shift and go to state 143
    F16             shift and go to state 144
    F32             shift and go to state 145
    F64             shift and go to state 146
    ID              shift and go to state 151
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    LANGRBRACKET    shift and go to state 74

  ! ID              [ reduce using rule 167 (empty -> .) ]
  ! VOID            [ reduce using rule 167 (empty -> .) ]
  ! BOOL            [ reduce using rule 167 (empty -> .) ]
  ! I8              [ reduce using rule 167 (empty -> .) ]
  ! U8              [ reduce using rule 167 (empty -> .) ]
  ! I16             [ reduce using rule 167 (empty -> .) ]
  ! U16             [ reduce using rule 167 (empty -> .) ]
  ! I32             [ reduce using rule 167 (empty -> .) ]
  ! U32             [ reduce using rule 167 (empty -> .) ]
  ! I64             [ reduce using rule 167 (empty -> .) ]
  ! U64             [ reduce using rule 167 (empty -> .) ]
  ! F16             [ reduce using rule 167 (empty -> .) ]
  ! F32             [ reduce using rule 167 (empty -> .) ]
  ! F64             [ reduce using rule 167 (empty -> .) ]
  ! LANGRBRACKET    [ reduce using rule 167 (empty -> .) ]

    expression                     shift and go to state 192
    type_spec                      shift and go to state 193
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    simple_type                    shift and go to state 126
    complex_type                   shift and go to state 127
    generic_type                   shift and go to state 128
    array_type                     shift and go to state 129
    reference_type                 shift and go to state 130
    function_type                  shift and go to state 131
    unary_operation_opt            shift and go to state 60
    function_sign                  shift and go to state 147
    empty                          shift and go to state 194
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72

state 124

    (153) new_expr -> type_spec . LPAREN parameter_list_opt RPAREN
    (43) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> type_spec . REF

    LPAREN          shift and go to state 195
    LBRACKET        shift and go to state 196
    REF             shift and go to state 197


state 125

    (164) io_expr -> in_out . LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN

    LANGRBRACKET    shift and go to state 198


state 126

    (22) type_spec -> simple_type .

    LPAREN          reduce using rule 22 (type_spec -> simple_type .)
    LBRACKET        reduce using rule 22 (type_spec -> simple_type .)
    REF             reduce using rule 22 (type_spec -> simple_type .)
    ASSIGN          reduce using rule 22 (type_spec -> simple_type .)
    COMMA           reduce using rule 22 (type_spec -> simple_type .)
    RPAREN          reduce using rule 22 (type_spec -> simple_type .)
    SEMICOLON       reduce using rule 22 (type_spec -> simple_type .)
    RANGRBRACKET    reduce using rule 22 (type_spec -> simple_type .)
    LANGRBRACKET    reduce using rule 22 (type_spec -> simple_type .)
    LBRACE          reduce using rule 22 (type_spec -> simple_type .)


state 127

    (23) type_spec -> complex_type .

    LPAREN          reduce using rule 23 (type_spec -> complex_type .)
    LBRACKET        reduce using rule 23 (type_spec -> complex_type .)
    REF             reduce using rule 23 (type_spec -> complex_type .)
    ASSIGN          reduce using rule 23 (type_spec -> complex_type .)
    COMMA           reduce using rule 23 (type_spec -> complex_type .)
    RPAREN          reduce using rule 23 (type_spec -> complex_type .)
    SEMICOLON       reduce using rule 23 (type_spec -> complex_type .)
    RANGRBRACKET    reduce using rule 23 (type_spec -> complex_type .)
    LANGRBRACKET    reduce using rule 23 (type_spec -> complex_type .)
    LBRACE          reduce using rule 23 (type_spec -> complex_type .)


state 128

    (24) type_spec -> generic_type .

    LPAREN          reduce using rule 24 (type_spec -> generic_type .)
    LBRACKET        reduce using rule 24 (type_spec -> generic_type .)
    REF             reduce using rule 24 (type_spec -> generic_type .)
    ASSIGN          reduce using rule 24 (type_spec -> generic_type .)
    COMMA           reduce using rule 24 (type_spec -> generic_type .)
    RPAREN          reduce using rule 24 (type_spec -> generic_type .)
    SEMICOLON       reduce using rule 24 (type_spec -> generic_type .)
    RANGRBRACKET    reduce using rule 24 (type_spec -> generic_type .)
    LANGRBRACKET    reduce using rule 24 (type_spec -> generic_type .)
    LBRACE          reduce using rule 24 (type_spec -> generic_type .)


state 129

    (25) type_spec -> array_type .

    LPAREN          reduce using rule 25 (type_spec -> array_type .)
    LBRACKET        reduce using rule 25 (type_spec -> array_type .)
    REF             reduce using rule 25 (type_spec -> array_type .)
    ASSIGN          reduce using rule 25 (type_spec -> array_type .)
    COMMA           reduce using rule 25 (type_spec -> array_type .)
    RPAREN          reduce using rule 25 (type_spec -> array_type .)
    SEMICOLON       reduce using rule 25 (type_spec -> array_type .)
    RANGRBRACKET    reduce using rule 25 (type_spec -> array_type .)
    LANGRBRACKET    reduce using rule 25 (type_spec -> array_type .)
    LBRACE          reduce using rule 25 (type_spec -> array_type .)


state 130

    (26) type_spec -> reference_type .

    LPAREN          reduce using rule 26 (type_spec -> reference_type .)
    LBRACKET        reduce using rule 26 (type_spec -> reference_type .)
    REF             reduce using rule 26 (type_spec -> reference_type .)
    ASSIGN          reduce using rule 26 (type_spec -> reference_type .)
    COMMA           reduce using rule 26 (type_spec -> reference_type .)
    RPAREN          reduce using rule 26 (type_spec -> reference_type .)
    SEMICOLON       reduce using rule 26 (type_spec -> reference_type .)
    RANGRBRACKET    reduce using rule 26 (type_spec -> reference_type .)
    LANGRBRACKET    reduce using rule 26 (type_spec -> reference_type .)
    LBRACE          reduce using rule 26 (type_spec -> reference_type .)


state 131

    (27) type_spec -> function_type .

    LPAREN          reduce using rule 27 (type_spec -> function_type .)
    LBRACKET        reduce using rule 27 (type_spec -> function_type .)
    REF             reduce using rule 27 (type_spec -> function_type .)
    ASSIGN          reduce using rule 27 (type_spec -> function_type .)
    COMMA           reduce using rule 27 (type_spec -> function_type .)
    RPAREN          reduce using rule 27 (type_spec -> function_type .)
    SEMICOLON       reduce using rule 27 (type_spec -> function_type .)
    RANGRBRACKET    reduce using rule 27 (type_spec -> function_type .)
    LANGRBRACKET    reduce using rule 27 (type_spec -> function_type .)
    LBRACE          reduce using rule 27 (type_spec -> function_type .)


state 132

    (165) in_out -> IN .

    LANGRBRACKET    reduce using rule 165 (in_out -> IN .)


state 133

    (166) in_out -> OUT .

    LANGRBRACKET    reduce using rule 166 (in_out -> OUT .)


state 134

    (28) simple_type -> VOID .

    LPAREN          reduce using rule 28 (simple_type -> VOID .)
    LBRACKET        reduce using rule 28 (simple_type -> VOID .)
    REF             reduce using rule 28 (simple_type -> VOID .)
    ASSIGN          reduce using rule 28 (simple_type -> VOID .)
    COMMA           reduce using rule 28 (simple_type -> VOID .)
    RPAREN          reduce using rule 28 (simple_type -> VOID .)
    SEMICOLON       reduce using rule 28 (simple_type -> VOID .)
    RANGRBRACKET    reduce using rule 28 (simple_type -> VOID .)
    LANGRBRACKET    reduce using rule 28 (simple_type -> VOID .)
    LBRACE          reduce using rule 28 (simple_type -> VOID .)


state 135

    (29) simple_type -> BOOL .

    LPAREN          reduce using rule 29 (simple_type -> BOOL .)
    LBRACKET        reduce using rule 29 (simple_type -> BOOL .)
    REF             reduce using rule 29 (simple_type -> BOOL .)
    ASSIGN          reduce using rule 29 (simple_type -> BOOL .)
    COMMA           reduce using rule 29 (simple_type -> BOOL .)
    RPAREN          reduce using rule 29 (simple_type -> BOOL .)
    SEMICOLON       reduce using rule 29 (simple_type -> BOOL .)
    RANGRBRACKET    reduce using rule 29 (simple_type -> BOOL .)
    LANGRBRACKET    reduce using rule 29 (simple_type -> BOOL .)
    LBRACE          reduce using rule 29 (simple_type -> BOOL .)


state 136

    (30) simple_type -> I8 .

    LPAREN          reduce using rule 30 (simple_type -> I8 .)
    LBRACKET        reduce using rule 30 (simple_type -> I8 .)
    REF             reduce using rule 30 (simple_type -> I8 .)
    ASSIGN          reduce using rule 30 (simple_type -> I8 .)
    COMMA           reduce using rule 30 (simple_type -> I8 .)
    RPAREN          reduce using rule 30 (simple_type -> I8 .)
    SEMICOLON       reduce using rule 30 (simple_type -> I8 .)
    RANGRBRACKET    reduce using rule 30 (simple_type -> I8 .)
    LANGRBRACKET    reduce using rule 30 (simple_type -> I8 .)
    LBRACE          reduce using rule 30 (simple_type -> I8 .)


state 137

    (31) simple_type -> U8 .

    LPAREN          reduce using rule 31 (simple_type -> U8 .)
    LBRACKET        reduce using rule 31 (simple_type -> U8 .)
    REF             reduce using rule 31 (simple_type -> U8 .)
    ASSIGN          reduce using rule 31 (simple_type -> U8 .)
    COMMA           reduce using rule 31 (simple_type -> U8 .)
    RPAREN          reduce using rule 31 (simple_type -> U8 .)
    SEMICOLON       reduce using rule 31 (simple_type -> U8 .)
    RANGRBRACKET    reduce using rule 31 (simple_type -> U8 .)
    LANGRBRACKET    reduce using rule 31 (simple_type -> U8 .)
    LBRACE          reduce using rule 31 (simple_type -> U8 .)


state 138

    (32) simple_type -> I16 .

    LPAREN          reduce using rule 32 (simple_type -> I16 .)
    LBRACKET        reduce using rule 32 (simple_type -> I16 .)
    REF             reduce using rule 32 (simple_type -> I16 .)
    ASSIGN          reduce using rule 32 (simple_type -> I16 .)
    COMMA           reduce using rule 32 (simple_type -> I16 .)
    RPAREN          reduce using rule 32 (simple_type -> I16 .)
    SEMICOLON       reduce using rule 32 (simple_type -> I16 .)
    RANGRBRACKET    reduce using rule 32 (simple_type -> I16 .)
    LANGRBRACKET    reduce using rule 32 (simple_type -> I16 .)
    LBRACE          reduce using rule 32 (simple_type -> I16 .)


state 139

    (33) simple_type -> U16 .

    LPAREN          reduce using rule 33 (simple_type -> U16 .)
    LBRACKET        reduce using rule 33 (simple_type -> U16 .)
    REF             reduce using rule 33 (simple_type -> U16 .)
    ASSIGN          reduce using rule 33 (simple_type -> U16 .)
    COMMA           reduce using rule 33 (simple_type -> U16 .)
    RPAREN          reduce using rule 33 (simple_type -> U16 .)
    SEMICOLON       reduce using rule 33 (simple_type -> U16 .)
    RANGRBRACKET    reduce using rule 33 (simple_type -> U16 .)
    LANGRBRACKET    reduce using rule 33 (simple_type -> U16 .)
    LBRACE          reduce using rule 33 (simple_type -> U16 .)


state 140

    (34) simple_type -> I32 .

    LPAREN          reduce using rule 34 (simple_type -> I32 .)
    LBRACKET        reduce using rule 34 (simple_type -> I32 .)
    REF             reduce using rule 34 (simple_type -> I32 .)
    ASSIGN          reduce using rule 34 (simple_type -> I32 .)
    COMMA           reduce using rule 34 (simple_type -> I32 .)
    RPAREN          reduce using rule 34 (simple_type -> I32 .)
    SEMICOLON       reduce using rule 34 (simple_type -> I32 .)
    RANGRBRACKET    reduce using rule 34 (simple_type -> I32 .)
    LANGRBRACKET    reduce using rule 34 (simple_type -> I32 .)
    LBRACE          reduce using rule 34 (simple_type -> I32 .)


state 141

    (35) simple_type -> U32 .

    LPAREN          reduce using rule 35 (simple_type -> U32 .)
    LBRACKET        reduce using rule 35 (simple_type -> U32 .)
    REF             reduce using rule 35 (simple_type -> U32 .)
    ASSIGN          reduce using rule 35 (simple_type -> U32 .)
    COMMA           reduce using rule 35 (simple_type -> U32 .)
    RPAREN          reduce using rule 35 (simple_type -> U32 .)
    SEMICOLON       reduce using rule 35 (simple_type -> U32 .)
    RANGRBRACKET    reduce using rule 35 (simple_type -> U32 .)
    LANGRBRACKET    reduce using rule 35 (simple_type -> U32 .)
    LBRACE          reduce using rule 35 (simple_type -> U32 .)


state 142

    (36) simple_type -> I64 .

    LPAREN          reduce using rule 36 (simple_type -> I64 .)
    LBRACKET        reduce using rule 36 (simple_type -> I64 .)
    REF             reduce using rule 36 (simple_type -> I64 .)
    ASSIGN          reduce using rule 36 (simple_type -> I64 .)
    COMMA           reduce using rule 36 (simple_type -> I64 .)
    RPAREN          reduce using rule 36 (simple_type -> I64 .)
    SEMICOLON       reduce using rule 36 (simple_type -> I64 .)
    RANGRBRACKET    reduce using rule 36 (simple_type -> I64 .)
    LANGRBRACKET    reduce using rule 36 (simple_type -> I64 .)
    LBRACE          reduce using rule 36 (simple_type -> I64 .)


state 143

    (37) simple_type -> U64 .

    LPAREN          reduce using rule 37 (simple_type -> U64 .)
    LBRACKET        reduce using rule 37 (simple_type -> U64 .)
    REF             reduce using rule 37 (simple_type -> U64 .)
    ASSIGN          reduce using rule 37 (simple_type -> U64 .)
    COMMA           reduce using rule 37 (simple_type -> U64 .)
    RPAREN          reduce using rule 37 (simple_type -> U64 .)
    SEMICOLON       reduce using rule 37 (simple_type -> U64 .)
    RANGRBRACKET    reduce using rule 37 (simple_type -> U64 .)
    LANGRBRACKET    reduce using rule 37 (simple_type -> U64 .)
    LBRACE          reduce using rule 37 (simple_type -> U64 .)


state 144

    (38) simple_type -> F16 .

    LPAREN          reduce using rule 38 (simple_type -> F16 .)
    LBRACKET        reduce using rule 38 (simple_type -> F16 .)
    REF             reduce using rule 38 (simple_type -> F16 .)
    ASSIGN          reduce using rule 38 (simple_type -> F16 .)
    COMMA           reduce using rule 38 (simple_type -> F16 .)
    RPAREN          reduce using rule 38 (simple_type -> F16 .)
    SEMICOLON       reduce using rule 38 (simple_type -> F16 .)
    RANGRBRACKET    reduce using rule 38 (simple_type -> F16 .)
    LANGRBRACKET    reduce using rule 38 (simple_type -> F16 .)
    LBRACE          reduce using rule 38 (simple_type -> F16 .)


state 145

    (39) simple_type -> F32 .

    LPAREN          reduce using rule 39 (simple_type -> F32 .)
    LBRACKET        reduce using rule 39 (simple_type -> F32 .)
    REF             reduce using rule 39 (simple_type -> F32 .)
    ASSIGN          reduce using rule 39 (simple_type -> F32 .)
    COMMA           reduce using rule 39 (simple_type -> F32 .)
    RPAREN          reduce using rule 39 (simple_type -> F32 .)
    SEMICOLON       reduce using rule 39 (simple_type -> F32 .)
    RANGRBRACKET    reduce using rule 39 (simple_type -> F32 .)
    LANGRBRACKET    reduce using rule 39 (simple_type -> F32 .)
    LBRACE          reduce using rule 39 (simple_type -> F32 .)


state 146

    (40) simple_type -> F64 .

    LPAREN          reduce using rule 40 (simple_type -> F64 .)
    LBRACKET        reduce using rule 40 (simple_type -> F64 .)
    REF             reduce using rule 40 (simple_type -> F64 .)
    ASSIGN          reduce using rule 40 (simple_type -> F64 .)
    COMMA           reduce using rule 40 (simple_type -> F64 .)
    RPAREN          reduce using rule 40 (simple_type -> F64 .)
    SEMICOLON       reduce using rule 40 (simple_type -> F64 .)
    RANGRBRACKET    reduce using rule 40 (simple_type -> F64 .)
    LANGRBRACKET    reduce using rule 40 (simple_type -> F64 .)
    LBRACE          reduce using rule 40 (simple_type -> F64 .)


state 147

    (47) function_type -> function_sign .

    LPAREN          reduce using rule 47 (function_type -> function_sign .)
    LBRACKET        reduce using rule 47 (function_type -> function_sign .)
    REF             reduce using rule 47 (function_type -> function_sign .)
    ASSIGN          reduce using rule 47 (function_type -> function_sign .)
    COMMA           reduce using rule 47 (function_type -> function_sign .)
    RPAREN          reduce using rule 47 (function_type -> function_sign .)
    SEMICOLON       reduce using rule 47 (function_type -> function_sign .)
    RANGRBRACKET    reduce using rule 47 (function_type -> function_sign .)
    LANGRBRACKET    reduce using rule 47 (function_type -> function_sign .)
    LBRACE          reduce using rule 47 (function_type -> function_sign .)


state 148

    (14) declarator_nest -> COMMA declarator . declarator_nest
    (14) declarator_nest -> . COMMA declarator declarator_nest
    (15) declarator_nest -> . empty
    (167) empty -> .

    COMMA           shift and go to state 64
    SEMICOLON       reduce using rule 167 (empty -> .)

    declarator_nest                shift and go to state 199
    empty                          shift and go to state 65

state 149

    (17) declarator -> ID type_spec_colon_opt ASSIGN . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 200
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 150

    (18) type_spec_colon_opt -> COLON type_spec .
    (43) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> type_spec . REF

    ASSIGN          reduce using rule 18 (type_spec_colon_opt -> COLON type_spec .)
    COMMA           reduce using rule 18 (type_spec_colon_opt -> COLON type_spec .)
    RPAREN          reduce using rule 18 (type_spec_colon_opt -> COLON type_spec .)
    SEMICOLON       reduce using rule 18 (type_spec_colon_opt -> COLON type_spec .)
    LBRACKET        shift and go to state 196
    REF             shift and go to state 197


state 151

    (41) complex_type -> ID . generics_specialization_list_opt
    (42) generic_type -> ID .
    (157) generics_specialization_list_opt -> . LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET
    (158) generics_specialization_list_opt -> . empty
    (167) empty -> .

  ! shift/reduce conflict for LANGRBRACKET resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for REF resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for ASSIGN resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for COMMA resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for RANGRBRACKET resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for LBRACE resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for LPAREN resolved using rule 42 (generic_type -> ID .)
  ! shift/reduce conflict for LANGRBRACKET resolved as shift
    LBRACKET        reduce using rule 42 (generic_type -> ID .)
    REF             reduce using rule 42 (generic_type -> ID .)
    ASSIGN          reduce using rule 42 (generic_type -> ID .)
    COMMA           reduce using rule 42 (generic_type -> ID .)
    RPAREN          reduce using rule 42 (generic_type -> ID .)
    SEMICOLON       reduce using rule 42 (generic_type -> ID .)
    RANGRBRACKET    reduce using rule 42 (generic_type -> ID .)
    LBRACE          reduce using rule 42 (generic_type -> ID .)
    LPAREN          reduce using rule 42 (generic_type -> ID .)
    LANGRBRACKET    shift and go to state 188

  ! LANGRBRACKET    [ reduce using rule 42 (generic_type -> ID .) ]
  ! LBRACKET        [ reduce using rule 167 (empty -> .) ]
  ! REF             [ reduce using rule 167 (empty -> .) ]
  ! ASSIGN          [ reduce using rule 167 (empty -> .) ]
  ! COMMA           [ reduce using rule 167 (empty -> .) ]
  ! RPAREN          [ reduce using rule 167 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 167 (empty -> .) ]
  ! RANGRBRACKET    [ reduce using rule 167 (empty -> .) ]
  ! LBRACE          [ reduce using rule 167 (empty -> .) ]
  ! LPAREN          [ reduce using rule 167 (empty -> .) ]
  ! LANGRBRACKET    [ reduce using rule 167 (empty -> .) ]

    generics_specialization_list_opt shift and go to state 191
    empty                          shift and go to state 189

state 152

    (67) function_sign -> generics_type_list_opt LPAREN . parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (68) parameter_decl_list_opt -> . parameter_decl parameter_decl_comma_nest
    (69) parameter_decl_list_opt -> . empty
    (74) parameter_decl -> . ID type_spec_colon_opt
    (167) empty -> .

    ID              shift and go to state 204
    RPAREN          reduce using rule 167 (empty -> .)

    parameter_decl_list_opt        shift and go to state 201
    parameter_decl                 shift and go to state 202
    empty                          shift and go to state 203

state 153

    (75) generics_type_list -> LANGRBRACKET generics_type . generics_type_comma_nest RANGRBRACKET
    (76) generics_type_comma_nest -> . COMMA generics_type generics_type_comma_nest
    (77) generics_type_comma_nest -> . empty
    (167) empty -> .

    COMMA           shift and go to state 206
    RANGRBRACKET    reduce using rule 167 (empty -> .)

    generics_type_comma_nest       shift and go to state 205
    empty                          shift and go to state 207

state 154

    (78) generics_type -> ID . generics_type_range_colon_opt
    (79) generics_type_range_colon_opt -> . COLON generics_type_range
    (80) generics_type_range_colon_opt -> . empty
    (167) empty -> .

    COLON           shift and go to state 209
    COMMA           reduce using rule 167 (empty -> .)
    RANGRBRACKET    reduce using rule 167 (empty -> .)

    generics_type_range_colon_opt  shift and go to state 208
    empty                          shift and go to state 210

state 155

    (12) type_alias_decl -> TYPE ID ASSIGN type_spec .
    (43) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> type_spec . REF

    SEMICOLON       reduce using rule 12 (type_alias_decl -> TYPE ID ASSIGN type_spec .)
    LBRACKET        shift and go to state 196
    REF             shift and go to state 197


state 156

    (48) struct_decl -> STRUCT ID generics_type_list_opt complex_type_colon_opt . LBRACE member_decl_nest RBRACE

    LBRACE          shift and go to state 211


state 157

    (49) complex_type_colon_opt -> COLON . complex_type
    (41) complex_type -> . ID generics_specialization_list_opt

    ID              shift and go to state 213

    complex_type                   shift and go to state 212

state 158

    (50) complex_type_colon_opt -> empty .

    LBRACE          reduce using rule 50 (complex_type_colon_opt -> empty .)


state 159

    (51) interface_decl -> INTERFACE ID generics_type_list_opt LBRACE . interface_member_decl_nest RBRACE
    (56) interface_member_decl_nest -> . interface_member_decl SEMICOLON interface_member_decl_nest
    (57) interface_member_decl_nest -> . empty
    (62) interface_member_decl -> . member_declarator
    (63) interface_member_decl -> . function_decl
    (64) interface_member_decl -> . type_function_decl
    (167) empty -> .
    (66) member_declarator -> . ID type_spec_colon_opt
    (20) function_decl -> . FUNC ID function_sign
    (65) type_function_decl -> . FUNC type_spec function_sign

    RBRACE          reduce using rule 167 (empty -> .)
    ID              shift and go to state 214
    FUNC            shift and go to state 221

    interface_member_decl_nest     shift and go to state 215
    interface_member_decl          shift and go to state 216
    empty                          shift and go to state 217
    member_declarator              shift and go to state 218
    function_decl                  shift and go to state 219
    type_function_decl             shift and go to state 220

state 160

    (96) if_statement -> IF LPAREN expression . RPAREN statement statement_else_opt
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    RPAREN          shift and go to state 222
    ASSIGN          shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_OR      shift and go to state 95
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102


state 161

    (135) unary_operation_opt -> empty .

    INT             reduce using rule 135 (unary_operation_opt -> empty .)
    HEXADECIMAL     reduce using rule 135 (unary_operation_opt -> empty .)
    FLOAT           reduce using rule 135 (unary_operation_opt -> empty .)
    DOUBLE          reduce using rule 135 (unary_operation_opt -> empty .)
    STRING          reduce using rule 135 (unary_operation_opt -> empty .)
    ID              reduce using rule 135 (unary_operation_opt -> empty .)
    LPAREN          reduce using rule 135 (unary_operation_opt -> empty .)
    IN              reduce using rule 135 (unary_operation_opt -> empty .)
    OUT             reduce using rule 135 (unary_operation_opt -> empty .)
    VOID            reduce using rule 135 (unary_operation_opt -> empty .)
    BOOL            reduce using rule 135 (unary_operation_opt -> empty .)
    I8              reduce using rule 135 (unary_operation_opt -> empty .)
    U8              reduce using rule 135 (unary_operation_opt -> empty .)
    I16             reduce using rule 135 (unary_operation_opt -> empty .)
    U16             reduce using rule 135 (unary_operation_opt -> empty .)
    I32             reduce using rule 135 (unary_operation_opt -> empty .)
    U32             reduce using rule 135 (unary_operation_opt -> empty .)
    I64             reduce using rule 135 (unary_operation_opt -> empty .)
    U64             reduce using rule 135 (unary_operation_opt -> empty .)
    F16             reduce using rule 135 (unary_operation_opt -> empty .)
    F32             reduce using rule 135 (unary_operation_opt -> empty .)
    F64             reduce using rule 135 (unary_operation_opt -> empty .)
    LANGRBRACKET    reduce using rule 135 (unary_operation_opt -> empty .)


state 162

    (111) assign_expr -> expression ASSIGN expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
    SEMICOLON       reduce using rule 111 (assign_expr -> expression ASSIGN expression .)
    RPAREN          reduce using rule 111 (assign_expr -> expression ASSIGN expression .)
    LBRACKET        reduce using rule 111 (assign_expr -> expression ASSIGN expression .)
    LANGRBRACKET    reduce using rule 111 (assign_expr -> expression ASSIGN expression .)
    LPAREN          reduce using rule 111 (assign_expr -> expression ASSIGN expression .)
    COMMA           reduce using rule 111 (assign_expr -> expression ASSIGN expression .)
    RBRACKET        reduce using rule 111 (assign_expr -> expression ASSIGN expression .)
    ASSIGN          shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_OR      shift and go to state 95
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102

  ! ASSIGN          [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! PLUS            [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! MINUS           [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! MUL             [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! DIV             [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! AND             [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! OR              [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! XOR             [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! MOD             [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! LSHIFT          [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! RSHIFT          [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! LOGICAL_OR      [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! LOGICAL_AND     [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! NOT_EQUAL       [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! EQUAL           [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! LESS_EQUAL      [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! LESS            [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]
  ! GREATER         [ reduce using rule 111 (assign_expr -> expression ASSIGN expression .) ]


state 163

    (112) binary_expr -> expression PLUS expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 112 (binary_expr -> expression PLUS expression .)
    PLUS            reduce using rule 112 (binary_expr -> expression PLUS expression .)
    MINUS           reduce using rule 112 (binary_expr -> expression PLUS expression .)
    AND             reduce using rule 112 (binary_expr -> expression PLUS expression .)
    OR              reduce using rule 112 (binary_expr -> expression PLUS expression .)
    XOR             reduce using rule 112 (binary_expr -> expression PLUS expression .)
    LSHIFT          reduce using rule 112 (binary_expr -> expression PLUS expression .)
    RSHIFT          reduce using rule 112 (binary_expr -> expression PLUS expression .)
    LOGICAL_OR      reduce using rule 112 (binary_expr -> expression PLUS expression .)
    LOGICAL_AND     reduce using rule 112 (binary_expr -> expression PLUS expression .)
    NOT_EQUAL       reduce using rule 112 (binary_expr -> expression PLUS expression .)
    EQUAL           reduce using rule 112 (binary_expr -> expression PLUS expression .)
    LESS_EQUAL      reduce using rule 112 (binary_expr -> expression PLUS expression .)
    LESS            reduce using rule 112 (binary_expr -> expression PLUS expression .)
    GREATER_EQUAL   reduce using rule 112 (binary_expr -> expression PLUS expression .)
    GREATER         reduce using rule 112 (binary_expr -> expression PLUS expression .)
    SEMICOLON       reduce using rule 112 (binary_expr -> expression PLUS expression .)
    RPAREN          reduce using rule 112 (binary_expr -> expression PLUS expression .)
    LBRACKET        reduce using rule 112 (binary_expr -> expression PLUS expression .)
    LANGRBRACKET    reduce using rule 112 (binary_expr -> expression PLUS expression .)
    LPAREN          reduce using rule 112 (binary_expr -> expression PLUS expression .)
    COMMA           reduce using rule 112 (binary_expr -> expression PLUS expression .)
    RBRACKET        reduce using rule 112 (binary_expr -> expression PLUS expression .)
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    MOD             shift and go to state 92

  ! MUL             [ reduce using rule 112 (binary_expr -> expression PLUS expression .) ]
  ! DIV             [ reduce using rule 112 (binary_expr -> expression PLUS expression .) ]
  ! MOD             [ reduce using rule 112 (binary_expr -> expression PLUS expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! PLUS            [ shift and go to state 85 ]
  ! MINUS           [ shift and go to state 86 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 93 ]
  ! RSHIFT          [ shift and go to state 94 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]
  ! LESS_EQUAL      [ shift and go to state 99 ]
  ! LESS            [ shift and go to state 100 ]
  ! GREATER_EQUAL   [ shift and go to state 101 ]
  ! GREATER         [ shift and go to state 102 ]


state 164

    (113) binary_expr -> expression MINUS expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 113 (binary_expr -> expression MINUS expression .)
    PLUS            reduce using rule 113 (binary_expr -> expression MINUS expression .)
    MINUS           reduce using rule 113 (binary_expr -> expression MINUS expression .)
    AND             reduce using rule 113 (binary_expr -> expression MINUS expression .)
    OR              reduce using rule 113 (binary_expr -> expression MINUS expression .)
    XOR             reduce using rule 113 (binary_expr -> expression MINUS expression .)
    LSHIFT          reduce using rule 113 (binary_expr -> expression MINUS expression .)
    RSHIFT          reduce using rule 113 (binary_expr -> expression MINUS expression .)
    LOGICAL_OR      reduce using rule 113 (binary_expr -> expression MINUS expression .)
    LOGICAL_AND     reduce using rule 113 (binary_expr -> expression MINUS expression .)
    NOT_EQUAL       reduce using rule 113 (binary_expr -> expression MINUS expression .)
    EQUAL           reduce using rule 113 (binary_expr -> expression MINUS expression .)
    LESS_EQUAL      reduce using rule 113 (binary_expr -> expression MINUS expression .)
    LESS            reduce using rule 113 (binary_expr -> expression MINUS expression .)
    GREATER_EQUAL   reduce using rule 113 (binary_expr -> expression MINUS expression .)
    GREATER         reduce using rule 113 (binary_expr -> expression MINUS expression .)
    SEMICOLON       reduce using rule 113 (binary_expr -> expression MINUS expression .)
    RPAREN          reduce using rule 113 (binary_expr -> expression MINUS expression .)
    LBRACKET        reduce using rule 113 (binary_expr -> expression MINUS expression .)
    LANGRBRACKET    reduce using rule 113 (binary_expr -> expression MINUS expression .)
    LPAREN          reduce using rule 113 (binary_expr -> expression MINUS expression .)
    COMMA           reduce using rule 113 (binary_expr -> expression MINUS expression .)
    RBRACKET        reduce using rule 113 (binary_expr -> expression MINUS expression .)
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    MOD             shift and go to state 92

  ! MUL             [ reduce using rule 113 (binary_expr -> expression MINUS expression .) ]
  ! DIV             [ reduce using rule 113 (binary_expr -> expression MINUS expression .) ]
  ! MOD             [ reduce using rule 113 (binary_expr -> expression MINUS expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! PLUS            [ shift and go to state 85 ]
  ! MINUS           [ shift and go to state 86 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 93 ]
  ! RSHIFT          [ shift and go to state 94 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]
  ! LESS_EQUAL      [ shift and go to state 99 ]
  ! LESS            [ shift and go to state 100 ]
  ! GREATER_EQUAL   [ shift and go to state 101 ]
  ! GREATER         [ shift and go to state 102 ]


state 165

    (114) binary_expr -> expression MUL expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 114 (binary_expr -> expression MUL expression .)
    PLUS            reduce using rule 114 (binary_expr -> expression MUL expression .)
    MINUS           reduce using rule 114 (binary_expr -> expression MUL expression .)
    MUL             reduce using rule 114 (binary_expr -> expression MUL expression .)
    DIV             reduce using rule 114 (binary_expr -> expression MUL expression .)
    AND             reduce using rule 114 (binary_expr -> expression MUL expression .)
    OR              reduce using rule 114 (binary_expr -> expression MUL expression .)
    XOR             reduce using rule 114 (binary_expr -> expression MUL expression .)
    MOD             reduce using rule 114 (binary_expr -> expression MUL expression .)
    LSHIFT          reduce using rule 114 (binary_expr -> expression MUL expression .)
    RSHIFT          reduce using rule 114 (binary_expr -> expression MUL expression .)
    LOGICAL_OR      reduce using rule 114 (binary_expr -> expression MUL expression .)
    LOGICAL_AND     reduce using rule 114 (binary_expr -> expression MUL expression .)
    NOT_EQUAL       reduce using rule 114 (binary_expr -> expression MUL expression .)
    EQUAL           reduce using rule 114 (binary_expr -> expression MUL expression .)
    LESS_EQUAL      reduce using rule 114 (binary_expr -> expression MUL expression .)
    LESS            reduce using rule 114 (binary_expr -> expression MUL expression .)
    GREATER_EQUAL   reduce using rule 114 (binary_expr -> expression MUL expression .)
    GREATER         reduce using rule 114 (binary_expr -> expression MUL expression .)
    SEMICOLON       reduce using rule 114 (binary_expr -> expression MUL expression .)
    RPAREN          reduce using rule 114 (binary_expr -> expression MUL expression .)
    LBRACKET        reduce using rule 114 (binary_expr -> expression MUL expression .)
    LANGRBRACKET    reduce using rule 114 (binary_expr -> expression MUL expression .)
    LPAREN          reduce using rule 114 (binary_expr -> expression MUL expression .)
    COMMA           reduce using rule 114 (binary_expr -> expression MUL expression .)
    RBRACKET        reduce using rule 114 (binary_expr -> expression MUL expression .)

  ! ASSIGN          [ shift and go to state 84 ]
  ! PLUS            [ shift and go to state 85 ]
  ! MINUS           [ shift and go to state 86 ]
  ! MUL             [ shift and go to state 87 ]
  ! DIV             [ shift and go to state 88 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! MOD             [ shift and go to state 92 ]
  ! LSHIFT          [ shift and go to state 93 ]
  ! RSHIFT          [ shift and go to state 94 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]
  ! LESS_EQUAL      [ shift and go to state 99 ]
  ! LESS            [ shift and go to state 100 ]
  ! GREATER_EQUAL   [ shift and go to state 101 ]
  ! GREATER         [ shift and go to state 102 ]


state 166

    (115) binary_expr -> expression DIV expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 115 (binary_expr -> expression DIV expression .)
    PLUS            reduce using rule 115 (binary_expr -> expression DIV expression .)
    MINUS           reduce using rule 115 (binary_expr -> expression DIV expression .)
    MUL             reduce using rule 115 (binary_expr -> expression DIV expression .)
    DIV             reduce using rule 115 (binary_expr -> expression DIV expression .)
    AND             reduce using rule 115 (binary_expr -> expression DIV expression .)
    OR              reduce using rule 115 (binary_expr -> expression DIV expression .)
    XOR             reduce using rule 115 (binary_expr -> expression DIV expression .)
    MOD             reduce using rule 115 (binary_expr -> expression DIV expression .)
    LSHIFT          reduce using rule 115 (binary_expr -> expression DIV expression .)
    RSHIFT          reduce using rule 115 (binary_expr -> expression DIV expression .)
    LOGICAL_OR      reduce using rule 115 (binary_expr -> expression DIV expression .)
    LOGICAL_AND     reduce using rule 115 (binary_expr -> expression DIV expression .)
    NOT_EQUAL       reduce using rule 115 (binary_expr -> expression DIV expression .)
    EQUAL           reduce using rule 115 (binary_expr -> expression DIV expression .)
    LESS_EQUAL      reduce using rule 115 (binary_expr -> expression DIV expression .)
    LESS            reduce using rule 115 (binary_expr -> expression DIV expression .)
    GREATER_EQUAL   reduce using rule 115 (binary_expr -> expression DIV expression .)
    GREATER         reduce using rule 115 (binary_expr -> expression DIV expression .)
    SEMICOLON       reduce using rule 115 (binary_expr -> expression DIV expression .)
    RPAREN          reduce using rule 115 (binary_expr -> expression DIV expression .)
    LBRACKET        reduce using rule 115 (binary_expr -> expression DIV expression .)
    LANGRBRACKET    reduce using rule 115 (binary_expr -> expression DIV expression .)
    LPAREN          reduce using rule 115 (binary_expr -> expression DIV expression .)
    COMMA           reduce using rule 115 (binary_expr -> expression DIV expression .)
    RBRACKET        reduce using rule 115 (binary_expr -> expression DIV expression .)

  ! ASSIGN          [ shift and go to state 84 ]
  ! PLUS            [ shift and go to state 85 ]
  ! MINUS           [ shift and go to state 86 ]
  ! MUL             [ shift and go to state 87 ]
  ! DIV             [ shift and go to state 88 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! MOD             [ shift and go to state 92 ]
  ! LSHIFT          [ shift and go to state 93 ]
  ! RSHIFT          [ shift and go to state 94 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]
  ! LESS_EQUAL      [ shift and go to state 99 ]
  ! LESS            [ shift and go to state 100 ]
  ! GREATER_EQUAL   [ shift and go to state 101 ]
  ! GREATER         [ shift and go to state 102 ]


state 167

    (116) binary_expr -> expression AND expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 116 (binary_expr -> expression AND expression .)
    AND             reduce using rule 116 (binary_expr -> expression AND expression .)
    OR              reduce using rule 116 (binary_expr -> expression AND expression .)
    XOR             reduce using rule 116 (binary_expr -> expression AND expression .)
    LOGICAL_OR      reduce using rule 116 (binary_expr -> expression AND expression .)
    LOGICAL_AND     reduce using rule 116 (binary_expr -> expression AND expression .)
    SEMICOLON       reduce using rule 116 (binary_expr -> expression AND expression .)
    RPAREN          reduce using rule 116 (binary_expr -> expression AND expression .)
    LBRACKET        reduce using rule 116 (binary_expr -> expression AND expression .)
    LANGRBRACKET    reduce using rule 116 (binary_expr -> expression AND expression .)
    LPAREN          reduce using rule 116 (binary_expr -> expression AND expression .)
    COMMA           reduce using rule 116 (binary_expr -> expression AND expression .)
    RBRACKET        reduce using rule 116 (binary_expr -> expression AND expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102

  ! PLUS            [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! MUL             [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! DIV             [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! MOD             [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! LSHIFT          [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! RSHIFT          [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! NOT_EQUAL       [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! EQUAL           [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! LESS_EQUAL      [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! LESS            [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! GREATER         [ reduce using rule 116 (binary_expr -> expression AND expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]


state 168

    (117) binary_expr -> expression OR expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 117 (binary_expr -> expression OR expression .)
    OR              reduce using rule 117 (binary_expr -> expression OR expression .)
    LOGICAL_OR      reduce using rule 117 (binary_expr -> expression OR expression .)
    LOGICAL_AND     reduce using rule 117 (binary_expr -> expression OR expression .)
    SEMICOLON       reduce using rule 117 (binary_expr -> expression OR expression .)
    RPAREN          reduce using rule 117 (binary_expr -> expression OR expression .)
    LBRACKET        reduce using rule 117 (binary_expr -> expression OR expression .)
    LANGRBRACKET    reduce using rule 117 (binary_expr -> expression OR expression .)
    LPAREN          reduce using rule 117 (binary_expr -> expression OR expression .)
    COMMA           reduce using rule 117 (binary_expr -> expression OR expression .)
    RBRACKET        reduce using rule 117 (binary_expr -> expression OR expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102

  ! PLUS            [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! MUL             [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! DIV             [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! AND             [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! XOR             [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! MOD             [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! LSHIFT          [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! RSHIFT          [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! NOT_EQUAL       [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! EQUAL           [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! LESS_EQUAL      [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! LESS            [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! GREATER         [ reduce using rule 117 (binary_expr -> expression OR expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! OR              [ shift and go to state 90 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]


state 169

    (118) binary_expr -> expression XOR expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 118 (binary_expr -> expression XOR expression .)
    OR              reduce using rule 118 (binary_expr -> expression XOR expression .)
    XOR             reduce using rule 118 (binary_expr -> expression XOR expression .)
    LOGICAL_OR      reduce using rule 118 (binary_expr -> expression XOR expression .)
    LOGICAL_AND     reduce using rule 118 (binary_expr -> expression XOR expression .)
    SEMICOLON       reduce using rule 118 (binary_expr -> expression XOR expression .)
    RPAREN          reduce using rule 118 (binary_expr -> expression XOR expression .)
    LBRACKET        reduce using rule 118 (binary_expr -> expression XOR expression .)
    LANGRBRACKET    reduce using rule 118 (binary_expr -> expression XOR expression .)
    LPAREN          reduce using rule 118 (binary_expr -> expression XOR expression .)
    COMMA           reduce using rule 118 (binary_expr -> expression XOR expression .)
    RBRACKET        reduce using rule 118 (binary_expr -> expression XOR expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102

  ! PLUS            [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! MINUS           [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! MUL             [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! DIV             [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! AND             [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! MOD             [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! LSHIFT          [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! RSHIFT          [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! NOT_EQUAL       [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! EQUAL           [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! LESS_EQUAL      [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! LESS            [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! GREATER         [ reduce using rule 118 (binary_expr -> expression XOR expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]


state 170

    (119) binary_expr -> expression MOD expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 119 (binary_expr -> expression MOD expression .)
    PLUS            reduce using rule 119 (binary_expr -> expression MOD expression .)
    MINUS           reduce using rule 119 (binary_expr -> expression MOD expression .)
    MUL             reduce using rule 119 (binary_expr -> expression MOD expression .)
    DIV             reduce using rule 119 (binary_expr -> expression MOD expression .)
    AND             reduce using rule 119 (binary_expr -> expression MOD expression .)
    OR              reduce using rule 119 (binary_expr -> expression MOD expression .)
    XOR             reduce using rule 119 (binary_expr -> expression MOD expression .)
    MOD             reduce using rule 119 (binary_expr -> expression MOD expression .)
    LSHIFT          reduce using rule 119 (binary_expr -> expression MOD expression .)
    RSHIFT          reduce using rule 119 (binary_expr -> expression MOD expression .)
    LOGICAL_OR      reduce using rule 119 (binary_expr -> expression MOD expression .)
    LOGICAL_AND     reduce using rule 119 (binary_expr -> expression MOD expression .)
    NOT_EQUAL       reduce using rule 119 (binary_expr -> expression MOD expression .)
    EQUAL           reduce using rule 119 (binary_expr -> expression MOD expression .)
    LESS_EQUAL      reduce using rule 119 (binary_expr -> expression MOD expression .)
    LESS            reduce using rule 119 (binary_expr -> expression MOD expression .)
    GREATER_EQUAL   reduce using rule 119 (binary_expr -> expression MOD expression .)
    GREATER         reduce using rule 119 (binary_expr -> expression MOD expression .)
    SEMICOLON       reduce using rule 119 (binary_expr -> expression MOD expression .)
    RPAREN          reduce using rule 119 (binary_expr -> expression MOD expression .)
    LBRACKET        reduce using rule 119 (binary_expr -> expression MOD expression .)
    LANGRBRACKET    reduce using rule 119 (binary_expr -> expression MOD expression .)
    LPAREN          reduce using rule 119 (binary_expr -> expression MOD expression .)
    COMMA           reduce using rule 119 (binary_expr -> expression MOD expression .)
    RBRACKET        reduce using rule 119 (binary_expr -> expression MOD expression .)

  ! ASSIGN          [ shift and go to state 84 ]
  ! PLUS            [ shift and go to state 85 ]
  ! MINUS           [ shift and go to state 86 ]
  ! MUL             [ shift and go to state 87 ]
  ! DIV             [ shift and go to state 88 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! MOD             [ shift and go to state 92 ]
  ! LSHIFT          [ shift and go to state 93 ]
  ! RSHIFT          [ shift and go to state 94 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]
  ! LESS_EQUAL      [ shift and go to state 99 ]
  ! LESS            [ shift and go to state 100 ]
  ! GREATER_EQUAL   [ shift and go to state 101 ]
  ! GREATER         [ shift and go to state 102 ]


state 171

    (120) binary_expr -> expression LSHIFT expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    AND             reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    OR              reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    XOR             reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    LSHIFT          reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    RSHIFT          reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    LOGICAL_OR      reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    LOGICAL_AND     reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    NOT_EQUAL       reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    EQUAL           reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    LESS_EQUAL      reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    LESS            reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    GREATER_EQUAL   reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    GREATER         reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    SEMICOLON       reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    RPAREN          reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    LBRACKET        reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    LANGRBRACKET    reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    LPAREN          reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    COMMA           reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    RBRACKET        reduce using rule 120 (binary_expr -> expression LSHIFT expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    MOD             shift and go to state 92

  ! PLUS            [ reduce using rule 120 (binary_expr -> expression LSHIFT expression .) ]
  ! MINUS           [ reduce using rule 120 (binary_expr -> expression LSHIFT expression .) ]
  ! MUL             [ reduce using rule 120 (binary_expr -> expression LSHIFT expression .) ]
  ! DIV             [ reduce using rule 120 (binary_expr -> expression LSHIFT expression .) ]
  ! MOD             [ reduce using rule 120 (binary_expr -> expression LSHIFT expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 93 ]
  ! RSHIFT          [ shift and go to state 94 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]
  ! LESS_EQUAL      [ shift and go to state 99 ]
  ! LESS            [ shift and go to state 100 ]
  ! GREATER_EQUAL   [ shift and go to state 101 ]
  ! GREATER         [ shift and go to state 102 ]


state 172

    (121) binary_expr -> expression RSHIFT expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    AND             reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    OR              reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    XOR             reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    LSHIFT          reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    RSHIFT          reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    LOGICAL_OR      reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    LOGICAL_AND     reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    NOT_EQUAL       reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    EQUAL           reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    LESS_EQUAL      reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    LESS            reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    GREATER_EQUAL   reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    GREATER         reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    SEMICOLON       reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    RPAREN          reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    LBRACKET        reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    LANGRBRACKET    reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    LPAREN          reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    COMMA           reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    RBRACKET        reduce using rule 121 (binary_expr -> expression RSHIFT expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    MOD             shift and go to state 92

  ! PLUS            [ reduce using rule 121 (binary_expr -> expression RSHIFT expression .) ]
  ! MINUS           [ reduce using rule 121 (binary_expr -> expression RSHIFT expression .) ]
  ! MUL             [ reduce using rule 121 (binary_expr -> expression RSHIFT expression .) ]
  ! DIV             [ reduce using rule 121 (binary_expr -> expression RSHIFT expression .) ]
  ! MOD             [ reduce using rule 121 (binary_expr -> expression RSHIFT expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LSHIFT          [ shift and go to state 93 ]
  ! RSHIFT          [ shift and go to state 94 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]
  ! LESS_EQUAL      [ shift and go to state 99 ]
  ! LESS            [ shift and go to state 100 ]
  ! GREATER_EQUAL   [ shift and go to state 101 ]
  ! GREATER         [ shift and go to state 102 ]


state 173

    (122) binary_expr -> expression LOGICAL_OR expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .)
    LOGICAL_OR      reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .)
    SEMICOLON       reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .)
    RPAREN          reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .)
    LBRACKET        reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .)
    LANGRBRACKET    reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .)
    LPAREN          reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .)
    COMMA           reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .)
    RBRACKET        reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102

  ! PLUS            [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! MINUS           [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! MUL             [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! DIV             [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! AND             [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! OR              [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! XOR             [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! MOD             [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! LSHIFT          [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! RSHIFT          [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! LOGICAL_AND     [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! NOT_EQUAL       [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! EQUAL           [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! LESS_EQUAL      [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! LESS            [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! GREATER         [ reduce using rule 122 (binary_expr -> expression LOGICAL_OR expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]


state 174

    (123) binary_expr -> expression LOGICAL_AND expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .)
    LOGICAL_OR      reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .)
    LOGICAL_AND     reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .)
    SEMICOLON       reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .)
    RPAREN          reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .)
    LBRACKET        reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .)
    LANGRBRACKET    reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .)
    LPAREN          reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .)
    COMMA           reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .)
    RBRACKET        reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102

  ! PLUS            [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! MINUS           [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! MUL             [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! DIV             [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! AND             [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! OR              [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! XOR             [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! MOD             [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! LSHIFT          [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! RSHIFT          [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! NOT_EQUAL       [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! EQUAL           [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! LESS_EQUAL      [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! LESS            [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! GREATER         [ reduce using rule 123 (binary_expr -> expression LOGICAL_AND expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]


state 175

    (124) binary_expr -> expression NOT_EQUAL expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    AND             reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    OR              reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    XOR             reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    LOGICAL_OR      reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    LOGICAL_AND     reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    NOT_EQUAL       reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    EQUAL           reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    SEMICOLON       reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    RPAREN          reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    LBRACKET        reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    LANGRBRACKET    reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    LPAREN          reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    COMMA           reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    RBRACKET        reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102

  ! PLUS            [ reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! MUL             [ reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! DIV             [ reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! MOD             [ reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! LSHIFT          [ reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! RSHIFT          [ reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! LESS            [ reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! GREATER         [ reduce using rule 124 (binary_expr -> expression NOT_EQUAL expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]


state 176

    (125) binary_expr -> expression EQUAL expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    AND             reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    OR              reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    XOR             reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    LOGICAL_OR      reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    LOGICAL_AND     reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    NOT_EQUAL       reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    EQUAL           reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    SEMICOLON       reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    RPAREN          reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    LBRACKET        reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    LANGRBRACKET    reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    LPAREN          reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    COMMA           reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    RBRACKET        reduce using rule 125 (binary_expr -> expression EQUAL expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102

  ! PLUS            [ reduce using rule 125 (binary_expr -> expression EQUAL expression .) ]
  ! MINUS           [ reduce using rule 125 (binary_expr -> expression EQUAL expression .) ]
  ! MUL             [ reduce using rule 125 (binary_expr -> expression EQUAL expression .) ]
  ! DIV             [ reduce using rule 125 (binary_expr -> expression EQUAL expression .) ]
  ! MOD             [ reduce using rule 125 (binary_expr -> expression EQUAL expression .) ]
  ! LSHIFT          [ reduce using rule 125 (binary_expr -> expression EQUAL expression .) ]
  ! RSHIFT          [ reduce using rule 125 (binary_expr -> expression EQUAL expression .) ]
  ! LESS_EQUAL      [ reduce using rule 125 (binary_expr -> expression EQUAL expression .) ]
  ! LESS            [ reduce using rule 125 (binary_expr -> expression EQUAL expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 125 (binary_expr -> expression EQUAL expression .) ]
  ! GREATER         [ reduce using rule 125 (binary_expr -> expression EQUAL expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]


state 177

    (126) binary_expr -> expression LESS_EQUAL expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    AND             reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    OR              reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    XOR             reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    LOGICAL_OR      reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    LOGICAL_AND     reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    NOT_EQUAL       reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    EQUAL           reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    LESS_EQUAL      reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    LESS            reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    GREATER_EQUAL   reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    GREATER         reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    SEMICOLON       reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    RPAREN          reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    LBRACKET        reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    LANGRBRACKET    reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    LPAREN          reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    COMMA           reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    RBRACKET        reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94

  ! PLUS            [ reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! MUL             [ reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! DIV             [ reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! MOD             [ reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! LSHIFT          [ reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! RSHIFT          [ reduce using rule 126 (binary_expr -> expression LESS_EQUAL expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]
  ! LESS_EQUAL      [ shift and go to state 99 ]
  ! LESS            [ shift and go to state 100 ]
  ! GREATER_EQUAL   [ shift and go to state 101 ]
  ! GREATER         [ shift and go to state 102 ]


state 178

    (127) binary_expr -> expression LESS expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 127 (binary_expr -> expression LESS expression .)
    AND             reduce using rule 127 (binary_expr -> expression LESS expression .)
    OR              reduce using rule 127 (binary_expr -> expression LESS expression .)
    XOR             reduce using rule 127 (binary_expr -> expression LESS expression .)
    LOGICAL_OR      reduce using rule 127 (binary_expr -> expression LESS expression .)
    LOGICAL_AND     reduce using rule 127 (binary_expr -> expression LESS expression .)
    NOT_EQUAL       reduce using rule 127 (binary_expr -> expression LESS expression .)
    EQUAL           reduce using rule 127 (binary_expr -> expression LESS expression .)
    LESS_EQUAL      reduce using rule 127 (binary_expr -> expression LESS expression .)
    LESS            reduce using rule 127 (binary_expr -> expression LESS expression .)
    GREATER_EQUAL   reduce using rule 127 (binary_expr -> expression LESS expression .)
    GREATER         reduce using rule 127 (binary_expr -> expression LESS expression .)
    SEMICOLON       reduce using rule 127 (binary_expr -> expression LESS expression .)
    RPAREN          reduce using rule 127 (binary_expr -> expression LESS expression .)
    LBRACKET        reduce using rule 127 (binary_expr -> expression LESS expression .)
    LANGRBRACKET    reduce using rule 127 (binary_expr -> expression LESS expression .)
    LPAREN          reduce using rule 127 (binary_expr -> expression LESS expression .)
    COMMA           reduce using rule 127 (binary_expr -> expression LESS expression .)
    RBRACKET        reduce using rule 127 (binary_expr -> expression LESS expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94

  ! PLUS            [ reduce using rule 127 (binary_expr -> expression LESS expression .) ]
  ! MINUS           [ reduce using rule 127 (binary_expr -> expression LESS expression .) ]
  ! MUL             [ reduce using rule 127 (binary_expr -> expression LESS expression .) ]
  ! DIV             [ reduce using rule 127 (binary_expr -> expression LESS expression .) ]
  ! MOD             [ reduce using rule 127 (binary_expr -> expression LESS expression .) ]
  ! LSHIFT          [ reduce using rule 127 (binary_expr -> expression LESS expression .) ]
  ! RSHIFT          [ reduce using rule 127 (binary_expr -> expression LESS expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]
  ! LESS_EQUAL      [ shift and go to state 99 ]
  ! LESS            [ shift and go to state 100 ]
  ! GREATER_EQUAL   [ shift and go to state 101 ]
  ! GREATER         [ shift and go to state 102 ]


state 179

    (128) binary_expr -> expression GREATER_EQUAL expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    AND             reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    OR              reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    XOR             reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    LOGICAL_OR      reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    LOGICAL_AND     reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    NOT_EQUAL       reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    EQUAL           reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    LESS_EQUAL      reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    LESS            reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    GREATER_EQUAL   reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    GREATER         reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    SEMICOLON       reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    RPAREN          reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    LBRACKET        reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    LANGRBRACKET    reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    LPAREN          reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    COMMA           reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    RBRACKET        reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94

  ! PLUS            [ reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! MINUS           [ reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! MUL             [ reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! DIV             [ reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! MOD             [ reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! LSHIFT          [ reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! RSHIFT          [ reduce using rule 128 (binary_expr -> expression GREATER_EQUAL expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]
  ! LESS_EQUAL      [ shift and go to state 99 ]
  ! LESS            [ shift and go to state 100 ]
  ! GREATER_EQUAL   [ shift and go to state 101 ]
  ! GREATER         [ shift and go to state 102 ]


state 180

    (129) binary_expr -> expression GREATER expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    ASSIGN          reduce using rule 129 (binary_expr -> expression GREATER expression .)
    AND             reduce using rule 129 (binary_expr -> expression GREATER expression .)
    OR              reduce using rule 129 (binary_expr -> expression GREATER expression .)
    XOR             reduce using rule 129 (binary_expr -> expression GREATER expression .)
    LOGICAL_OR      reduce using rule 129 (binary_expr -> expression GREATER expression .)
    LOGICAL_AND     reduce using rule 129 (binary_expr -> expression GREATER expression .)
    NOT_EQUAL       reduce using rule 129 (binary_expr -> expression GREATER expression .)
    EQUAL           reduce using rule 129 (binary_expr -> expression GREATER expression .)
    LESS_EQUAL      reduce using rule 129 (binary_expr -> expression GREATER expression .)
    LESS            reduce using rule 129 (binary_expr -> expression GREATER expression .)
    GREATER_EQUAL   reduce using rule 129 (binary_expr -> expression GREATER expression .)
    GREATER         reduce using rule 129 (binary_expr -> expression GREATER expression .)
    SEMICOLON       reduce using rule 129 (binary_expr -> expression GREATER expression .)
    RPAREN          reduce using rule 129 (binary_expr -> expression GREATER expression .)
    LBRACKET        reduce using rule 129 (binary_expr -> expression GREATER expression .)
    LANGRBRACKET    reduce using rule 129 (binary_expr -> expression GREATER expression .)
    LPAREN          reduce using rule 129 (binary_expr -> expression GREATER expression .)
    COMMA           reduce using rule 129 (binary_expr -> expression GREATER expression .)
    RBRACKET        reduce using rule 129 (binary_expr -> expression GREATER expression .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94

  ! PLUS            [ reduce using rule 129 (binary_expr -> expression GREATER expression .) ]
  ! MINUS           [ reduce using rule 129 (binary_expr -> expression GREATER expression .) ]
  ! MUL             [ reduce using rule 129 (binary_expr -> expression GREATER expression .) ]
  ! DIV             [ reduce using rule 129 (binary_expr -> expression GREATER expression .) ]
  ! MOD             [ reduce using rule 129 (binary_expr -> expression GREATER expression .) ]
  ! LSHIFT          [ reduce using rule 129 (binary_expr -> expression GREATER expression .) ]
  ! RSHIFT          [ reduce using rule 129 (binary_expr -> expression GREATER expression .) ]
  ! ASSIGN          [ shift and go to state 84 ]
  ! AND             [ shift and go to state 89 ]
  ! OR              [ shift and go to state 90 ]
  ! XOR             [ shift and go to state 91 ]
  ! LOGICAL_OR      [ shift and go to state 95 ]
  ! LOGICAL_AND     [ shift and go to state 96 ]
  ! NOT_EQUAL       [ shift and go to state 97 ]
  ! EQUAL           [ shift and go to state 98 ]
  ! LESS_EQUAL      [ shift and go to state 99 ]
  ! LESS            [ shift and go to state 100 ]
  ! GREATER_EQUAL   [ shift and go to state 101 ]
  ! GREATER         [ shift and go to state 102 ]


state 181

    (107) jump_statement -> RETURN expression_opt SEMICOLON .

    LBRACE          reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    IF              reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    BREAK           reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    CONTINUE        reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    RETURN          reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    LET             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    CONST           reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    WHILE           reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    FOR             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    NOT             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    LOGICAL_NOT     reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    PLUS            reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    MINUS           reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    SEMICOLON       reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    INT             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    HEXADECIMAL     reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    FLOAT           reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    DOUBLE          reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    STRING          reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    ID              reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    LPAREN          reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    IN              reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    OUT             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    VOID            reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    BOOL            reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    I8              reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    U8              reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    I16             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    U16             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    I32             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    U32             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    I64             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    U64             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    F16             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    F32             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    F64             reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    LANGRBRACKET    reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    RBRACE          reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)
    ELSE            reduce using rule 107 (jump_statement -> RETURN expression_opt SEMICOLON .)


state 182

    (101) while_clause -> WHILE LPAREN expression . RPAREN statement
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    RPAREN          shift and go to state 223
    ASSIGN          shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_OR      shift and go to state 95
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102


state 183

    (102) for_clause -> FOR LPAREN for_init_statement . expression_opt SEMICOLON expression RPAREN statement
    (94) expression_opt -> . expression
    (95) expression_opt -> . empty
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (167) empty -> .
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty

    SEMICOLON       reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    expression_opt                 shift and go to state 224
    expression                     shift and go to state 47
    empty                          shift and go to state 106
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60

state 184

    (103) for_init_statement -> expression_statement .

    NOT             reduce using rule 103 (for_init_statement -> expression_statement .)
    LOGICAL_NOT     reduce using rule 103 (for_init_statement -> expression_statement .)
    PLUS            reduce using rule 103 (for_init_statement -> expression_statement .)
    MINUS           reduce using rule 103 (for_init_statement -> expression_statement .)
    SEMICOLON       reduce using rule 103 (for_init_statement -> expression_statement .)
    INT             reduce using rule 103 (for_init_statement -> expression_statement .)
    HEXADECIMAL     reduce using rule 103 (for_init_statement -> expression_statement .)
    FLOAT           reduce using rule 103 (for_init_statement -> expression_statement .)
    DOUBLE          reduce using rule 103 (for_init_statement -> expression_statement .)
    STRING          reduce using rule 103 (for_init_statement -> expression_statement .)
    ID              reduce using rule 103 (for_init_statement -> expression_statement .)
    LPAREN          reduce using rule 103 (for_init_statement -> expression_statement .)
    IN              reduce using rule 103 (for_init_statement -> expression_statement .)
    OUT             reduce using rule 103 (for_init_statement -> expression_statement .)
    VOID            reduce using rule 103 (for_init_statement -> expression_statement .)
    BOOL            reduce using rule 103 (for_init_statement -> expression_statement .)
    I8              reduce using rule 103 (for_init_statement -> expression_statement .)
    U8              reduce using rule 103 (for_init_statement -> expression_statement .)
    I16             reduce using rule 103 (for_init_statement -> expression_statement .)
    U16             reduce using rule 103 (for_init_statement -> expression_statement .)
    I32             reduce using rule 103 (for_init_statement -> expression_statement .)
    U32             reduce using rule 103 (for_init_statement -> expression_statement .)
    I64             reduce using rule 103 (for_init_statement -> expression_statement .)
    U64             reduce using rule 103 (for_init_statement -> expression_statement .)
    F16             reduce using rule 103 (for_init_statement -> expression_statement .)
    F32             reduce using rule 103 (for_init_statement -> expression_statement .)
    F64             reduce using rule 103 (for_init_statement -> expression_statement .)
    LANGRBRACKET    reduce using rule 103 (for_init_statement -> expression_statement .)


state 185

    (104) for_init_statement -> decl_statement .

    NOT             reduce using rule 104 (for_init_statement -> decl_statement .)
    LOGICAL_NOT     reduce using rule 104 (for_init_statement -> decl_statement .)
    PLUS            reduce using rule 104 (for_init_statement -> decl_statement .)
    MINUS           reduce using rule 104 (for_init_statement -> decl_statement .)
    SEMICOLON       reduce using rule 104 (for_init_statement -> decl_statement .)
    INT             reduce using rule 104 (for_init_statement -> decl_statement .)
    HEXADECIMAL     reduce using rule 104 (for_init_statement -> decl_statement .)
    FLOAT           reduce using rule 104 (for_init_statement -> decl_statement .)
    DOUBLE          reduce using rule 104 (for_init_statement -> decl_statement .)
    STRING          reduce using rule 104 (for_init_statement -> decl_statement .)
    ID              reduce using rule 104 (for_init_statement -> decl_statement .)
    LPAREN          reduce using rule 104 (for_init_statement -> decl_statement .)
    IN              reduce using rule 104 (for_init_statement -> decl_statement .)
    OUT             reduce using rule 104 (for_init_statement -> decl_statement .)
    VOID            reduce using rule 104 (for_init_statement -> decl_statement .)
    BOOL            reduce using rule 104 (for_init_statement -> decl_statement .)
    I8              reduce using rule 104 (for_init_statement -> decl_statement .)
    U8              reduce using rule 104 (for_init_statement -> decl_statement .)
    I16             reduce using rule 104 (for_init_statement -> decl_statement .)
    U16             reduce using rule 104 (for_init_statement -> decl_statement .)
    I32             reduce using rule 104 (for_init_statement -> decl_statement .)
    U32             reduce using rule 104 (for_init_statement -> decl_statement .)
    I64             reduce using rule 104 (for_init_statement -> decl_statement .)
    U64             reduce using rule 104 (for_init_statement -> decl_statement .)
    F16             reduce using rule 104 (for_init_statement -> decl_statement .)
    F32             reduce using rule 104 (for_init_statement -> decl_statement .)
    F64             reduce using rule 104 (for_init_statement -> decl_statement .)
    LANGRBRACKET    reduce using rule 104 (for_init_statement -> decl_statement .)


state 186

    (156) call_expr -> primary_expr generics_specialization_list_opt . LPAREN parameter_list_opt RPAREN

    LPAREN          shift and go to state 225


state 187

    (151) index_expr -> primary_expr LBRACKET . expression RBRACKET
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 226
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 188

    (157) generics_specialization_list_opt -> LANGRBRACKET . type_spec type_spec_comma_nest RANGRBRACKET
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . array_type
    (26) type_spec -> . reference_type
    (27) type_spec -> . function_type
    (28) simple_type -> . VOID
    (29) simple_type -> . BOOL
    (30) simple_type -> . I8
    (31) simple_type -> . U8
    (32) simple_type -> . I16
    (33) simple_type -> . U16
    (34) simple_type -> . I32
    (35) simple_type -> . U32
    (36) simple_type -> . I64
    (37) simple_type -> . U64
    (38) simple_type -> . F16
    (39) simple_type -> . F32
    (40) simple_type -> . F64
    (41) complex_type -> . ID generics_specialization_list_opt
    (42) generic_type -> . ID
    (43) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> . type_spec REF
    (47) function_type -> . function_sign
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    VOID            shift and go to state 134
    BOOL            shift and go to state 135
    I8              shift and go to state 136
    U8              shift and go to state 137
    I16             shift and go to state 138
    U16             shift and go to state 139
    I32             shift and go to state 140
    U32             shift and go to state 141
    I64             shift and go to state 142
    U64             shift and go to state 143
    F16             shift and go to state 144
    F32             shift and go to state 145
    F64             shift and go to state 146
    ID              shift and go to state 151
    LANGRBRACKET    shift and go to state 74
    LPAREN          reduce using rule 167 (empty -> .)

    type_spec                      shift and go to state 227
    simple_type                    shift and go to state 126
    complex_type                   shift and go to state 127
    generic_type                   shift and go to state 128
    array_type                     shift and go to state 129
    reference_type                 shift and go to state 130
    function_type                  shift and go to state 131
    function_sign                  shift and go to state 147
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 189

    (158) generics_specialization_list_opt -> empty .

    LPAREN          reduce using rule 158 (generics_specialization_list_opt -> empty .)
    LBRACKET        reduce using rule 158 (generics_specialization_list_opt -> empty .)
    REF             reduce using rule 158 (generics_specialization_list_opt -> empty .)
    ASSIGN          reduce using rule 158 (generics_specialization_list_opt -> empty .)
    COMMA           reduce using rule 158 (generics_specialization_list_opt -> empty .)
    RPAREN          reduce using rule 158 (generics_specialization_list_opt -> empty .)
    SEMICOLON       reduce using rule 158 (generics_specialization_list_opt -> empty .)
    RANGRBRACKET    reduce using rule 158 (generics_specialization_list_opt -> empty .)
    LBRACE          reduce using rule 158 (generics_specialization_list_opt -> empty .)
    LANGRBRACKET    reduce using rule 158 (generics_specialization_list_opt -> empty .)


state 190

    (150) member_expr -> ID DOT . ID

    ID              shift and go to state 228


state 191

    (41) complex_type -> ID generics_specialization_list_opt .

    LPAREN          reduce using rule 41 (complex_type -> ID generics_specialization_list_opt .)
    LBRACKET        reduce using rule 41 (complex_type -> ID generics_specialization_list_opt .)
    REF             reduce using rule 41 (complex_type -> ID generics_specialization_list_opt .)
    ASSIGN          reduce using rule 41 (complex_type -> ID generics_specialization_list_opt .)
    COMMA           reduce using rule 41 (complex_type -> ID generics_specialization_list_opt .)
    RPAREN          reduce using rule 41 (complex_type -> ID generics_specialization_list_opt .)
    SEMICOLON       reduce using rule 41 (complex_type -> ID generics_specialization_list_opt .)
    LBRACE          reduce using rule 41 (complex_type -> ID generics_specialization_list_opt .)
    RANGRBRACKET    reduce using rule 41 (complex_type -> ID generics_specialization_list_opt .)
    LANGRBRACKET    reduce using rule 41 (complex_type -> ID generics_specialization_list_opt .)


state 192

    (149) operand -> LPAREN expression . RPAREN
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    RPAREN          shift and go to state 229
    ASSIGN          shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_OR      shift and go to state 95
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102


state 193

    (152) cast_expr -> LPAREN type_spec . RPAREN expression
    (43) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> type_spec . REF

    RPAREN          shift and go to state 230
    LBRACKET        shift and go to state 196
    REF             shift and go to state 197


state 194

    (135) unary_operation_opt -> empty .
    (53) generics_type_list_opt -> empty .

  ! reduce/reduce conflict for LPAREN resolved using rule 53 (generics_type_list_opt -> empty .)
    INT             reduce using rule 135 (unary_operation_opt -> empty .)
    HEXADECIMAL     reduce using rule 135 (unary_operation_opt -> empty .)
    FLOAT           reduce using rule 135 (unary_operation_opt -> empty .)
    DOUBLE          reduce using rule 135 (unary_operation_opt -> empty .)
    STRING          reduce using rule 135 (unary_operation_opt -> empty .)
    ID              reduce using rule 135 (unary_operation_opt -> empty .)
    IN              reduce using rule 135 (unary_operation_opt -> empty .)
    OUT             reduce using rule 135 (unary_operation_opt -> empty .)
    VOID            reduce using rule 135 (unary_operation_opt -> empty .)
    BOOL            reduce using rule 135 (unary_operation_opt -> empty .)
    I8              reduce using rule 135 (unary_operation_opt -> empty .)
    U8              reduce using rule 135 (unary_operation_opt -> empty .)
    I16             reduce using rule 135 (unary_operation_opt -> empty .)
    U16             reduce using rule 135 (unary_operation_opt -> empty .)
    I32             reduce using rule 135 (unary_operation_opt -> empty .)
    U32             reduce using rule 135 (unary_operation_opt -> empty .)
    I64             reduce using rule 135 (unary_operation_opt -> empty .)
    U64             reduce using rule 135 (unary_operation_opt -> empty .)
    F16             reduce using rule 135 (unary_operation_opt -> empty .)
    F32             reduce using rule 135 (unary_operation_opt -> empty .)
    F64             reduce using rule 135 (unary_operation_opt -> empty .)
    LANGRBRACKET    reduce using rule 135 (unary_operation_opt -> empty .)
    LPAREN          reduce using rule 53 (generics_type_list_opt -> empty .)

  ! LPAREN          [ reduce using rule 135 (unary_operation_opt -> empty .) ]


state 195

    (153) new_expr -> type_spec LPAREN . parameter_list_opt RPAREN
    (154) parameter_list_opt -> . parameter_list
    (155) parameter_list_opt -> . empty
    (161) parameter_list -> . expression expression_comma_nest
    (167) empty -> .
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty

    RPAREN          reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    parameter_list_opt             shift and go to state 231
    parameter_list                 shift and go to state 232
    empty                          shift and go to state 233
    expression                     shift and go to state 234
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60

state 196

    (43) array_type -> type_spec LBRACKET . int_literal_opt RBRACKET
    (44) int_literal_opt -> . INT
    (45) int_literal_opt -> . empty
    (167) empty -> .

    INT             shift and go to state 236
    RBRACKET        reduce using rule 167 (empty -> .)

    int_literal_opt                shift and go to state 235
    empty                          shift and go to state 237

state 197

    (46) reference_type -> type_spec REF .

    LPAREN          reduce using rule 46 (reference_type -> type_spec REF .)
    LBRACKET        reduce using rule 46 (reference_type -> type_spec REF .)
    REF             reduce using rule 46 (reference_type -> type_spec REF .)
    ASSIGN          reduce using rule 46 (reference_type -> type_spec REF .)
    COMMA           reduce using rule 46 (reference_type -> type_spec REF .)
    RPAREN          reduce using rule 46 (reference_type -> type_spec REF .)
    SEMICOLON       reduce using rule 46 (reference_type -> type_spec REF .)
    RANGRBRACKET    reduce using rule 46 (reference_type -> type_spec REF .)
    LANGRBRACKET    reduce using rule 46 (reference_type -> type_spec REF .)
    LBRACE          reduce using rule 46 (reference_type -> type_spec REF .)


state 198

    (164) io_expr -> in_out LANGRBRACKET . type_spec RANGRBRACKET LPAREN STRING RPAREN
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . array_type
    (26) type_spec -> . reference_type
    (27) type_spec -> . function_type
    (28) simple_type -> . VOID
    (29) simple_type -> . BOOL
    (30) simple_type -> . I8
    (31) simple_type -> . U8
    (32) simple_type -> . I16
    (33) simple_type -> . U16
    (34) simple_type -> . I32
    (35) simple_type -> . U32
    (36) simple_type -> . I64
    (37) simple_type -> . U64
    (38) simple_type -> . F16
    (39) simple_type -> . F32
    (40) simple_type -> . F64
    (41) complex_type -> . ID generics_specialization_list_opt
    (42) generic_type -> . ID
    (43) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> . type_spec REF
    (47) function_type -> . function_sign
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    VOID            shift and go to state 134
    BOOL            shift and go to state 135
    I8              shift and go to state 136
    U8              shift and go to state 137
    I16             shift and go to state 138
    U16             shift and go to state 139
    I32             shift and go to state 140
    U32             shift and go to state 141
    I64             shift and go to state 142
    U64             shift and go to state 143
    F16             shift and go to state 144
    F32             shift and go to state 145
    F64             shift and go to state 146
    ID              shift and go to state 151
    LANGRBRACKET    shift and go to state 74
    LPAREN          reduce using rule 167 (empty -> .)

    type_spec                      shift and go to state 238
    simple_type                    shift and go to state 126
    complex_type                   shift and go to state 127
    generic_type                   shift and go to state 128
    array_type                     shift and go to state 129
    reference_type                 shift and go to state 130
    function_type                  shift and go to state 131
    function_sign                  shift and go to state 147
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 199

    (14) declarator_nest -> COMMA declarator declarator_nest .

    SEMICOLON       reduce using rule 14 (declarator_nest -> COMMA declarator declarator_nest .)


state 200

    (17) declarator -> ID type_spec_colon_opt ASSIGN expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    COMMA           reduce using rule 17 (declarator -> ID type_spec_colon_opt ASSIGN expression .)
    SEMICOLON       reduce using rule 17 (declarator -> ID type_spec_colon_opt ASSIGN expression .)
    ASSIGN          shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_OR      shift and go to state 95
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102


state 201

    (67) function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt . RPAREN type_spec_assigntype_opt

    RPAREN          shift and go to state 239


state 202

    (68) parameter_decl_list_opt -> parameter_decl . parameter_decl_comma_nest
    (72) parameter_decl_comma_nest -> . COMMA parameter_decl parameter_decl_comma_nest
    (73) parameter_decl_comma_nest -> . empty
    (167) empty -> .

    COMMA           shift and go to state 241
    RPAREN          reduce using rule 167 (empty -> .)

    parameter_decl_comma_nest      shift and go to state 240
    empty                          shift and go to state 242

state 203

    (69) parameter_decl_list_opt -> empty .

    RPAREN          reduce using rule 69 (parameter_decl_list_opt -> empty .)


state 204

    (74) parameter_decl -> ID . type_spec_colon_opt
    (18) type_spec_colon_opt -> . COLON type_spec
    (19) type_spec_colon_opt -> . empty
    (167) empty -> .

    COLON           shift and go to state 67
    COMMA           reduce using rule 167 (empty -> .)
    RPAREN          reduce using rule 167 (empty -> .)

    type_spec_colon_opt            shift and go to state 243
    empty                          shift and go to state 68

state 205

    (75) generics_type_list -> LANGRBRACKET generics_type generics_type_comma_nest . RANGRBRACKET

    RANGRBRACKET    shift and go to state 244


state 206

    (76) generics_type_comma_nest -> COMMA . generics_type generics_type_comma_nest
    (78) generics_type -> . ID generics_type_range_colon_opt

    ID              shift and go to state 154

    generics_type                  shift and go to state 245

state 207

    (77) generics_type_comma_nest -> empty .

    RANGRBRACKET    reduce using rule 77 (generics_type_comma_nest -> empty .)


state 208

    (78) generics_type -> ID generics_type_range_colon_opt .

    COMMA           reduce using rule 78 (generics_type -> ID generics_type_range_colon_opt .)
    RANGRBRACKET    reduce using rule 78 (generics_type -> ID generics_type_range_colon_opt .)


state 209

    (79) generics_type_range_colon_opt -> COLON . generics_type_range
    (81) generics_type_range -> . complex_type
    (41) complex_type -> . ID generics_specialization_list_opt

    ID              shift and go to state 213

    generics_type_range            shift and go to state 246
    complex_type                   shift and go to state 247

state 210

    (80) generics_type_range_colon_opt -> empty .

    COMMA           reduce using rule 80 (generics_type_range_colon_opt -> empty .)
    RANGRBRACKET    reduce using rule 80 (generics_type_range_colon_opt -> empty .)


state 211

    (48) struct_decl -> STRUCT ID generics_type_list_opt complex_type_colon_opt LBRACE . member_decl_nest RBRACE
    (54) member_decl_nest -> . member_decl member_decl_nest
    (55) member_decl_nest -> . empty
    (58) member_decl -> . member_declarator SEMICOLON
    (59) member_decl -> . function_def
    (60) member_decl -> . type_function_def
    (167) empty -> .
    (66) member_declarator -> . ID type_spec_colon_opt
    (21) function_def -> . function_decl block_statement
    (61) type_function_def -> . type_function_decl block_statement
    (20) function_decl -> . FUNC ID function_sign
    (65) type_function_decl -> . FUNC type_spec function_sign

    RBRACE          reduce using rule 167 (empty -> .)
    ID              shift and go to state 214
    FUNC            shift and go to state 221

    member_decl_nest               shift and go to state 248
    member_decl                    shift and go to state 249
    empty                          shift and go to state 250
    member_declarator              shift and go to state 251
    function_def                   shift and go to state 252
    type_function_def              shift and go to state 253
    function_decl                  shift and go to state 254
    type_function_decl             shift and go to state 255

state 212

    (49) complex_type_colon_opt -> COLON complex_type .

    LBRACE          reduce using rule 49 (complex_type_colon_opt -> COLON complex_type .)


state 213

    (41) complex_type -> ID . generics_specialization_list_opt
    (157) generics_specialization_list_opt -> . LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET
    (158) generics_specialization_list_opt -> . empty
    (167) empty -> .

    LANGRBRACKET    shift and go to state 188
    LBRACE          reduce using rule 167 (empty -> .)
    COMMA           reduce using rule 167 (empty -> .)
    RANGRBRACKET    reduce using rule 167 (empty -> .)

    generics_specialization_list_opt shift and go to state 191
    empty                          shift and go to state 189

state 214

    (66) member_declarator -> ID . type_spec_colon_opt
    (18) type_spec_colon_opt -> . COLON type_spec
    (19) type_spec_colon_opt -> . empty
    (167) empty -> .

    COLON           shift and go to state 67
    SEMICOLON       reduce using rule 167 (empty -> .)

    type_spec_colon_opt            shift and go to state 256
    empty                          shift and go to state 68

state 215

    (51) interface_decl -> INTERFACE ID generics_type_list_opt LBRACE interface_member_decl_nest . RBRACE

    RBRACE          shift and go to state 257


state 216

    (56) interface_member_decl_nest -> interface_member_decl . SEMICOLON interface_member_decl_nest

    SEMICOLON       shift and go to state 258


state 217

    (57) interface_member_decl_nest -> empty .

    RBRACE          reduce using rule 57 (interface_member_decl_nest -> empty .)


state 218

    (62) interface_member_decl -> member_declarator .

    SEMICOLON       reduce using rule 62 (interface_member_decl -> member_declarator .)


state 219

    (63) interface_member_decl -> function_decl .

    SEMICOLON       reduce using rule 63 (interface_member_decl -> function_decl .)


state 220

    (64) interface_member_decl -> type_function_decl .

    SEMICOLON       reduce using rule 64 (interface_member_decl -> type_function_decl .)


state 221

    (20) function_decl -> FUNC . ID function_sign
    (65) type_function_decl -> FUNC . type_spec function_sign
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . array_type
    (26) type_spec -> . reference_type
    (27) type_spec -> . function_type
    (28) simple_type -> . VOID
    (29) simple_type -> . BOOL
    (30) simple_type -> . I8
    (31) simple_type -> . U8
    (32) simple_type -> . I16
    (33) simple_type -> . U16
    (34) simple_type -> . I32
    (35) simple_type -> . U32
    (36) simple_type -> . I64
    (37) simple_type -> . U64
    (38) simple_type -> . F16
    (39) simple_type -> . F32
    (40) simple_type -> . F64
    (41) complex_type -> . ID generics_specialization_list_opt
    (42) generic_type -> . ID
    (43) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> . type_spec REF
    (47) function_type -> . function_sign
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    ID              shift and go to state 259
    VOID            shift and go to state 134
    BOOL            shift and go to state 135
    I8              shift and go to state 136
    U8              shift and go to state 137
    I16             shift and go to state 138
    U16             shift and go to state 139
    I32             shift and go to state 140
    U32             shift and go to state 141
    I64             shift and go to state 142
    U64             shift and go to state 143
    F16             shift and go to state 144
    F32             shift and go to state 145
    F64             shift and go to state 146
    LANGRBRACKET    shift and go to state 74
    LPAREN          reduce using rule 167 (empty -> .)

    function_sign                  shift and go to state 147
    type_spec                      shift and go to state 260
    simple_type                    shift and go to state 126
    complex_type                   shift and go to state 127
    generic_type                   shift and go to state 128
    array_type                     shift and go to state 129
    reference_type                 shift and go to state 130
    function_type                  shift and go to state 131
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 222

    (96) if_statement -> IF LPAREN expression RPAREN . statement statement_else_opt
    (82) statement -> . decl_statement
    (83) statement -> . block_statement
    (84) statement -> . expression_statement
    (85) statement -> . if_statement
    (86) statement -> . iteration_statement
    (87) statement -> . jump_statement
    (88) decl_statement -> . variable_decl SEMICOLON
    (89) decl_statement -> . constant_decl SEMICOLON
    (90) block_statement -> . LBRACE statement_nest RBRACE
    (93) expression_statement -> . expression_opt SEMICOLON
    (96) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (99) iteration_statement -> . while_clause
    (100) iteration_statement -> . for_clause
    (105) jump_statement -> . BREAK SEMICOLON
    (106) jump_statement -> . CONTINUE SEMICOLON
    (107) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (94) expression_opt -> . expression
    (95) expression_opt -> . empty
    (101) while_clause -> . WHILE LPAREN expression RPAREN statement
    (102) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (167) empty -> .
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty

    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 50
    CONTINUE        shift and go to state 51
    RETURN          shift and go to state 52
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SEMICOLON       reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    expression                     shift and go to state 47
    statement                      shift and go to state 261
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    expression_opt                 shift and go to state 45
    while_clause                   shift and go to state 48
    for_clause                     shift and go to state 49
    empty                          shift and go to state 106
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60

state 223

    (101) while_clause -> WHILE LPAREN expression RPAREN . statement
    (82) statement -> . decl_statement
    (83) statement -> . block_statement
    (84) statement -> . expression_statement
    (85) statement -> . if_statement
    (86) statement -> . iteration_statement
    (87) statement -> . jump_statement
    (88) decl_statement -> . variable_decl SEMICOLON
    (89) decl_statement -> . constant_decl SEMICOLON
    (90) block_statement -> . LBRACE statement_nest RBRACE
    (93) expression_statement -> . expression_opt SEMICOLON
    (96) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (99) iteration_statement -> . while_clause
    (100) iteration_statement -> . for_clause
    (105) jump_statement -> . BREAK SEMICOLON
    (106) jump_statement -> . CONTINUE SEMICOLON
    (107) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (94) expression_opt -> . expression
    (95) expression_opt -> . empty
    (101) while_clause -> . WHILE LPAREN expression RPAREN statement
    (102) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (167) empty -> .
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty

    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 50
    CONTINUE        shift and go to state 51
    RETURN          shift and go to state 52
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SEMICOLON       reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    expression                     shift and go to state 47
    statement                      shift and go to state 262
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    expression_opt                 shift and go to state 45
    while_clause                   shift and go to state 48
    for_clause                     shift and go to state 49
    empty                          shift and go to state 106
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60

state 224

    (102) for_clause -> FOR LPAREN for_init_statement expression_opt . SEMICOLON expression RPAREN statement

    SEMICOLON       shift and go to state 263


state 225

    (156) call_expr -> primary_expr generics_specialization_list_opt LPAREN . parameter_list_opt RPAREN
    (154) parameter_list_opt -> . parameter_list
    (155) parameter_list_opt -> . empty
    (161) parameter_list -> . expression expression_comma_nest
    (167) empty -> .
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty

    RPAREN          reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    parameter_list_opt             shift and go to state 264
    parameter_list                 shift and go to state 232
    empty                          shift and go to state 233
    expression                     shift and go to state 234
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60

state 226

    (151) index_expr -> primary_expr LBRACKET expression . RBRACKET
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    RBRACKET        shift and go to state 265
    ASSIGN          shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_OR      shift and go to state 95
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102


state 227

    (157) generics_specialization_list_opt -> LANGRBRACKET type_spec . type_spec_comma_nest RANGRBRACKET
    (43) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> type_spec . REF
    (159) type_spec_comma_nest -> . COMMA type_spec type_spec_comma_nest
    (160) type_spec_comma_nest -> . empty
    (167) empty -> .

    LBRACKET        shift and go to state 196
    REF             shift and go to state 197
    COMMA           shift and go to state 267
    RANGRBRACKET    reduce using rule 167 (empty -> .)

    type_spec_comma_nest           shift and go to state 266
    empty                          shift and go to state 268

state 228

    (150) member_expr -> ID DOT ID .

    LBRACKET        reduce using rule 150 (member_expr -> ID DOT ID .)
    LANGRBRACKET    reduce using rule 150 (member_expr -> ID DOT ID .)
    LPAREN          reduce using rule 150 (member_expr -> ID DOT ID .)
    ASSIGN          reduce using rule 150 (member_expr -> ID DOT ID .)
    PLUS            reduce using rule 150 (member_expr -> ID DOT ID .)
    MINUS           reduce using rule 150 (member_expr -> ID DOT ID .)
    MUL             reduce using rule 150 (member_expr -> ID DOT ID .)
    DIV             reduce using rule 150 (member_expr -> ID DOT ID .)
    AND             reduce using rule 150 (member_expr -> ID DOT ID .)
    OR              reduce using rule 150 (member_expr -> ID DOT ID .)
    XOR             reduce using rule 150 (member_expr -> ID DOT ID .)
    MOD             reduce using rule 150 (member_expr -> ID DOT ID .)
    LSHIFT          reduce using rule 150 (member_expr -> ID DOT ID .)
    RSHIFT          reduce using rule 150 (member_expr -> ID DOT ID .)
    LOGICAL_OR      reduce using rule 150 (member_expr -> ID DOT ID .)
    LOGICAL_AND     reduce using rule 150 (member_expr -> ID DOT ID .)
    NOT_EQUAL       reduce using rule 150 (member_expr -> ID DOT ID .)
    EQUAL           reduce using rule 150 (member_expr -> ID DOT ID .)
    LESS_EQUAL      reduce using rule 150 (member_expr -> ID DOT ID .)
    LESS            reduce using rule 150 (member_expr -> ID DOT ID .)
    GREATER_EQUAL   reduce using rule 150 (member_expr -> ID DOT ID .)
    GREATER         reduce using rule 150 (member_expr -> ID DOT ID .)
    SEMICOLON       reduce using rule 150 (member_expr -> ID DOT ID .)
    RPAREN          reduce using rule 150 (member_expr -> ID DOT ID .)
    COMMA           reduce using rule 150 (member_expr -> ID DOT ID .)
    RBRACKET        reduce using rule 150 (member_expr -> ID DOT ID .)


state 229

    (149) operand -> LPAREN expression RPAREN .

    LBRACKET        reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    LANGRBRACKET    reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    ASSIGN          reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    MUL             reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    DIV             reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    AND             reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    OR              reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    XOR             reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    MOD             reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    LSHIFT          reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    RSHIFT          reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    LOGICAL_OR      reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    LOGICAL_AND     reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    LESS_EQUAL      reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    LESS            reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    GREATER_EQUAL   reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 149 (operand -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 149 (operand -> LPAREN expression RPAREN .)


state 230

    (152) cast_expr -> LPAREN type_spec RPAREN . expression
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 269
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 231

    (153) new_expr -> type_spec LPAREN parameter_list_opt . RPAREN

    RPAREN          shift and go to state 270


state 232

    (154) parameter_list_opt -> parameter_list .

    RPAREN          reduce using rule 154 (parameter_list_opt -> parameter_list .)


state 233

    (155) parameter_list_opt -> empty .
    (135) unary_operation_opt -> empty .

    RPAREN          reduce using rule 155 (parameter_list_opt -> empty .)
    INT             reduce using rule 135 (unary_operation_opt -> empty .)
    HEXADECIMAL     reduce using rule 135 (unary_operation_opt -> empty .)
    FLOAT           reduce using rule 135 (unary_operation_opt -> empty .)
    DOUBLE          reduce using rule 135 (unary_operation_opt -> empty .)
    STRING          reduce using rule 135 (unary_operation_opt -> empty .)
    ID              reduce using rule 135 (unary_operation_opt -> empty .)
    LPAREN          reduce using rule 135 (unary_operation_opt -> empty .)
    IN              reduce using rule 135 (unary_operation_opt -> empty .)
    OUT             reduce using rule 135 (unary_operation_opt -> empty .)
    VOID            reduce using rule 135 (unary_operation_opt -> empty .)
    BOOL            reduce using rule 135 (unary_operation_opt -> empty .)
    I8              reduce using rule 135 (unary_operation_opt -> empty .)
    U8              reduce using rule 135 (unary_operation_opt -> empty .)
    I16             reduce using rule 135 (unary_operation_opt -> empty .)
    U16             reduce using rule 135 (unary_operation_opt -> empty .)
    I32             reduce using rule 135 (unary_operation_opt -> empty .)
    U32             reduce using rule 135 (unary_operation_opt -> empty .)
    I64             reduce using rule 135 (unary_operation_opt -> empty .)
    U64             reduce using rule 135 (unary_operation_opt -> empty .)
    F16             reduce using rule 135 (unary_operation_opt -> empty .)
    F32             reduce using rule 135 (unary_operation_opt -> empty .)
    F64             reduce using rule 135 (unary_operation_opt -> empty .)
    LANGRBRACKET    reduce using rule 135 (unary_operation_opt -> empty .)


state 234

    (161) parameter_list -> expression . expression_comma_nest
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression
    (162) expression_comma_nest -> . COMMA expression expression_comma_nest
    (163) expression_comma_nest -> . empty
    (167) empty -> .

    ASSIGN          shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_OR      shift and go to state 95
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102
    COMMA           shift and go to state 272
    RPAREN          reduce using rule 167 (empty -> .)

    expression_comma_nest          shift and go to state 271
    empty                          shift and go to state 273

state 235

    (43) array_type -> type_spec LBRACKET int_literal_opt . RBRACKET

    RBRACKET        shift and go to state 274


state 236

    (44) int_literal_opt -> INT .

    RBRACKET        reduce using rule 44 (int_literal_opt -> INT .)


state 237

    (45) int_literal_opt -> empty .

    RBRACKET        reduce using rule 45 (int_literal_opt -> empty .)


state 238

    (164) io_expr -> in_out LANGRBRACKET type_spec . RANGRBRACKET LPAREN STRING RPAREN
    (43) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> type_spec . REF

    RANGRBRACKET    shift and go to state 275
    LBRACKET        shift and go to state 196
    REF             shift and go to state 197


state 239

    (67) function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN . type_spec_assigntype_opt
    (70) type_spec_assigntype_opt -> . ASSIGNTYPE type_spec
    (71) type_spec_assigntype_opt -> . empty
    (167) empty -> .

    ASSIGNTYPE      shift and go to state 277
    LBRACKET        reduce using rule 167 (empty -> .)
    REF             reduce using rule 167 (empty -> .)
    SEMICOLON       reduce using rule 167 (empty -> .)
    LBRACE          reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    ASSIGN          reduce using rule 167 (empty -> .)
    COMMA           reduce using rule 167 (empty -> .)
    RPAREN          reduce using rule 167 (empty -> .)
    RANGRBRACKET    reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    type_spec_assigntype_opt       shift and go to state 276
    empty                          shift and go to state 278

state 240

    (68) parameter_decl_list_opt -> parameter_decl parameter_decl_comma_nest .

    RPAREN          reduce using rule 68 (parameter_decl_list_opt -> parameter_decl parameter_decl_comma_nest .)


state 241

    (72) parameter_decl_comma_nest -> COMMA . parameter_decl parameter_decl_comma_nest
    (74) parameter_decl -> . ID type_spec_colon_opt

    ID              shift and go to state 204

    parameter_decl                 shift and go to state 279

state 242

    (73) parameter_decl_comma_nest -> empty .

    RPAREN          reduce using rule 73 (parameter_decl_comma_nest -> empty .)


state 243

    (74) parameter_decl -> ID type_spec_colon_opt .

    COMMA           reduce using rule 74 (parameter_decl -> ID type_spec_colon_opt .)
    RPAREN          reduce using rule 74 (parameter_decl -> ID type_spec_colon_opt .)


state 244

    (75) generics_type_list -> LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET .

    LPAREN          reduce using rule 75 (generics_type_list -> LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET .)
    COLON           reduce using rule 75 (generics_type_list -> LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET .)
    LBRACE          reduce using rule 75 (generics_type_list -> LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET .)


state 245

    (76) generics_type_comma_nest -> COMMA generics_type . generics_type_comma_nest
    (76) generics_type_comma_nest -> . COMMA generics_type generics_type_comma_nest
    (77) generics_type_comma_nest -> . empty
    (167) empty -> .

    COMMA           shift and go to state 206
    RANGRBRACKET    reduce using rule 167 (empty -> .)

    generics_type_comma_nest       shift and go to state 280
    empty                          shift and go to state 207

state 246

    (79) generics_type_range_colon_opt -> COLON generics_type_range .

    COMMA           reduce using rule 79 (generics_type_range_colon_opt -> COLON generics_type_range .)
    RANGRBRACKET    reduce using rule 79 (generics_type_range_colon_opt -> COLON generics_type_range .)


state 247

    (81) generics_type_range -> complex_type .

    COMMA           reduce using rule 81 (generics_type_range -> complex_type .)
    RANGRBRACKET    reduce using rule 81 (generics_type_range -> complex_type .)


state 248

    (48) struct_decl -> STRUCT ID generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest . RBRACE

    RBRACE          shift and go to state 281


state 249

    (54) member_decl_nest -> member_decl . member_decl_nest
    (54) member_decl_nest -> . member_decl member_decl_nest
    (55) member_decl_nest -> . empty
    (58) member_decl -> . member_declarator SEMICOLON
    (59) member_decl -> . function_def
    (60) member_decl -> . type_function_def
    (167) empty -> .
    (66) member_declarator -> . ID type_spec_colon_opt
    (21) function_def -> . function_decl block_statement
    (61) type_function_def -> . type_function_decl block_statement
    (20) function_decl -> . FUNC ID function_sign
    (65) type_function_decl -> . FUNC type_spec function_sign

    RBRACE          reduce using rule 167 (empty -> .)
    ID              shift and go to state 214
    FUNC            shift and go to state 221

    member_decl                    shift and go to state 249
    member_decl_nest               shift and go to state 282
    empty                          shift and go to state 250
    member_declarator              shift and go to state 251
    function_def                   shift and go to state 252
    type_function_def              shift and go to state 253
    function_decl                  shift and go to state 254
    type_function_decl             shift and go to state 255

state 250

    (55) member_decl_nest -> empty .

    RBRACE          reduce using rule 55 (member_decl_nest -> empty .)


state 251

    (58) member_decl -> member_declarator . SEMICOLON

    SEMICOLON       shift and go to state 283


state 252

    (59) member_decl -> function_def .

    ID              reduce using rule 59 (member_decl -> function_def .)
    FUNC            reduce using rule 59 (member_decl -> function_def .)
    RBRACE          reduce using rule 59 (member_decl -> function_def .)


state 253

    (60) member_decl -> type_function_def .

    ID              reduce using rule 60 (member_decl -> type_function_def .)
    FUNC            reduce using rule 60 (member_decl -> type_function_def .)
    RBRACE          reduce using rule 60 (member_decl -> type_function_def .)


state 254

    (21) function_def -> function_decl . block_statement
    (90) block_statement -> . LBRACE statement_nest RBRACE

    LBRACE          shift and go to state 26

    block_statement                shift and go to state 25

state 255

    (61) type_function_def -> type_function_decl . block_statement
    (90) block_statement -> . LBRACE statement_nest RBRACE

    LBRACE          shift and go to state 26

    block_statement                shift and go to state 284

state 256

    (66) member_declarator -> ID type_spec_colon_opt .

    SEMICOLON       reduce using rule 66 (member_declarator -> ID type_spec_colon_opt .)


state 257

    (51) interface_decl -> INTERFACE ID generics_type_list_opt LBRACE interface_member_decl_nest RBRACE .

    SEMICOLON       reduce using rule 51 (interface_decl -> INTERFACE ID generics_type_list_opt LBRACE interface_member_decl_nest RBRACE .)


state 258

    (56) interface_member_decl_nest -> interface_member_decl SEMICOLON . interface_member_decl_nest
    (56) interface_member_decl_nest -> . interface_member_decl SEMICOLON interface_member_decl_nest
    (57) interface_member_decl_nest -> . empty
    (62) interface_member_decl -> . member_declarator
    (63) interface_member_decl -> . function_decl
    (64) interface_member_decl -> . type_function_decl
    (167) empty -> .
    (66) member_declarator -> . ID type_spec_colon_opt
    (20) function_decl -> . FUNC ID function_sign
    (65) type_function_decl -> . FUNC type_spec function_sign

    RBRACE          reduce using rule 167 (empty -> .)
    ID              shift and go to state 214
    FUNC            shift and go to state 221

    interface_member_decl          shift and go to state 216
    interface_member_decl_nest     shift and go to state 285
    empty                          shift and go to state 217
    member_declarator              shift and go to state 218
    function_decl                  shift and go to state 219
    type_function_decl             shift and go to state 220

state 259

    (20) function_decl -> FUNC ID . function_sign
    (41) complex_type -> ID . generics_specialization_list_opt
    (42) generic_type -> ID .
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (157) generics_specialization_list_opt -> . LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET
    (158) generics_specialization_list_opt -> . empty
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (167) empty -> .
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET

  ! shift/reduce conflict for LANGRBRACKET resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for REF resolved using rule 42 (generic_type -> ID .)
  ! shift/reduce conflict for LANGRBRACKET resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 42 (generic_type -> ID .)
    LBRACKET        reduce using rule 42 (generic_type -> ID .)
    REF             reduce using rule 42 (generic_type -> ID .)
    LPAREN          reduce using rule 42 (generic_type -> ID .)
    LANGRBRACKET    shift and go to state 286

  ! LANGRBRACKET    [ reduce using rule 42 (generic_type -> ID .) ]
  ! LBRACKET        [ reduce using rule 167 (empty -> .) ]
  ! REF             [ reduce using rule 167 (empty -> .) ]
  ! LANGRBRACKET    [ reduce using rule 167 (empty -> .) ]
  ! LPAREN          [ reduce using rule 167 (empty -> .) ]

    function_sign                  shift and go to state 70
    generics_specialization_list_opt shift and go to state 191
    generics_type_list_opt         shift and go to state 71
    empty                          shift and go to state 287
    generics_type_list             shift and go to state 72

state 260

    (65) type_function_decl -> FUNC type_spec . function_sign
    (43) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> type_spec . REF
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    LBRACKET        shift and go to state 196
    REF             shift and go to state 197
    LANGRBRACKET    shift and go to state 74
    LPAREN          reduce using rule 167 (empty -> .)

    function_sign                  shift and go to state 288
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 261

    (96) if_statement -> IF LPAREN expression RPAREN statement . statement_else_opt
    (97) statement_else_opt -> . ELSE statement
    (98) statement_else_opt -> . empty
    (167) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 290
    LBRACE          reduce using rule 167 (empty -> .)
    IF              reduce using rule 167 (empty -> .)
    BREAK           reduce using rule 167 (empty -> .)
    CONTINUE        reduce using rule 167 (empty -> .)
    RETURN          reduce using rule 167 (empty -> .)
    LET             reduce using rule 167 (empty -> .)
    CONST           reduce using rule 167 (empty -> .)
    WHILE           reduce using rule 167 (empty -> .)
    FOR             reduce using rule 167 (empty -> .)
    NOT             reduce using rule 167 (empty -> .)
    LOGICAL_NOT     reduce using rule 167 (empty -> .)
    PLUS            reduce using rule 167 (empty -> .)
    MINUS           reduce using rule 167 (empty -> .)
    SEMICOLON       reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    RBRACE          reduce using rule 167 (empty -> .)

  ! ELSE            [ reduce using rule 167 (empty -> .) ]

    statement_else_opt             shift and go to state 289
    empty                          shift and go to state 291

state 262

    (101) while_clause -> WHILE LPAREN expression RPAREN statement .

    LBRACE          reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    IF              reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    CONTINUE        reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    RETURN          reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    LET             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    CONST           reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    FOR             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    NOT             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    LOGICAL_NOT     reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    PLUS            reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    SEMICOLON       reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    INT             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    HEXADECIMAL     reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    FLOAT           reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    DOUBLE          reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    STRING          reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    ID              reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    IN              reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    OUT             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    VOID            reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    BOOL            reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    I8              reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    U8              reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    I16             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    U16             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    I32             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    U32             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    I64             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    U64             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    F16             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    F32             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    F64             reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    LANGRBRACKET    reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    RBRACE          reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)
    ELSE            reduce using rule 101 (while_clause -> WHILE LPAREN expression RPAREN statement .)


state 263

    (102) for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON . expression RPAREN statement
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 292
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 264

    (156) call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt . RPAREN

    RPAREN          shift and go to state 293


state 265

    (151) index_expr -> primary_expr LBRACKET expression RBRACKET .

    LBRACKET        reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LANGRBRACKET    reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LPAREN          reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    ASSIGN          reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    MUL             reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    DIV             reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    AND             reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    OR              reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    XOR             reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    MOD             reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LSHIFT          reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    RSHIFT          reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LOGICAL_OR      reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LOGICAL_AND     reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    NOT_EQUAL       reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    EQUAL           reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LESS_EQUAL      reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    LESS            reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    GREATER_EQUAL   reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    GREATER         reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 151 (index_expr -> primary_expr LBRACKET expression RBRACKET .)


state 266

    (157) generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest . RANGRBRACKET

    RANGRBRACKET    shift and go to state 294


state 267

    (159) type_spec_comma_nest -> COMMA . type_spec type_spec_comma_nest
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . array_type
    (26) type_spec -> . reference_type
    (27) type_spec -> . function_type
    (28) simple_type -> . VOID
    (29) simple_type -> . BOOL
    (30) simple_type -> . I8
    (31) simple_type -> . U8
    (32) simple_type -> . I16
    (33) simple_type -> . U16
    (34) simple_type -> . I32
    (35) simple_type -> . U32
    (36) simple_type -> . I64
    (37) simple_type -> . U64
    (38) simple_type -> . F16
    (39) simple_type -> . F32
    (40) simple_type -> . F64
    (41) complex_type -> . ID generics_specialization_list_opt
    (42) generic_type -> . ID
    (43) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> . type_spec REF
    (47) function_type -> . function_sign
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    VOID            shift and go to state 134
    BOOL            shift and go to state 135
    I8              shift and go to state 136
    U8              shift and go to state 137
    I16             shift and go to state 138
    U16             shift and go to state 139
    I32             shift and go to state 140
    U32             shift and go to state 141
    I64             shift and go to state 142
    U64             shift and go to state 143
    F16             shift and go to state 144
    F32             shift and go to state 145
    F64             shift and go to state 146
    ID              shift and go to state 151
    LANGRBRACKET    shift and go to state 74
    LPAREN          reduce using rule 167 (empty -> .)

    type_spec                      shift and go to state 295
    simple_type                    shift and go to state 126
    complex_type                   shift and go to state 127
    generic_type                   shift and go to state 128
    array_type                     shift and go to state 129
    reference_type                 shift and go to state 130
    function_type                  shift and go to state 131
    function_sign                  shift and go to state 147
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 268

    (160) type_spec_comma_nest -> empty .

    RANGRBRACKET    reduce using rule 160 (type_spec_comma_nest -> empty .)


state 269

    (152) cast_expr -> LPAREN type_spec RPAREN expression .
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for XOR resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for LSHIFT resolved as shift
  ! shift/reduce conflict for RSHIFT resolved as shift
  ! shift/reduce conflict for LOGICAL_OR resolved as shift
  ! shift/reduce conflict for LOGICAL_AND resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for LESS_EQUAL resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATER_EQUAL resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
    LBRACKET        reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .)
    LANGRBRACKET    reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .)
    LPAREN          reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .)
    SEMICOLON       reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .)
    RPAREN          reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .)
    COMMA           reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .)
    RBRACKET        reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .)
    ASSIGN          shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_OR      shift and go to state 95
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102

  ! ASSIGN          [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! PLUS            [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! MINUS           [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! MUL             [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! DIV             [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! AND             [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! OR              [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! XOR             [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! MOD             [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! LSHIFT          [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! RSHIFT          [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! LOGICAL_OR      [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! LOGICAL_AND     [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! NOT_EQUAL       [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! EQUAL           [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! LESS_EQUAL      [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! LESS            [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! GREATER_EQUAL   [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]
  ! GREATER         [ reduce using rule 152 (cast_expr -> LPAREN type_spec RPAREN expression .) ]


state 270

    (153) new_expr -> type_spec LPAREN parameter_list_opt RPAREN .

    LBRACKET        reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LANGRBRACKET    reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LPAREN          reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    ASSIGN          reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    PLUS            reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    MINUS           reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    MUL             reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    DIV             reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    AND             reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    OR              reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    XOR             reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    MOD             reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LSHIFT          reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    RSHIFT          reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LOGICAL_OR      reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LOGICAL_AND     reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    NOT_EQUAL       reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    EQUAL           reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LESS_EQUAL      reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    LESS            reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    GREATER_EQUAL   reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    GREATER         reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    SEMICOLON       reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    RPAREN          reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    COMMA           reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)
    RBRACKET        reduce using rule 153 (new_expr -> type_spec LPAREN parameter_list_opt RPAREN .)


state 271

    (161) parameter_list -> expression expression_comma_nest .

    RPAREN          reduce using rule 161 (parameter_list -> expression expression_comma_nest .)


state 272

    (162) expression_comma_nest -> COMMA . expression expression_comma_nest
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty
    (167) empty -> .

    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)

    expression                     shift and go to state 296
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60
    empty                          shift and go to state 161

state 273

    (163) expression_comma_nest -> empty .

    RPAREN          reduce using rule 163 (expression_comma_nest -> empty .)


state 274

    (43) array_type -> type_spec LBRACKET int_literal_opt RBRACKET .

    LPAREN          reduce using rule 43 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    LBRACKET        reduce using rule 43 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    REF             reduce using rule 43 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    ASSIGN          reduce using rule 43 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    COMMA           reduce using rule 43 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    RPAREN          reduce using rule 43 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    SEMICOLON       reduce using rule 43 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    RANGRBRACKET    reduce using rule 43 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    LANGRBRACKET    reduce using rule 43 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)
    LBRACE          reduce using rule 43 (array_type -> type_spec LBRACKET int_literal_opt RBRACKET .)


state 275

    (164) io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET . LPAREN STRING RPAREN

    LPAREN          shift and go to state 297


state 276

    (67) function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .

    SEMICOLON       reduce using rule 67 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    LBRACE          reduce using rule 67 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    LPAREN          reduce using rule 67 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    LBRACKET        reduce using rule 67 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    REF             reduce using rule 67 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    ASSIGN          reduce using rule 67 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    COMMA           reduce using rule 67 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    RPAREN          reduce using rule 67 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    RANGRBRACKET    reduce using rule 67 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)
    LANGRBRACKET    reduce using rule 67 (function_sign -> generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt .)


state 277

    (70) type_spec_assigntype_opt -> ASSIGNTYPE . type_spec
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . array_type
    (26) type_spec -> . reference_type
    (27) type_spec -> . function_type
    (28) simple_type -> . VOID
    (29) simple_type -> . BOOL
    (30) simple_type -> . I8
    (31) simple_type -> . U8
    (32) simple_type -> . I16
    (33) simple_type -> . U16
    (34) simple_type -> . I32
    (35) simple_type -> . U32
    (36) simple_type -> . I64
    (37) simple_type -> . U64
    (38) simple_type -> . F16
    (39) simple_type -> . F32
    (40) simple_type -> . F64
    (41) complex_type -> . ID generics_specialization_list_opt
    (42) generic_type -> . ID
    (43) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> . type_spec REF
    (47) function_type -> . function_sign
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    VOID            shift and go to state 134
    BOOL            shift and go to state 135
    I8              shift and go to state 136
    U8              shift and go to state 137
    I16             shift and go to state 138
    U16             shift and go to state 139
    I32             shift and go to state 140
    U32             shift and go to state 141
    I64             shift and go to state 142
    U64             shift and go to state 143
    F16             shift and go to state 144
    F32             shift and go to state 145
    F64             shift and go to state 146
    ID              shift and go to state 151
    LANGRBRACKET    shift and go to state 74
    LPAREN          reduce using rule 167 (empty -> .)

    type_spec                      shift and go to state 298
    simple_type                    shift and go to state 126
    complex_type                   shift and go to state 127
    generic_type                   shift and go to state 128
    array_type                     shift and go to state 129
    reference_type                 shift and go to state 130
    function_type                  shift and go to state 131
    function_sign                  shift and go to state 147
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 278

    (71) type_spec_assigntype_opt -> empty .

    LBRACKET        reduce using rule 71 (type_spec_assigntype_opt -> empty .)
    REF             reduce using rule 71 (type_spec_assigntype_opt -> empty .)
    SEMICOLON       reduce using rule 71 (type_spec_assigntype_opt -> empty .)
    LBRACE          reduce using rule 71 (type_spec_assigntype_opt -> empty .)
    LPAREN          reduce using rule 71 (type_spec_assigntype_opt -> empty .)
    ASSIGN          reduce using rule 71 (type_spec_assigntype_opt -> empty .)
    COMMA           reduce using rule 71 (type_spec_assigntype_opt -> empty .)
    RPAREN          reduce using rule 71 (type_spec_assigntype_opt -> empty .)
    RANGRBRACKET    reduce using rule 71 (type_spec_assigntype_opt -> empty .)
    LANGRBRACKET    reduce using rule 71 (type_spec_assigntype_opt -> empty .)


state 279

    (72) parameter_decl_comma_nest -> COMMA parameter_decl . parameter_decl_comma_nest
    (72) parameter_decl_comma_nest -> . COMMA parameter_decl parameter_decl_comma_nest
    (73) parameter_decl_comma_nest -> . empty
    (167) empty -> .

    COMMA           shift and go to state 241
    RPAREN          reduce using rule 167 (empty -> .)

    parameter_decl_comma_nest      shift and go to state 299
    empty                          shift and go to state 242

state 280

    (76) generics_type_comma_nest -> COMMA generics_type generics_type_comma_nest .

    RANGRBRACKET    reduce using rule 76 (generics_type_comma_nest -> COMMA generics_type generics_type_comma_nest .)


state 281

    (48) struct_decl -> STRUCT ID generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE .

    SEMICOLON       reduce using rule 48 (struct_decl -> STRUCT ID generics_type_list_opt complex_type_colon_opt LBRACE member_decl_nest RBRACE .)


state 282

    (54) member_decl_nest -> member_decl member_decl_nest .

    RBRACE          reduce using rule 54 (member_decl_nest -> member_decl member_decl_nest .)


state 283

    (58) member_decl -> member_declarator SEMICOLON .

    ID              reduce using rule 58 (member_decl -> member_declarator SEMICOLON .)
    FUNC            reduce using rule 58 (member_decl -> member_declarator SEMICOLON .)
    RBRACE          reduce using rule 58 (member_decl -> member_declarator SEMICOLON .)


state 284

    (61) type_function_def -> type_function_decl block_statement .

    ID              reduce using rule 61 (type_function_def -> type_function_decl block_statement .)
    FUNC            reduce using rule 61 (type_function_def -> type_function_decl block_statement .)
    RBRACE          reduce using rule 61 (type_function_def -> type_function_decl block_statement .)


state 285

    (56) interface_member_decl_nest -> interface_member_decl SEMICOLON interface_member_decl_nest .

    RBRACE          reduce using rule 56 (interface_member_decl_nest -> interface_member_decl SEMICOLON interface_member_decl_nest .)


state 286

    (157) generics_specialization_list_opt -> LANGRBRACKET . type_spec type_spec_comma_nest RANGRBRACKET
    (75) generics_type_list -> LANGRBRACKET . generics_type generics_type_comma_nest RANGRBRACKET
    (22) type_spec -> . simple_type
    (23) type_spec -> . complex_type
    (24) type_spec -> . generic_type
    (25) type_spec -> . array_type
    (26) type_spec -> . reference_type
    (27) type_spec -> . function_type
    (78) generics_type -> . ID generics_type_range_colon_opt
    (28) simple_type -> . VOID
    (29) simple_type -> . BOOL
    (30) simple_type -> . I8
    (31) simple_type -> . U8
    (32) simple_type -> . I16
    (33) simple_type -> . U16
    (34) simple_type -> . I32
    (35) simple_type -> . U32
    (36) simple_type -> . I64
    (37) simple_type -> . U64
    (38) simple_type -> . F16
    (39) simple_type -> . F32
    (40) simple_type -> . F64
    (41) complex_type -> . ID generics_specialization_list_opt
    (42) generic_type -> . ID
    (43) array_type -> . type_spec LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> . type_spec REF
    (47) function_type -> . function_sign
    (67) function_sign -> . generics_type_list_opt LPAREN parameter_decl_list_opt RPAREN type_spec_assigntype_opt
    (52) generics_type_list_opt -> . generics_type_list
    (53) generics_type_list_opt -> . empty
    (75) generics_type_list -> . LANGRBRACKET generics_type generics_type_comma_nest RANGRBRACKET
    (167) empty -> .

    ID              shift and go to state 300
    VOID            shift and go to state 134
    BOOL            shift and go to state 135
    I8              shift and go to state 136
    U8              shift and go to state 137
    I16             shift and go to state 138
    U16             shift and go to state 139
    I32             shift and go to state 140
    U32             shift and go to state 141
    I64             shift and go to state 142
    U64             shift and go to state 143
    F16             shift and go to state 144
    F32             shift and go to state 145
    F64             shift and go to state 146
    LANGRBRACKET    shift and go to state 74
    LPAREN          reduce using rule 167 (empty -> .)

    type_spec                      shift and go to state 227
    generics_type                  shift and go to state 153
    simple_type                    shift and go to state 126
    complex_type                   shift and go to state 127
    generic_type                   shift and go to state 128
    array_type                     shift and go to state 129
    reference_type                 shift and go to state 130
    function_type                  shift and go to state 131
    function_sign                  shift and go to state 147
    generics_type_list_opt         shift and go to state 71
    generics_type_list             shift and go to state 72
    empty                          shift and go to state 73

state 287

    (158) generics_specialization_list_opt -> empty .
    (53) generics_type_list_opt -> empty .

  ! reduce/reduce conflict for LPAREN resolved using rule 53 (generics_type_list_opt -> empty .)
    LBRACKET        reduce using rule 158 (generics_specialization_list_opt -> empty .)
    REF             reduce using rule 158 (generics_specialization_list_opt -> empty .)
    LANGRBRACKET    reduce using rule 158 (generics_specialization_list_opt -> empty .)
    LPAREN          reduce using rule 53 (generics_type_list_opt -> empty .)

  ! LPAREN          [ reduce using rule 158 (generics_specialization_list_opt -> empty .) ]


state 288

    (65) type_function_decl -> FUNC type_spec function_sign .

    SEMICOLON       reduce using rule 65 (type_function_decl -> FUNC type_spec function_sign .)
    LBRACE          reduce using rule 65 (type_function_decl -> FUNC type_spec function_sign .)


state 289

    (96) if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .

    LBRACE          reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    IF              reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    BREAK           reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    CONTINUE        reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    RETURN          reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    LET             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    CONST           reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    WHILE           reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    FOR             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    NOT             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    LOGICAL_NOT     reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    PLUS            reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    MINUS           reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    SEMICOLON       reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    INT             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    HEXADECIMAL     reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    FLOAT           reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    DOUBLE          reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    STRING          reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    ID              reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    LPAREN          reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    IN              reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    OUT             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    VOID            reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    BOOL            reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    I8              reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    U8              reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    I16             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    U16             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    I32             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    U32             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    I64             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    U64             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    F16             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    F32             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    F64             reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    LANGRBRACKET    reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    RBRACE          reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)
    ELSE            reduce using rule 96 (if_statement -> IF LPAREN expression RPAREN statement statement_else_opt .)


state 290

    (97) statement_else_opt -> ELSE . statement
    (82) statement -> . decl_statement
    (83) statement -> . block_statement
    (84) statement -> . expression_statement
    (85) statement -> . if_statement
    (86) statement -> . iteration_statement
    (87) statement -> . jump_statement
    (88) decl_statement -> . variable_decl SEMICOLON
    (89) decl_statement -> . constant_decl SEMICOLON
    (90) block_statement -> . LBRACE statement_nest RBRACE
    (93) expression_statement -> . expression_opt SEMICOLON
    (96) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (99) iteration_statement -> . while_clause
    (100) iteration_statement -> . for_clause
    (105) jump_statement -> . BREAK SEMICOLON
    (106) jump_statement -> . CONTINUE SEMICOLON
    (107) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (94) expression_opt -> . expression
    (95) expression_opt -> . empty
    (101) while_clause -> . WHILE LPAREN expression RPAREN statement
    (102) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (167) empty -> .
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty

    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 50
    CONTINUE        shift and go to state 51
    RETURN          shift and go to state 52
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SEMICOLON       reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    statement                      shift and go to state 301
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    expression_opt                 shift and go to state 45
    expression                     shift and go to state 47
    while_clause                   shift and go to state 48
    for_clause                     shift and go to state 49
    empty                          shift and go to state 106
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60

state 291

    (98) statement_else_opt -> empty .

    ELSE            reduce using rule 98 (statement_else_opt -> empty .)
    LBRACE          reduce using rule 98 (statement_else_opt -> empty .)
    IF              reduce using rule 98 (statement_else_opt -> empty .)
    BREAK           reduce using rule 98 (statement_else_opt -> empty .)
    CONTINUE        reduce using rule 98 (statement_else_opt -> empty .)
    RETURN          reduce using rule 98 (statement_else_opt -> empty .)
    LET             reduce using rule 98 (statement_else_opt -> empty .)
    CONST           reduce using rule 98 (statement_else_opt -> empty .)
    WHILE           reduce using rule 98 (statement_else_opt -> empty .)
    FOR             reduce using rule 98 (statement_else_opt -> empty .)
    NOT             reduce using rule 98 (statement_else_opt -> empty .)
    LOGICAL_NOT     reduce using rule 98 (statement_else_opt -> empty .)
    PLUS            reduce using rule 98 (statement_else_opt -> empty .)
    MINUS           reduce using rule 98 (statement_else_opt -> empty .)
    SEMICOLON       reduce using rule 98 (statement_else_opt -> empty .)
    INT             reduce using rule 98 (statement_else_opt -> empty .)
    HEXADECIMAL     reduce using rule 98 (statement_else_opt -> empty .)
    FLOAT           reduce using rule 98 (statement_else_opt -> empty .)
    DOUBLE          reduce using rule 98 (statement_else_opt -> empty .)
    STRING          reduce using rule 98 (statement_else_opt -> empty .)
    ID              reduce using rule 98 (statement_else_opt -> empty .)
    LPAREN          reduce using rule 98 (statement_else_opt -> empty .)
    IN              reduce using rule 98 (statement_else_opt -> empty .)
    OUT             reduce using rule 98 (statement_else_opt -> empty .)
    VOID            reduce using rule 98 (statement_else_opt -> empty .)
    BOOL            reduce using rule 98 (statement_else_opt -> empty .)
    I8              reduce using rule 98 (statement_else_opt -> empty .)
    U8              reduce using rule 98 (statement_else_opt -> empty .)
    I16             reduce using rule 98 (statement_else_opt -> empty .)
    U16             reduce using rule 98 (statement_else_opt -> empty .)
    I32             reduce using rule 98 (statement_else_opt -> empty .)
    U32             reduce using rule 98 (statement_else_opt -> empty .)
    I64             reduce using rule 98 (statement_else_opt -> empty .)
    U64             reduce using rule 98 (statement_else_opt -> empty .)
    F16             reduce using rule 98 (statement_else_opt -> empty .)
    F32             reduce using rule 98 (statement_else_opt -> empty .)
    F64             reduce using rule 98 (statement_else_opt -> empty .)
    LANGRBRACKET    reduce using rule 98 (statement_else_opt -> empty .)
    RBRACE          reduce using rule 98 (statement_else_opt -> empty .)


state 292

    (102) for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression . RPAREN statement
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression

    RPAREN          shift and go to state 302
    ASSIGN          shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_OR      shift and go to state 95
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102


state 293

    (156) call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .

    LBRACKET        reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    LANGRBRACKET    reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    LPAREN          reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    ASSIGN          reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    PLUS            reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    MINUS           reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    MUL             reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    DIV             reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    AND             reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    OR              reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    XOR             reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    MOD             reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    LSHIFT          reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    RSHIFT          reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    LOGICAL_OR      reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    LOGICAL_AND     reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    NOT_EQUAL       reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    EQUAL           reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    LESS_EQUAL      reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    LESS            reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    GREATER_EQUAL   reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    GREATER         reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    SEMICOLON       reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    RPAREN          reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    COMMA           reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)
    RBRACKET        reduce using rule 156 (call_expr -> primary_expr generics_specialization_list_opt LPAREN parameter_list_opt RPAREN .)


state 294

    (157) generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET .

    LPAREN          reduce using rule 157 (generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET .)
    LBRACKET        reduce using rule 157 (generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET .)
    REF             reduce using rule 157 (generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET .)
    ASSIGN          reduce using rule 157 (generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET .)
    COMMA           reduce using rule 157 (generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET .)
    RPAREN          reduce using rule 157 (generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET .)
    SEMICOLON       reduce using rule 157 (generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET .)
    RANGRBRACKET    reduce using rule 157 (generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET .)
    LBRACE          reduce using rule 157 (generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET .)
    LANGRBRACKET    reduce using rule 157 (generics_specialization_list_opt -> LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET .)


state 295

    (159) type_spec_comma_nest -> COMMA type_spec . type_spec_comma_nest
    (43) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> type_spec . REF
    (159) type_spec_comma_nest -> . COMMA type_spec type_spec_comma_nest
    (160) type_spec_comma_nest -> . empty
    (167) empty -> .

    LBRACKET        shift and go to state 196
    REF             shift and go to state 197
    COMMA           shift and go to state 267
    RANGRBRACKET    reduce using rule 167 (empty -> .)

    type_spec_comma_nest           shift and go to state 303
    empty                          shift and go to state 268

state 296

    (162) expression_comma_nest -> COMMA expression . expression_comma_nest
    (111) assign_expr -> expression . ASSIGN expression
    (112) binary_expr -> expression . PLUS expression
    (113) binary_expr -> expression . MINUS expression
    (114) binary_expr -> expression . MUL expression
    (115) binary_expr -> expression . DIV expression
    (116) binary_expr -> expression . AND expression
    (117) binary_expr -> expression . OR expression
    (118) binary_expr -> expression . XOR expression
    (119) binary_expr -> expression . MOD expression
    (120) binary_expr -> expression . LSHIFT expression
    (121) binary_expr -> expression . RSHIFT expression
    (122) binary_expr -> expression . LOGICAL_OR expression
    (123) binary_expr -> expression . LOGICAL_AND expression
    (124) binary_expr -> expression . NOT_EQUAL expression
    (125) binary_expr -> expression . EQUAL expression
    (126) binary_expr -> expression . LESS_EQUAL expression
    (127) binary_expr -> expression . LESS expression
    (128) binary_expr -> expression . GREATER_EQUAL expression
    (129) binary_expr -> expression . GREATER expression
    (162) expression_comma_nest -> . COMMA expression expression_comma_nest
    (163) expression_comma_nest -> . empty
    (167) empty -> .

    ASSIGN          shift and go to state 84
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    MUL             shift and go to state 87
    DIV             shift and go to state 88
    AND             shift and go to state 89
    OR              shift and go to state 90
    XOR             shift and go to state 91
    MOD             shift and go to state 92
    LSHIFT          shift and go to state 93
    RSHIFT          shift and go to state 94
    LOGICAL_OR      shift and go to state 95
    LOGICAL_AND     shift and go to state 96
    NOT_EQUAL       shift and go to state 97
    EQUAL           shift and go to state 98
    LESS_EQUAL      shift and go to state 99
    LESS            shift and go to state 100
    GREATER_EQUAL   shift and go to state 101
    GREATER         shift and go to state 102
    COMMA           shift and go to state 272
    RPAREN          reduce using rule 167 (empty -> .)

    expression_comma_nest          shift and go to state 304
    empty                          shift and go to state 273

state 297

    (164) io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN . STRING RPAREN

    STRING          shift and go to state 305


state 298

    (70) type_spec_assigntype_opt -> ASSIGNTYPE type_spec .
    (43) array_type -> type_spec . LBRACKET int_literal_opt RBRACKET
    (46) reference_type -> type_spec . REF

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for REF resolved as shift
    SEMICOLON       reduce using rule 70 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    LBRACE          reduce using rule 70 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    LPAREN          reduce using rule 70 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    ASSIGN          reduce using rule 70 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    COMMA           reduce using rule 70 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    RPAREN          reduce using rule 70 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    RANGRBRACKET    reduce using rule 70 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    LANGRBRACKET    reduce using rule 70 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .)
    LBRACKET        shift and go to state 196
    REF             shift and go to state 197

  ! LBRACKET        [ reduce using rule 70 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .) ]
  ! REF             [ reduce using rule 70 (type_spec_assigntype_opt -> ASSIGNTYPE type_spec .) ]


state 299

    (72) parameter_decl_comma_nest -> COMMA parameter_decl parameter_decl_comma_nest .

    RPAREN          reduce using rule 72 (parameter_decl_comma_nest -> COMMA parameter_decl parameter_decl_comma_nest .)


state 300

    (78) generics_type -> ID . generics_type_range_colon_opt
    (41) complex_type -> ID . generics_specialization_list_opt
    (42) generic_type -> ID .
    (79) generics_type_range_colon_opt -> . COLON generics_type_range
    (80) generics_type_range_colon_opt -> . empty
    (157) generics_specialization_list_opt -> . LANGRBRACKET type_spec type_spec_comma_nest RANGRBRACKET
    (158) generics_specialization_list_opt -> . empty
    (167) empty -> .

  ! reduce/reduce conflict for COMMA resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for RANGRBRACKET resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 42 (generic_type -> ID .)
  ! reduce/reduce conflict for REF resolved using rule 42 (generic_type -> ID .)
    LBRACKET        reduce using rule 42 (generic_type -> ID .)
    REF             reduce using rule 42 (generic_type -> ID .)
    COMMA           reduce using rule 42 (generic_type -> ID .)
    RANGRBRACKET    reduce using rule 42 (generic_type -> ID .)
    COLON           shift and go to state 209
    LANGRBRACKET    shift and go to state 188

  ! COMMA           [ reduce using rule 167 (empty -> .) ]
  ! RANGRBRACKET    [ reduce using rule 167 (empty -> .) ]
  ! LBRACKET        [ reduce using rule 167 (empty -> .) ]
  ! REF             [ reduce using rule 167 (empty -> .) ]

    generics_type_range_colon_opt  shift and go to state 208
    generics_specialization_list_opt shift and go to state 191
    empty                          shift and go to state 306

state 301

    (97) statement_else_opt -> ELSE statement .

    ELSE            reduce using rule 97 (statement_else_opt -> ELSE statement .)
    LBRACE          reduce using rule 97 (statement_else_opt -> ELSE statement .)
    IF              reduce using rule 97 (statement_else_opt -> ELSE statement .)
    BREAK           reduce using rule 97 (statement_else_opt -> ELSE statement .)
    CONTINUE        reduce using rule 97 (statement_else_opt -> ELSE statement .)
    RETURN          reduce using rule 97 (statement_else_opt -> ELSE statement .)
    LET             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    CONST           reduce using rule 97 (statement_else_opt -> ELSE statement .)
    WHILE           reduce using rule 97 (statement_else_opt -> ELSE statement .)
    FOR             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    NOT             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    LOGICAL_NOT     reduce using rule 97 (statement_else_opt -> ELSE statement .)
    PLUS            reduce using rule 97 (statement_else_opt -> ELSE statement .)
    MINUS           reduce using rule 97 (statement_else_opt -> ELSE statement .)
    SEMICOLON       reduce using rule 97 (statement_else_opt -> ELSE statement .)
    INT             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    HEXADECIMAL     reduce using rule 97 (statement_else_opt -> ELSE statement .)
    FLOAT           reduce using rule 97 (statement_else_opt -> ELSE statement .)
    DOUBLE          reduce using rule 97 (statement_else_opt -> ELSE statement .)
    STRING          reduce using rule 97 (statement_else_opt -> ELSE statement .)
    ID              reduce using rule 97 (statement_else_opt -> ELSE statement .)
    LPAREN          reduce using rule 97 (statement_else_opt -> ELSE statement .)
    IN              reduce using rule 97 (statement_else_opt -> ELSE statement .)
    OUT             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    VOID            reduce using rule 97 (statement_else_opt -> ELSE statement .)
    BOOL            reduce using rule 97 (statement_else_opt -> ELSE statement .)
    I8              reduce using rule 97 (statement_else_opt -> ELSE statement .)
    U8              reduce using rule 97 (statement_else_opt -> ELSE statement .)
    I16             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    U16             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    I32             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    U32             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    I64             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    U64             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    F16             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    F32             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    F64             reduce using rule 97 (statement_else_opt -> ELSE statement .)
    LANGRBRACKET    reduce using rule 97 (statement_else_opt -> ELSE statement .)
    RBRACE          reduce using rule 97 (statement_else_opt -> ELSE statement .)


state 302

    (102) for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN . statement
    (82) statement -> . decl_statement
    (83) statement -> . block_statement
    (84) statement -> . expression_statement
    (85) statement -> . if_statement
    (86) statement -> . iteration_statement
    (87) statement -> . jump_statement
    (88) decl_statement -> . variable_decl SEMICOLON
    (89) decl_statement -> . constant_decl SEMICOLON
    (90) block_statement -> . LBRACE statement_nest RBRACE
    (93) expression_statement -> . expression_opt SEMICOLON
    (96) if_statement -> . IF LPAREN expression RPAREN statement statement_else_opt
    (99) iteration_statement -> . while_clause
    (100) iteration_statement -> . for_clause
    (105) jump_statement -> . BREAK SEMICOLON
    (106) jump_statement -> . CONTINUE SEMICOLON
    (107) jump_statement -> . RETURN expression_opt SEMICOLON
    (13) variable_decl -> . LET declarator declarator_nest
    (16) constant_decl -> . CONST declarator declarator_nest
    (94) expression_opt -> . expression
    (95) expression_opt -> . empty
    (101) while_clause -> . WHILE LPAREN expression RPAREN statement
    (102) for_clause -> . FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement
    (108) expression -> . assign_expr
    (109) expression -> . binary_expr
    (110) expression -> . unary_expr
    (167) empty -> .
    (111) assign_expr -> . expression ASSIGN expression
    (112) binary_expr -> . expression PLUS expression
    (113) binary_expr -> . expression MINUS expression
    (114) binary_expr -> . expression MUL expression
    (115) binary_expr -> . expression DIV expression
    (116) binary_expr -> . expression AND expression
    (117) binary_expr -> . expression OR expression
    (118) binary_expr -> . expression XOR expression
    (119) binary_expr -> . expression MOD expression
    (120) binary_expr -> . expression LSHIFT expression
    (121) binary_expr -> . expression RSHIFT expression
    (122) binary_expr -> . expression LOGICAL_OR expression
    (123) binary_expr -> . expression LOGICAL_AND expression
    (124) binary_expr -> . expression NOT_EQUAL expression
    (125) binary_expr -> . expression EQUAL expression
    (126) binary_expr -> . expression LESS_EQUAL expression
    (127) binary_expr -> . expression LESS expression
    (128) binary_expr -> . expression GREATER_EQUAL expression
    (129) binary_expr -> . expression GREATER expression
    (130) unary_expr -> . unary_operation_opt primary_expr
    (131) unary_operation_opt -> . NOT
    (132) unary_operation_opt -> . LOGICAL_NOT
    (133) unary_operation_opt -> . PLUS
    (134) unary_operation_opt -> . MINUS
    (135) unary_operation_opt -> . empty

    LBRACE          shift and go to state 26
    IF              shift and go to state 46
    BREAK           shift and go to state 50
    CONTINUE        shift and go to state 51
    RETURN          shift and go to state 52
    LET             shift and go to state 13
    CONST           shift and go to state 14
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    SEMICOLON       reduce using rule 167 (empty -> .)
    INT             reduce using rule 167 (empty -> .)
    HEXADECIMAL     reduce using rule 167 (empty -> .)
    FLOAT           reduce using rule 167 (empty -> .)
    DOUBLE          reduce using rule 167 (empty -> .)
    STRING          reduce using rule 167 (empty -> .)
    ID              reduce using rule 167 (empty -> .)
    LPAREN          reduce using rule 167 (empty -> .)
    IN              reduce using rule 167 (empty -> .)
    OUT             reduce using rule 167 (empty -> .)
    VOID            reduce using rule 167 (empty -> .)
    BOOL            reduce using rule 167 (empty -> .)
    I8              reduce using rule 167 (empty -> .)
    U8              reduce using rule 167 (empty -> .)
    I16             reduce using rule 167 (empty -> .)
    U16             reduce using rule 167 (empty -> .)
    I32             reduce using rule 167 (empty -> .)
    U32             reduce using rule 167 (empty -> .)
    I64             reduce using rule 167 (empty -> .)
    U64             reduce using rule 167 (empty -> .)
    F16             reduce using rule 167 (empty -> .)
    F32             reduce using rule 167 (empty -> .)
    F64             reduce using rule 167 (empty -> .)
    LANGRBRACKET    reduce using rule 167 (empty -> .)
    NOT             shift and go to state 61
    LOGICAL_NOT     shift and go to state 62
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59

    expression_opt                 shift and go to state 45
    expression                     shift and go to state 47
    statement                      shift and go to state 307
    decl_statement                 shift and go to state 37
    block_statement                shift and go to state 38
    expression_statement           shift and go to state 39
    if_statement                   shift and go to state 40
    iteration_statement            shift and go to state 41
    jump_statement                 shift and go to state 42
    variable_decl                  shift and go to state 43
    constant_decl                  shift and go to state 44
    while_clause                   shift and go to state 48
    for_clause                     shift and go to state 49
    empty                          shift and go to state 106
    assign_expr                    shift and go to state 55
    binary_expr                    shift and go to state 56
    unary_expr                     shift and go to state 57
    unary_operation_opt            shift and go to state 60

state 303

    (159) type_spec_comma_nest -> COMMA type_spec type_spec_comma_nest .

    RANGRBRACKET    reduce using rule 159 (type_spec_comma_nest -> COMMA type_spec type_spec_comma_nest .)


state 304

    (162) expression_comma_nest -> COMMA expression expression_comma_nest .

    RPAREN          reduce using rule 162 (expression_comma_nest -> COMMA expression expression_comma_nest .)


state 305

    (164) io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING . RPAREN

    RPAREN          shift and go to state 308


state 306

    (80) generics_type_range_colon_opt -> empty .
    (158) generics_specialization_list_opt -> empty .

  ! reduce/reduce conflict for COMMA resolved using rule 80 (generics_type_range_colon_opt -> empty .)
  ! reduce/reduce conflict for RANGRBRACKET resolved using rule 80 (generics_type_range_colon_opt -> empty .)
    COMMA           reduce using rule 80 (generics_type_range_colon_opt -> empty .)
    RANGRBRACKET    reduce using rule 80 (generics_type_range_colon_opt -> empty .)
    LBRACKET        reduce using rule 158 (generics_specialization_list_opt -> empty .)
    REF             reduce using rule 158 (generics_specialization_list_opt -> empty .)

  ! COMMA           [ reduce using rule 158 (generics_specialization_list_opt -> empty .) ]
  ! RANGRBRACKET    [ reduce using rule 158 (generics_specialization_list_opt -> empty .) ]


state 307

    (102) for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .

    LBRACE          reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    IF              reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    BREAK           reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    CONTINUE        reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    RETURN          reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    LET             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    CONST           reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    WHILE           reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    FOR             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    NOT             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    LOGICAL_NOT     reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    PLUS            reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    MINUS           reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    SEMICOLON       reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    INT             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    HEXADECIMAL     reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    FLOAT           reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    DOUBLE          reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    STRING          reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    ID              reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    LPAREN          reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    IN              reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    OUT             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    VOID            reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    BOOL            reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    I8              reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    U8              reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    I16             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    U16             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    I32             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    U32             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    I64             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    U64             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    F16             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    F32             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    F64             reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    LANGRBRACKET    reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    RBRACE          reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)
    ELSE            reduce using rule 102 (for_clause -> FOR LPAREN for_init_statement expression_opt SEMICOLON expression RPAREN statement .)


state 308

    (164) io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .

    LBRACKET        reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    LANGRBRACKET    reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    LPAREN          reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    ASSIGN          reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    PLUS            reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    MINUS           reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    MUL             reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    DIV             reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    AND             reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    OR              reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    XOR             reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    MOD             reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    LSHIFT          reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    RSHIFT          reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    LOGICAL_OR      reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    LOGICAL_AND     reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    NOT_EQUAL       reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    EQUAL           reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    LESS_EQUAL      reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    LESS            reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    GREATER_EQUAL   reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    GREATER         reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    SEMICOLON       reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    RPAREN          reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    COMMA           reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)
    RBRACKET        reduce using rule 164 (io_expr -> in_out LANGRBRACKET type_spec RANGRBRACKET LPAREN STRING RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LPAREN in state 60 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 109 resolved as shift
WARNING: shift/reduce conflict for LANGRBRACKET in state 109 resolved as shift
WARNING: shift/reduce conflict for LANGRBRACKET in state 122 resolved as shift
WARNING: shift/reduce conflict for ID in state 123 resolved as shift
WARNING: shift/reduce conflict for VOID in state 123 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 123 resolved as shift
WARNING: shift/reduce conflict for I8 in state 123 resolved as shift
WARNING: shift/reduce conflict for U8 in state 123 resolved as shift
WARNING: shift/reduce conflict for I16 in state 123 resolved as shift
WARNING: shift/reduce conflict for U16 in state 123 resolved as shift
WARNING: shift/reduce conflict for I32 in state 123 resolved as shift
WARNING: shift/reduce conflict for U32 in state 123 resolved as shift
WARNING: shift/reduce conflict for I64 in state 123 resolved as shift
WARNING: shift/reduce conflict for U64 in state 123 resolved as shift
WARNING: shift/reduce conflict for F16 in state 123 resolved as shift
WARNING: shift/reduce conflict for F32 in state 123 resolved as shift
WARNING: shift/reduce conflict for F64 in state 123 resolved as shift
WARNING: shift/reduce conflict for LANGRBRACKET in state 123 resolved as shift
WARNING: shift/reduce conflict for LANGRBRACKET in state 151 resolved as shift
WARNING: shift/reduce conflict for LANGRBRACKET in state 151 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 162 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 162 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 162 resolved as shift
WARNING: shift/reduce conflict for MUL in state 162 resolved as shift
WARNING: shift/reduce conflict for DIV in state 162 resolved as shift
WARNING: shift/reduce conflict for AND in state 162 resolved as shift
WARNING: shift/reduce conflict for OR in state 162 resolved as shift
WARNING: shift/reduce conflict for XOR in state 162 resolved as shift
WARNING: shift/reduce conflict for MOD in state 162 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 162 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 162 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 162 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 162 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 162 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 162 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 162 resolved as shift
WARNING: shift/reduce conflict for LESS in state 162 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 162 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 162 resolved as shift
WARNING: shift/reduce conflict for LANGRBRACKET in state 259 resolved as shift
WARNING: shift/reduce conflict for LANGRBRACKET in state 259 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 261 resolved as shift
WARNING: shift/reduce conflict for ASSIGN in state 269 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 269 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 269 resolved as shift
WARNING: shift/reduce conflict for MUL in state 269 resolved as shift
WARNING: shift/reduce conflict for DIV in state 269 resolved as shift
WARNING: shift/reduce conflict for AND in state 269 resolved as shift
WARNING: shift/reduce conflict for OR in state 269 resolved as shift
WARNING: shift/reduce conflict for XOR in state 269 resolved as shift
WARNING: shift/reduce conflict for MOD in state 269 resolved as shift
WARNING: shift/reduce conflict for LSHIFT in state 269 resolved as shift
WARNING: shift/reduce conflict for RSHIFT in state 269 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_OR in state 269 resolved as shift
WARNING: shift/reduce conflict for LOGICAL_AND in state 269 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 269 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 269 resolved as shift
WARNING: shift/reduce conflict for LESS_EQUAL in state 269 resolved as shift
WARNING: shift/reduce conflict for LESS in state 269 resolved as shift
WARNING: shift/reduce conflict for GREATER_EQUAL in state 269 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 269 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 298 resolved as shift
WARNING: shift/reduce conflict for REF in state 298 resolved as shift
WARNING: reduce/reduce conflict in state 109 resolved using rule (unary_expr -> unary_operation_opt primary_expr)
WARNING: rejected rule (empty -> <empty>) in state 109
WARNING: reduce/reduce conflict in state 122 resolved using rule (generic_type -> ID)
WARNING: rejected rule (operand -> ID) in state 122
WARNING: reduce/reduce conflict in state 122 resolved using rule (generic_type -> ID)
WARNING: rejected rule (empty -> <empty>) in state 122
WARNING: reduce/reduce conflict in state 151 resolved using rule (generic_type -> ID)
WARNING: rejected rule (empty -> <empty>) in state 151
WARNING: reduce/reduce conflict in state 194 resolved using rule (generics_type_list_opt -> empty)
WARNING: rejected rule (unary_operation_opt -> empty) in state 194
WARNING: reduce/reduce conflict in state 259 resolved using rule (generic_type -> ID)
WARNING: rejected rule (empty -> <empty>) in state 259
WARNING: reduce/reduce conflict in state 287 resolved using rule (generics_type_list_opt -> empty)
WARNING: rejected rule (generics_specialization_list_opt -> empty) in state 287
WARNING: reduce/reduce conflict in state 300 resolved using rule (generic_type -> ID)
WARNING: rejected rule (empty -> <empty>) in state 300
WARNING: reduce/reduce conflict in state 306 resolved using rule (generics_type_range_colon_opt -> empty)
WARNING: rejected rule (generics_specialization_list_opt -> empty) in state 306
